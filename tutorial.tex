\chapter{Tutorial} \label{ch:tutorial}

\textit{How do I write a Steve program?} This chapter will answer this question through examples. Steve's primary focus is to provide language features for defining and connecting the pipeline processing stages described in Chapter \ref{ch:pipeline_model}. This chapter will explain how we write each of these components. Specifically, we will talk about how headers are represented, how to write decoders, how to write tables, and how to apply actions to packets.

By the end of this chapter, a user should be able to write many basic network applications using Steve. Three such applications will be presented: a simple learning switch, a simple learning router and a wire. Many of the examples presented throughout this chapter are just smaller parts of these applications presented in isolation. As we work through this tutorial, we will slowly build up these little components and explain what they do before finally presenting the complete program at the end.  

However, if you are feeling impatient, you may skip directly to these examples in Section \ref{tut:examples}.

As we walk through this tutorial, we will mention some semantics and limitations of Steve, but only in minor detail. For the complete semantic description of Steve, including grammar, typing rules, and other restrictions, see the User's Guide in Chapter \ref{ch:users_guide}. For a complete reference of all Steve grammar, see Appendix \ref{ap:a}.

\section{General Purpose Language Features} \label{tut:gen_purp}

Before we delve into language features specifically designed for packet processing, first we must mention a few language features which are more "general purpose." These language features are common to most programming languages and are not explicitly for packet processing, though they may prove useful. These language features are provided as part of the Beaker programming language \footnote{https://github.com/asutton/beaker} from which Steve derives.

\subsection{Variables} \label{tut:variable}

Steve allows us to allocate variables for storing values like any other language. Suppose we wanted to write a variable named \texttt{x} which holds an integer value \texttt{10}. We would write it as follows.

\begin{codepage}
\begin{lstlisting}
var x : int = 10;
\end{lstlisting}
\end{codepage}

Note that the type of the variable, \texttt{int}, follows the colon (\texttt{:}). We can assign a new value to it.

\begin{codepage}
\begin{lstlisting}
x = 1;
\end{lstlisting}
\end{codepage}

We can perform arithmetic and bitwise operations as well. The complete set of arithmetic and bitwise operations can be found in Section \ref{guide:binary_expr}.

\begin{codepage}
\begin{lstlisting}
var y : int = 2;
var z : int = 3;
y = x + y; // Adding
z = y + z + 1; 
z = z << 4; // Left shift.
var a : int = y & z; // bitwise and
\end{lstlisting}
\end{codepage}


\subsection{Conditional Statements} \label{tut:condition}

Steve supports some common language constructs for conditional decision making. Specifically, we have three conditional statements: the if statement, the if-else statement, and the match statement.

The if and if-else statements are written just like in most C-like languages. The behavior works the same as well.

\begin{codepage}
\begin{lstlisting}
var a : bool = true;
var b : bool = false;

// If statement
if (a || b) { }

// If else statement
if (a && b) { }
else if (a) { }
else { }
\end{lstlisting}
\end{codepage}

A match statement allows for a decision to be made given a number of possible case values. This makes it similar to a C-like switch statement, with the only major difference being that there is no "fall-through" behavior. In other words, after the execution of a case statement, control jumps out of the match statement rather than moving to the next case (i.e. an implied break). The condition and labels must be integers just like in C. A match statements can be written as follows.

\begin{codepage}
\begin{lstlisting}
// Assuming there are integer variables named x and y.
match (x) {
  case 0: x = x + 1;
  // Multiple statements following the label must be 
  // enclosed in a block.
  case 1: {
    x = x + 2;
    y = y * x;
  }
  
  // The default case statement.
  miss: x = 0;
}
\end{lstlisting}
\end{codepage}

Here, if \texttt{x} equals \texttt{0}, then \texttt{x = x + 1} gets executed. If \texttt{x} equals \texttt{1}, then two statements get executed in order: \texttt{x = x + 2}, then \texttt{y = y * x}. If \texttt{x} is neither, then \texttt{x = 0} is executed.

\subsection{While Loops} \label{tut:while}

While loops appear in Steve just like they appear in C-like languages. They also support the \texttt{break} and \texttt{continue} statements for limited branching abilities inside a loop.

In the following, we present a trivial while loop which demonstrate the basics of \texttt{break} and \texttt{continue}.

\begin{codepage}
\begin{lstlisting}
var x : int = 0;
var z : int = 0;
// Loop while x is less than 5.
while (x < 5) {
  x = x + 1;
  // If x equals 3, control goes back to the
  // first statement in the loop body.
  if (x == 3)
    continue;
    
  // This part is never reached if x == 2.
  // If z equals 2, then we exit the loop
  // altogether.
  if (z == 2) 
    break;
  // This will never execute when z == 2.
  z = z + 1;
}
\end{lstlisting}
\end{codepage}

Here, the value of \texttt{x} will end up being \texttt{4} and \texttt{z} will be \texttt{2} by the end of this loop.

The usage of while loops in packet processing right now is rather limited. Usage of loops will rarely come up in defining pipeline processing stages. However, they may become more useful as other features are added.

\subsection{Functions} \label{tut:function}

Steve supports writing simple functions, though the syntax is a little different from C-like languages. Functions can be called with parameters and can return results just like any other language. 

Suppose we wanted to write a function named \texttt{sum} which takes two integers, \texttt{a} and \texttt{b}, and returned the integer sum of \texttt{a} and \texttt{b}. We would write \texttt{sum} as follows.

\begin{codepage}
\begin{lstlisting}
def sum(a : int, b : int) -> int
{
  return a + b;
}
\end{lstlisting}
\end{codepage}

Note that the return type follows the \texttt{->} in Steve functions. To call the \texttt{sum} function we would write the following. Here, the result of \texttt{sum} would be \texttt{3}.

\begin{codepage}
\begin{lstlisting}
var x : int = 1;
var y : int = 2;
var z : int = sum(x, y);
\end{lstlisting}
\end{codepage}

\subsection{Literals} \label{tut:literal}

Steve supports decimal, binary, and hexadecimal integer literals. Steve does not currently support things like IP address literals or MAC address literals. Decimal integers can be written like any other language.

Binary literals all start with the prefix \texttt{0b} followed by any number of \texttt{0}'s and \texttt{1}'s. The underscore (\texttt{\_}) can optionally occur anywhere in the literal following the prefix; a feature similar to Java. This is purely for organization and readability.

\begin{codepage}
\begin{lstlisting}
// These are the same value.
0b10101010
0b1010_1010
\end{lstlisting}
\end{codepage}

Hexadecimal literals all start with the prefix \texttt{0x} followed by any number of digits between \texttt{0} and \texttt{9}. The underscore (\texttt{\_}) can optionally occur anywhere in the literal following the prefix similar to binary literals.

\begin{codepage}
\begin{lstlisting}
// These are the same value.
0x0800
0x08_00
\end{lstlisting}
\end{codepage}

\section{Layouts} \label{tut:layout}

Now that we've gotten the general purpose things out of the way, we can move on to packet processing specific language features.

\textit{Layouts} are something which will appear in almost all Steve programs. They let us describe the \textit{structure} of a packet header. More specifically, they describe \textit{what} fields are present, their \textit{lengths}, the \textit{order} in which they appear, and their \textit{relative offset} from the beginning of the header. Layouts become pivotal during decoding stages, where all this information is used to guide the extraction of fields from a packet. 

\textit{What is the difference between a layout and a header?} Before moving on, it is important to make this distinction clear. A layout is like a blueprint for a header. It gives us information; it \textit{describes} that header. The header is an actual sequence of bits, a portion of the packet, which we get off of the network. The header \textit{exists} whereas a layout merely helps us \textit{understands} it.d. 

\textit{How does one write a layout?} Let us begin with a simple example: the ethernet header \cite{eth_std}. Ethernet is probably the most common Layer 2 (\cite{osi_model} protocol in use. The first header most programs decode is ethernet.

An ethernet header has three fields: \texttt{dst} and \texttt{src} which are both 6 bytes (or 48-bits) long, and a type field which is 2 bytes (or 16-bits long). To write a layout describing the ethernet header, we use a \textit{layout declaration} (\ref{guide:layout}). In the following, we present an ethernet layout declaration matching these specifications.

\begin{codepage}
\begin{lstlisting}
// This layout describes the ethernet header.
layout ethernet
{
	// Each field is a pair of names and types.
	// Each type specifies that field's length.
	dst  : uint(48); // This is 48 bits long.
	src  : uint(48); // This is 48 bits long.
	type : uint(16); // This is 16 bits long.
}
\end{lstlisting}
\end{codepage}

Here, we declare a layout named \texttt{ethernet}. Each layout defines which fields it has with a \textit{field declarations} (\ref{guide:layout}). Each field is given a \textit{name} and a \textit{type} (\ref{guide:type}). In this example, we declare three such fields: \texttt{dst}, \texttt{src}, and \texttt{type}. The \textit{length} of each field is denoted by the \textit{size} required to store an object of that \textit{type}. Here, each field has unsigned integer type (\ref{guide:integer_type}), \texttt{uint}, with an (optional) precision. The precision denotes the size (in bits) needed to store that integer. Thus the \texttt{dst} and \texttt{src} fields have a length of 48 bits, and the \texttt{type} field has a length of 16 bits.

The \textit{relative offset} of each field is the number of bytes it is away from the beginning of the header. The first field will always have a relative offset of 0 bytes. The relative offset of each subsequent field is equal to the sum of the lengths of all fields preceding it. Here, \texttt{dst} has a relative offset of 0 bytes, \texttt{src} has one of 6 bytes, and \texttt{type} has one of 12 bytes.

Note that the fields appear in the order with which they would normally appear in an ethernet header. This is important. Field ordering should always be preserved when declaring layouts. If the ordering is incorrect, decoders will assume a sequence of bits is a certain field when it truly is not.

Not all header structures are as simple as the ethernet header. Sometimes we must deal with headers nested inside headers. It is for this very reason, that we allow layouts to be nested. 

In the following, we present such a case, where we expect a VLAN header \cite{vlan_std} is nested right before the \texttt{type} field of an ethernet header. 

\begin{codepage}
\begin{lstlisting}
// Layouts may be nested like this.
layout ethernet
{
  dst  : uint(48);
  src  : uint(48);
  vlan_tag : vlan; // Nested layout
  type : uint(16);
}

layout vlan
{
  type : uint(16);
  tci  : uint(16);
}
\end{lstlisting}
\end{codepage}

In this example, we declare two layouts: \texttt{ethernet} and \texttt{vlan}. To achieve a nested layout, we add a field named \texttt{vlan\_tag} to \texttt{ethernet}, and we give its type as the name of the layout, \texttt{vlan}. Then length of the \texttt{vlan\_tag} field would be the sum of its sub-fields, in this case, 32 bits.

\textit{How do layouts differ from classes in other languages?} With the way layouts are described, it is easy to draw the comparison between layouts and classes in object-oriented languages. However, layouts do \textbf{not} function like classes at all. Layouts are much stricter.

First of all, \textit{the types of each field are restricted}. Fields may only have two types: integer (\ref{guide:integer_type}) and layout (\ref{guide:layout_type}). There may be varying kinds of integer (e.g. precisions, signed, unsigned, etc.), but the precision of each integer must also be \textit{byte-aligned}, that is, a multiple of 8. 

Second, the most important distinction is that \textit{objects of layout type can never be created}. Layouts may not appear as the type of parameters, nor may they appear as return types. All of the following are considered illegal.

\begin{codepage}
\begin{lstlisting}
layout L1 { f1 : uint; f2 : uint(16); }
var x : L1 = 0; // Invalid.
// Invalid parameter type and return type.
def foo(y : L1) -> L1 { ... }
\end{lstlisting}
\end{codepage} 

Packets and their headers exist independent of a running Steve application. Layouts are purely used to guide decoding them. Additionally, there are a number of concerns related to constructing objects of layout type, thus such behavior is not allowed. For further details on layout limitations, refer to Section \ref{guide:layout} in the User's Guide.

Another important note is that Steve does not currently support dynamically sized types (DST). A DST is a type whose size is predicated upon some value known only during runtime. These DST's are used to represent fields whose lengths are dynamic. Some examples of dynamic length fields are the \texttt{options} fields in IPv4, IPv6, and TCP headers \cite{ipv4_std, ipv6_std, tcp_std}.

DST's are a language feature that will eventually be added, but are outside the current implementation. Because of this, fields whose lengths are dynamic cannot currently be declared, extracted, nor used. The existence and eventual support of DST's is one of the reasons why objects of layout type cannot be created which is further discussed in Section \ref{guide:layout}.

In the following, we present a case where some of these limitations come into play -- the IPv4 layout. IPv4 is a Layer 3 protocol \cite{osi_model} and is used for routing. An IPv4 header appears in almost all Internet-bound packets and thus makes it a common layout to write. This layout will prove useful to us when defining the simple router program later on.

\begin{codepage}
\begin{lstlisting}
layout ipv4
{
  version_ihl : uint(8); // Non-byte aligned fields are merged.
  dscp_ecn    : uint(8);  // This is merged, too.
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16); // Fragment usually has flags.
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
  // Note, the missing, unsupported options field.
}
\end{lstlisting}
\end{codepage}

In this example, we can seen that \texttt{version} (a 4 bit field) has to be merged with \texttt{ihl} (internet header length) (also a 4 bit field) to achieve byte alignment. The same is true for \texttt{dscp} and \texttt{ecn}. The \texttt{fragment} field, typically composed of three 1 bit flags and a 13 bit fragment offset field, is merged into a single 16 bit field. To recover the values of these sub-fields, we have to use logical-and (\ref{guide:bitwise_expr}) to mask the un-needed bits. An example will come up later when we discuss an IPv4 decoder.

\section{Decoders} \label{tut:decoder}

Decoding stages, or \textit{decoders} for short, are special purpose functions used to handle decoding and extracting fields from a \textit{single} header. By chaining multiple decoders together, a user can construct a sequence of functions used to parse an entire packet. 

When writing a decoder, it is good practice to keep the following in mind.

\begin{itemize}
\item Which header am I decoding? What layout will I use to guide the decoder?

\item What fields do I want from the header?

\item How will I use the extracted fields? Will I need to perform arithmetic or make decisions with them?

\item \textit{Actions} are used to manipulate packet fields, forward packets, and add/remove flow entries from tables. What actions do I want to take on the packet? Change a field value? Forward it? Drop it? 

\item What do I want to do next with the packet? Do I want to decode the next header? Do I want to send it to table matching? 
\end{itemize}

As we write these decoders, we too will answer these questions.

\subsection{The Basic Form} \label{tut:basic_decoder}

To write a decoder, we use a \textit{decoder declaration} (\ref{guide:decoder}). A decoder declaration has four important parts: 1) a name, 2) a \textit{layout rule}, 3) a keyword specifying whether this is the starting decoder, and 4) a body.

\textit{What is a layout rule?} A layout rule is the layout which the decoder will use to guide its extractions. It provides all the information necessary for the decoder to determine which bits in a packet comprise which fields. Here we decide the answer to the questions, "Which header am I decoding? What layout will I use to guide the decoder?"

For our applications (and for almost all applications) we will need to decode ethernet first. We assume that all packets coming to our device begin with the ethernet header (the most common first header). Our decoder will look something like this:

\begin{codepage}
\begin{lstlisting}
// The empty ethernet decoder.
decoder start eth_d(ethernet) { }
\end{lstlisting}
\end{codepage}

In this example, our decoder is named \texttt{eth\_d}. The layout rule is \texttt{ethernet}. We also add the \texttt{start} keyword. This means this decoder will always be the first to execute. A program must have exactly one starting decoder. Our decoder has an empty body delimited by \texttt{\{\}}. As we go, we will fill in this body with instructions for the decoder.

\subsection{Extractions} \label{tut:decoder_extract}

The primary goal of a decoder is to extract fields from a single header. These extracted fields, or \textit{extractions} for short, are found using information gathered by the \textit{layout rule}.

To extract a field, we write an \textit{extract declaration} in the decoder's body. We decide that we want all fields extracted from the ethernet header. Our decoder now looks like the following.

\begin{codepage}
\begin{lstlisting}
// The ethernet decoder extracts all fields.
decoder start eth_d(ethernet) 
{
	extract ethernet.dst; 
	extract ethernet.src;
	extract ethernet.type; 
}
\end{lstlisting}
\end{codepage}

Each extract declaration gives a \textit{field name} (\ref{guide:field_name}). The field name refers to a field in the \textit{layout rule}. Here \texttt{ethernet.dst}, \texttt{ethernet.src}, and \texttt{ethernet.type} are our field names.

We can only use field names which refer to fields in the layout rule. It would obviously make no sense to extract a field not in the header. The decoder gathers information to find the location and length of the field, then saves it in our context (\ref{context_desc}).

\subsection{How Decoder's Extract Fields} \label{tut:extract_how}

Before we continue, we must discuss exactly how a decoder uses a layout rule to extract fields. A decoder has a very limited look into a packet. It only has access to a subset of contiguous bytes, known as the \textit{view} of the decoder. A decoder's view begins where the header it decodes begins, and ends (implicitly) where that header ends. Its view ends implicitly because a layout only provides information on a single header's fields. It is obvious that a decoder would not be able to decode past the final field it knows about from its layout rule.

Figure \ref{fg:decoding} demonstrates how decoders and their views work. In this case, we're decoding a typical packet with ethernet, IPv4, and UDP headers. The starting decoder's view always starts at the beginning of the packet. In the case of Figure \ref{fg:view1}, the first header is ethernet.

\begin{figure}[ht]
\begin{subfigure}[t]{.45\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{view1}
  \caption{Here we have the view of the starting decoder, in this case, the ethernet decoder. The beginning of the view is the same as the beginning of the ethernet header, which is also the beginning of the packet.}
  \label{fg:view1}
\end{subfigure}%
\hfill
\begin{subfigure}[t]{.45\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{view2}
  \caption{The beginning of a field is discovered by its relative offset from the beginning of the view. The end is determined by the field's length. Here we find \texttt{dst} 0 bytes from the beginning, \texttt{src} 6 bytes in, and \texttt{type} 12 bytes in.}
  \label{fg:view2}
\end{subfigure}

\begin{subfigure}[t]{.45\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{view3}
  \caption{When a decoder is finished working, it \textit{shifts} the view to the next header. The shift moves the beginning of the view by the length of the header -- 14 bytes.}
  \label{fg:view3}
\end{subfigure}%
\hfill
\begin{subfigure}[t]{.45\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{view4}
  \caption{The view shifts again by 20 bytes once the IPv4 decoder finishes.}
  \label{fg:view4}
\end{subfigure}
\caption{A demonstration of the decoding processing in action.}
\label{fg:decoding}
\end{figure}

Each field in the header is discovered by information gathered by the layout rule. Recall that our layout rule tells us the location, or relative offset, of each field from the beginning of the header (which is equivalent to the beginning of the view). Also recall our layout rule gives us the length of each field. From here, our decoder can go about discovering which bits form each field as demonstrated in Figure \ref{fg:view2}.

When a decoder finishes, it \textit{shifts} the view, as seen in Figure \ref{fg:view3}. The beginning of the view is moved by the length of header. The view now starts one byte \textit{after} where the previous header ended. The end of the view is implicit. Once the next decoder is reached, its view is already on the header is decodes. When this next decoder finishes, it shifts the view once again, as seen in Figure \ref{fg:view4}.

\subsection{Accessing Extracted Fields} \label{tut:decoder_access}

After extracting a field from a header, we generally want to use the \textit{value} of that extraction. To use the value of an extraction, we need the \textit{field access expression} (\ref{guide:field_access_expr}). When we use the field names from our extract declarations in other operations, such as the condition of an if-else statement, or an operand in addition, we use it to mean the value of that field. That field name \textit{becomes} a field access expression.

Now, let us go about using some of our extracted fields from the ethernet header. A typical operation on an ethernet header is determining which protocol it encapsulates, i.e. the header which comes next.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) 
{
  extract ethernet.dst;
  extract ethernet.src;
  extract ethernet.type;
  // Using a field access expression with logical operator >=
  if (ethernet.type >= 0x600) {
    // Then this field determines what header comes next.
  }
  // Using a field access expression with logical operator <=
  else if (ethernet.type <= 0x05dc) {
    // Then this field is the length of the entire packet.
  }
  // ...
}
\end{lstlisting}
\end{codepage}

The IEEE ethernet standard says that \texttt{type} fields greater than or equal to \texttt{0x600} indicate the next header \cite{eth_std}. Any \texttt{type} fields less than \texttt{0x05dc} indicate the ethernet frame's length. Here we use field access to compare \texttt{ethernet.type} to hexadecimal literals in an if-else statement to determine the meaning of that field.

Our field values can also be used in arithmetic operations, bitwise operations, and can be stored and assigned to local variables. In the following, we present a trivial IPv4 decoder demonstrating some of these basic operations.

\begin{codepage}
\begin{lstlisting}
decoder ipv4_d(ipv4)
{
  extract ipv4.len; // Note that we do not have to extract
  extract ipv4.version_ihl; // fields in order.
  extract ipv4.ttl;
  extract ipv4.src;
  extract ipv4.dst;
  
  // We can assign to field values to variables
  var pktlen : uint = ipv4.len;
  // We can perform bitwise operations.
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  // We can also perform shifts.
  var version : uint(8) = ipv4.version_ihl >> 4;
  
  // Determine what the Time-to-Live is after this
  // device finishes with the packet.
  var next_ttl : uint = ipv4.ttl - 1;
  // ...
}
\end{lstlisting}
\end{codepage}

In this example, we also present a solution for recovering non-byte aligned fields. We bitwise-and (\ref{guide:bitwise_expr}) \texttt{ipv4.version\_ihl} with \texttt{0x0f} to recover the \texttt{ihl} field. We left-shift \texttt{ipv4.version\_ihl} by 4 bits to get the \texttt{version} field. We also demonstrate subtraction on \texttt{ipv4.ttl}, another common operation when dealing with IPv4 headers.

Field access expressions do have a number of limitations. The following example demonstrates this.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet)
{
  // Error: Cannot use eth.type before its extracted.
  if (ethernet.type >= 0x600) { }
  
  extract eth.type;
  
  // Now that its been extracted ...
  // Error: Cannot assign to a field this way.
  ethernet.type = 0x800;
  // ...
}

decoder ipv4_decode(ipv4)
{
  // Error: eth.type was not extracted by this decoder.
  if (ethernet.type == 0x800) { }
  // ...
}
\end{lstlisting}
\end{codepage}

A field access expression can only be used \textit{after} an extract declaration is made for that field. After all, it is impossible to recover the value of a field which has not been extracted. By extensions, they cannot be used in decoders which have not extracted that field. A decoder focuses on exactly one header and has no knowledge of previous headers or extractions. 

Field access expressions cannot be assigned to like a variable. To modify the value of a field, a set action must be used (see Section \ref{tut:set_action} for an example).

\subsection{Moving to Other Stages} \label{tut:decoder_next}

Now that we have completed extracting fields, we must answer the question, "What do I do next?" Recall from Chapter \ref{ch:pipeline_model} that decoding and table matching stages can be chained together in a number of flexible ways. 

A decoder can move a packet to another decoder, table, or it can forward/drop the packet. Its up to the programmer to decide which is appropriate.

To move to another decoding stage, a decode action (\ref{guide:decode_action})) is used. In the following example, we bridge the ethernet and IPv4 decoders we declared in an earlier example. We use the match statement (\ref{guide:match_stmt}) to check if \texttt{ethernet.type} is equal to \texttt{0x800}. If it is, we use the decode action to move the packet to the IPv4 decoder.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet)
{
	extract ethernet.dst;
	extract ethernet.src;
	extract ethernet.type;
	if (ethernet.type >= 0x600)
	  	// The next header is IPv4 if the type field is 0x800.
	    match (ethernet.type) {
	      case 0x800: decode ipv4_d;
	    }
}

decoder ipv4_d(ipv4) {
	// ...
}
\end{lstlisting}
\end{codepage}

To transition to a table matching stage, a goto action (\ref{guide:goto}) (not to be confused with a C-like \texttt{goto}) is used. 

\begin{codepage}
\begin{lstlisting}
decoder ipv4_d(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.protocol;
  extract ipv4.src;
  extract ipv4.dst;
  // Calculate internet header length (ihl).
  var ihl : uint(8) = (ipv4.version_ihl & 0x0f) * 4;
  // We apply the advance clause to shift our view by a given
  // number of bytes.
  goto t1 advance ihl;
}
\end{lstlisting}
\end{codepage}

In this example, we use a goto action to send the packet to a hypothetical table named \texttt{t1}. We will go into more details about writing tables in the next section. The most important thing to note from this example is the \texttt{advance} clause.

Recall from Section \ref{tut:extract_how} that a decoder shifts the \textit{view} of a packet before moving to the next stage. That shift is by the length of the header. IPv4 headers are dynamic in length. Even though we do not currently support extract dynamic length fields, we must still account for them. To correctly do this, we apply the \texttt{advance} clause. The \texttt{advance} clause may appear on both goto and decode actions. This explicitly shifts the view by the given number of \textit{bytes}. We make the assumption that all headers are word-aligned, and thus an advancing by a number of bytes rather than bits would be appropriate.

\section{Tables} \label{tut:table}

The next stage to explore is the table matching stage. Remember that a table specifies a \textit{key} and is comprised of a set of \textit{flow entries}. Each flow entry specifies a priority, values for its \textit{match fields}, and a set of \textit{actions} to perform against matching packets. All flow entries in the table must be uniquely identifiable from its match fields and priority.

Figure \ref{fg:table_syntax} provides the syntax for writing tables and flow entries in Steve. Tables are written using \textit{table declarations} and flow entries are written using \textit{flow declarations}.

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}
<table-decl> ::=
\textbf{exact\_table} <table-name> \textbf{(} <key-decl-sequence> \textbf{)} 
[ <requires-clause> ] <table-initializer>

<key-decl> ::=
<layout-id> \textbf{.} <field-id>
\alt <key-decl> \textbf{.} <field-id>
\alt \textbf{in\_port}
\alt \textbf{in\_phys\_port}

<requires-clause> ::=
\textbf{requires} \textbf{(} <field-name-sequence> \textbf{)}

<table-initializer> ::= \textbf{\{} <flow-decl> + \textbf{\}}

<flow-decl> ::=
<properties-block>
\textbf{\{} [<expr-sequence>] \textbf{\}} "-\>" <flow-body>
\alt <miss-flow-decl>

<flow-body> :: \textbf{\{} <action> + \textbf{\}}

<properties-block> ::=
\textbf{[} <property-sequence> \textbf{]}

<property> ::=
<property-kind> \textbf{=} <expr>

<property-kind> ::=
\textbf{timeout}
\alt \textbf{egress}

<miss-flow-decl> ::=
\textbf{miss} \textbf{-\textgreater} <flow-body>
\end{grammar}
\end{mdframed}
\caption{Table syntax for Steve in BNF.}
\label{fg:table_syntax}
\end{figure}

There are three commonly used types of flow tables: \textit{exact}, \textit{prefix}, and \textit{wildcard} matching tables. Steve currently only supports the exact match table. 

With an exact match table, each field in the packet must \textbf{exactly} match a flow entry's match fields. By default, the priority of all flow entries in an exact match table are the same. The exception is the miss case which always has a priority lower than every other flow entry.

Consider that the objective of tables is to classify packets based on their fields and perform the same actions on like-classified packets. Assume we have one such problem. We want to decode the data portion following the IPv4 header. The data following an IPv4 header is determined by the value \texttt{ipv4.protocol} field. All packets whose \texttt{ipv4.protocol} field equal \texttt{0x01} get sent to the ICMP decoder. All packets whose \texttt{ipv4.protocol} field equal \texttt{0x06} get sent to the TCP decoder, and so on.

Now we also add the additional restriction that we only want to deal with non-fragmented packets. Whether or not an IPv4 packet is fragmented can be determined by checking the \texttt{ipv4.fragment} field. To solve this problem, we can use table \texttt{ip\_data\_table} presented in Figure \ref{fg:ip_table_ex}.

\begin{figure}
\begin{lstlisting}
// A table declaration declares which fields comprise its
// key. In this case, we have ipv4.fragment and ipv4.protocol.
exact_table ip_data_table(ipv4.fragment, ipv4.protocol)
	requires (ipv4.ttl)
{
  // NOTE: The fragment field is typically 0 when a packet
  // is not fragmented.
  
  // Flow entry #1 
  // Here we declare a flow entry. The first part of the
  // entry specifies the values for the "Match Fields".
  // Here we have 0x0 for the ipv4.fragment match field
  // and 0x01 (ICMP) for the ipv4.protocol field.
  { 0x0, 0x01 } ->
  {
    // Using the Set action to decrement the ttl.
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode icmp_decode advance ipv4.version_ihl & 0x0f;
  } 
  
  // Flow entry #2
  // The protocol field is 0x06 for TCP data.
  [timeout = 1000]
  { 0x0, 0x06 } ->
  {
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode tcp_decode advance ipv4.version_ihl & 0x0f;
  } 
    
  // And so on...
  
  // Miss Case
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of a simple table used to classify IPv4 packets.}
\label{fg:ip_table_ex}
\end{figure}

To write a complete exact match table, the programmer must specify 1) what fields comprise the key, 2) what additional fields need to be extracted by a decoder before reaching the table, and 3) a set of flow entries. 

The table \texttt{ip\_data\_table} declares that its keys are the \texttt{ipv4.fragment} and \texttt{ipv4.protocol} fields. It is thus limited to classifying packets based on these fields. Additionally, it specifiesthat \texttt{ipv4.ttl} also be extracted using the \texttt{\color{blue}requires} clause. This table is declared with three initial flow entries (two normal entries and one miss case).

A flow entry must specify 1) the values of its match fields, 2) the actions to be applied to the packet.

The first flow declaration declares a flow entry whose \texttt{ipv4.fragment} match field is equal to \texttt{0x0} and whose \texttt{ipv4.protocol} match field is equal to \texttt{0x01}. The second flow entry similarly has an \texttt{ipv4.fragment} match field equal to \texttt{0x0} and an \texttt{ipv4.protocol} match field equal to \texttt{0x06}.In both cases, we use the \texttt{set} action (described in Section \ref{set_action_tut}) to decrement the \texttt{ipv4.ttl} field. We then dispatch to the appropriate decoder using the \texttt{decode} action.

In the second flow entry we have a special case where we set the timeout \textit{property} of the flow entry to \texttt{1000}. Properties are additional information attached to flow entries. Flow entries currently support two properties. The first is \texttt{timeout}. A flow entry is removed from a table after a \texttt{timeout} number of milliseconds. The other is the \texttt{egress} port property which allows flows to use the \texttt{\color{blue}output \color{green}egress} action described in Section \ref{output_action_tut}.

\textit{So what makes using a table different from decision structures like an if-else or match statements?} As one may have noticed, the table example given in Figure \ref{fg:ip_table_ex} could just as easily be written using a combination of if-else and match statements like we used with the ethernet decoder earlier in Figure \ref{fg:transition_ex}. 

First of all, a table can match on one or more fields at once. The table can also match on a packet's \texttt{in\_port} and \texttt{in\_phys\_port} fields (described in Section \ref{output_action_tut}). The more fields required in the decision making process, the more complex using nested decision structures gets. Tables, on the other hand, are easier to write in this case.

Second, a table can match on and use fields from different headers. Unlike decoders, tables have a wider perspective on packets. For example, the following is a perfectly valid table. 

\begin{lstlisting}
exact_table t1(ethernet.dst, ipv4.dst)
{
  // ...
}
\end{lstlisting}

Tables and their contained flow entries have access to every field that has been extracted before them using \textit{field access expressions}. The only limitation is that field access can only occur on fields which the table either matches on or requires explicitly.

Lastly, flow entries can be added and removed from tables using the appropriate actions. This allows decision making on packets to change dynamically during runtime. It is obviously impossible to add new branches to if-else and match statements. The ability to add, or \textbf{learn}, new entries allows us to write applications which can learn, such as learning switches and routers.

\section{Actions} \label{tut:action}

Actions change packets, action sets, and pipeline state. Steve supports eleven actions with more anticipated in the future. Actions can be used in both decoders and flows in Steve. The syntax for supported actions can be found in Figure \ref{fg:action_syntax}.

\begin{figure}
\begin{mdframed}
\begin{grammar}
<port-decl> ::=
\textbf{Port} <port-name> \textbf{;}
\alt \textbf{Port} <port-name> \textbf{=} <string-literal> \textbf{;}

<action-stmt> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <drop-action>
\alt <flood-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>

<decode-action> ::=
\textbf{decode} <decoder-decl-id> \textbf{;}

<goto-action> ::=
\textbf{goto} <table-decl-id> \textbf{;}

<output-action> ::=
\textbf{output} <port-expr> \textbf{;}

<drop-action> ::= \textbf{drop;}

<flood-action> ::= \textbf{flood;}

<clear-action> ::= \textbf{clear;}

<set-field-action> ::= \textbf{set} <field-access-expr> \textbf{=} <expr> \textbf{;}

<insert-flow-action> ::= \textbf{insert} <flow-decl> \textbf{into} <table-id> \textbf{;}

<remove-flow-action> ::= \textbf{remove} \textbf{\{} [ <expr> + ] \textbf{\}}
\textbf{from} <table-id> \textbf{;}

<raise-action> ::= \textbf{raise} <event-id> \textbf{;}

<write-action> ::= \textbf{write} <action-stmt>

\end{grammar}
\end{mdframed}
\caption{Action syntax for Steve in BNF.}
\label{fg:action_syntax}
\end{figure}

\subsection{Decode Action} \label{tut:decode_action}

The \texttt{decode} action is used to move a packet from the current stage to a decoding stage. Assume we want to move to an IPv4 decoder named \texttt{ipv4\_decode}, the action would be written as:

\begin{lstlisting}
decode ipv4_decode;
\end{lstlisting}

Remember that there is also an optional \texttt{advance} clause which can occur if the "view" of the packet must be explicitly shifted by some special number of bytes. For example, if the current decoder is for IPv4, and the next decoder is named \texttt{udp\_decode}, the action would be written as:

\begin{lstlisting}
decode udp_decode advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Goto Action} \label{tut:goto_action}

The \texttt{goto} action is used to move a packet from the current stage to a table matching stage. Assume we want to move to a table named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1;
\end{lstlisting}

Similar to the \texttt{decode} action, the \texttt{goto} action also supports an optional advance clause. For example, if the current decoder is for IPv4, and the table the programmer wants to dispatch to is named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1 advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Ports and the Output Action} \label{tut:output_action}

Ports are an important part of the system. Ports are where packets enter (ingress) and leave (egress) the system. Ports are all given a unique integer identifier by the system.

Steve supports a number of \textit{reserved ports} which are required to exist on every system Steve applications runs on. These are compliant with OpenFlow port specifications \cite{openflow_spec}.

The \texttt{all} port represents every port on the system that can be forwarded to. This port can only be used for output.

The \texttt{controller} port represents the communication channel between a device and a set of application controllers. A packet might enter from this port or be output through this port.

The \texttt{reflow} port represents the beginning of the pipeline. Packets sent to this port are sent through the pipeline again for re-processing. This is equivalent to the \textbf{TABLE} port in OpenFlow. This port is only valid for output.

To output a packet to a port we can use the \texttt{output} action as follows.

\begin{lstlisting}
// Outputs to all ports on the system.
output all; 

// Outputs to the controller.
output controller; 

// Sends the packet back to the beginning of the pipeline.
output reflow; 
\end{lstlisting}

In addition to the reserved ports, there are a number of keywords in Steve which can be used to access certain ports.

The \texttt{in\_port} port refers to the packet's ingress port. The \texttt{in\_phys\_port} port refers the packets physical ingress port. To output to these port, we write the following.

\begin{lstlisting}
output in_port;

output in_phys_port;
\end{lstlisting}

Flow entries can have an (optional) \texttt{egress} port property which can be set. When executing a flow, if this property has been set, the packet can be output to this \texttt{egress} port using:

\begin{lstlisting}
output egress;
\end{lstlisting}

Steve also provides the limited ability to user-declare ports with certain capabilities. These ports are only valid if the system has a port with the given capabilities, otherwise they produce runtime errors when the system loads the Steve application.

A port bound to logical port \texttt{5000} on a system would be written as follows.

\begin{lstlisting}
Port p1 = ":5000";

// To output to p1...
output p1;
\end{lstlisting}

User-declared ports with no configuration information, like the following, refer to an invalid port whose identifier is always 0. 

\begin{lstlisting}
Port p1;
\end{lstlisting}

These ports can be assigned to later with a valid port. Outputting to invalid ports results in the packet being dropped.

\begin{lstlisting}
p1 = in_port;
output p1;
\end{lstlisting}

\subsection{Drop Action} \label{tut:drop_action}

A packet can be dropped by the Steve application using the \texttt{drop} action. No further processing can be done on a dropped packet.

\begin{lstlisting}
drop;
\end{lstlisting}

\subsection{Flood Action} \label{tut:flood_action}

A packet can be flooded to all ports except the packet's ingress port using the \texttt{flood} action.

\begin{lstlisting}
flood;
\end{lstlisting}

\subsection{Set Action} \label{tut:set_action}

A \texttt{set} action can be used to write to any extracted field within a packet. The \texttt{set} action is only valid if the field given by the field access expression is valid in that stage.

\begin{lstlisting}
set ipv4.ttl = ipv4.ttl - 1;
\end{lstlisting}

\subsection{Insert Flow Action} \label{tut:insert_flow_action}

Inserting flow entries into a table is a Steve action not explicitly supported by the OpenFlow standard \cite{openflow_spec} though it is supported in software switches like OVS \cite{ovs_man_page}. Flow entries can be inserted with constant key values and no properties. 

\begin{lstlisting}
// Constant key values.
insert
{ 0x0, 0x89 } ->
{
  set ipv4.ttl = ipv4.ttl - 1;
  decode mpls_decode;
} 
into ip_data_table;
\end{lstlisting}

They can also be inserted with field values of the current packet and with optional properties.

\begin{lstlisting}
// Dynamic key values
insert
[timeout = 1000, egress = in_port]
{ ipv4.fragment, ipv4.protocol } ->
{
  output egress;
} 
into ip_data_table;
\end{lstlisting}

In this case, the flow entry uses the \texttt{ipv4.src} and \texttt{ipv4.dst} fields of current packet as values for the inserted flow entry's key. It also sets the timeout to 1000 and sets the \texttt{egress} property to the current packet's \texttt{in\_port}, making the \texttt{output egress} action valid.

\subsection{Remove Flow Action} \label{tut:remove_flow_action}

A flow entry can be removed from a table by providing match field values and the name of the table to remove the flow entry from. This can be done with constant values or dynamic field values of the current packet.

\begin{lstlisting}
// Removal with constant values.
remove { 0x0, 0x01 } from ip_data_table;

// Or dynamic values.
remove {ipv4.dst, ipv4.protocol } from ip_data_table;
\end{lstlisting}

\subsection{Write Action} \label{tut:write_action}

The context data structure keeps an \textit{action set}. This action set is a set of actions which are written to the context using the \texttt{write} action. All actions in this section except the \texttt{raise}, \texttt{insert}, and \texttt{remove} action can be written to an action set. The execution of these written actions is deferred until egress processing.

\begin{lstlisting}
// Writing a set action
write set ipv4.ttl = ipv4.ttl - 1;
// Writing an output action.
write output reflow;
// Writing a drop action.
write drop;
// etc...
\end{lstlisting}

\subsection{Clear Action} \label{tut:clear_action}

The clear action removes all actions from the context's action set.

\begin{lstlisting}
clear;
\end{lstlisting}

\subsection{Raise Action} \label{tut:raise_action}

A \texttt{raise} action is used to trigger an \textit{event}. Events are Steve's lightweight way of supporting asynchronous execution during pipeline processing. Section \ref{event_tut} demonstrates how to write events. To trigger an event, you use a \texttt{raise} action and give an event identifier as follows.

\begin{lstlisting}
// Assuming we have an event named "learn"
raise learn;
\end{lstlisting}

\section{Events} \label{tut:event}

Steve supports \textit{events} which are lightweight asynchronous pipeline processing stages. These stages are special because their processing occurs outside of the run-to-completion model that tables and decoders have. 

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<event-decl> ::=
\textbf{event} <event-name> <requires-clause> 
<block-statement>

\end{grammar}
\end{mdframed}
\caption{Event syntax for Steve in BNF.}
\label{fg:event_syntax}
\end{figure}

Each \textit{event declaration} in Steve declares an \textit{event handler} which (optionally) declares which fields must be extracted before that event can be raised. When a user raises an event using the \texttt{raise} action, they trigger the execution of the event handler in a separate event thread.

Events are most useful when performing slower actions, namely \texttt{insert} and \texttt{remove}. Inserting flow entries and removing flow entries from a table can be a bottleneck for execution. Events allow these bottleneck actions to be performed when convenient while the packet continues through the run-to-completion model.

In Figure \ref{fg:event_ex}, we declare an event named \texttt{learn\_mac} which inserts flow entries into a table named \texttt{learn} and a table named \texttt{switch}. To raise this event, we would use the action \texttt{\color{blue}raise} \texttt{learn\_mac}. 

\begin{figure}[ht]
\begin{lstlisting}
event learn_mac
	requires(ethernet.src)
{
	insert
	{ ethernet.src } ->
	{
		goto switch;
	}
	into learn;


	insert
	[timeout = 1000, egress = in_port]
	{ eth.src } ->
	{
		output egress;
	}
	into switch;
}
\end{lstlisting}
\caption{An example of an event used to learn which ports are receiving packets from which MAC addresses.}
\label{fg:event_ex}
\end{figure}

An important thing to know when using events is that a \textbf{copy} of the packet and context are sent to the event handler. Any changes made to a packet using an action in the event handler does not modify the original packet or its context. The original packet continues moving through the pipeline after a \texttt{raise} occurs and does not wait for the event handler to execute.

Another thing to note is that this usage of events to learn flow entries is distinct from OpenFlow semantics. Normally packets are sent to the \texttt{controller} port which connects to an application called the \textit{controller}. The controller then asynchronously processes packets and potentially adds the flow entries.

The advantage here is that Steve events are written as part of the Steve application and are thus subject to the same semantic, logical, and safety guarantees applied to other pipeline stages. 

\section{Examples} \label{tut:examples}

As promised at the beginning of this tutorial, we would demonstrate how to write three basic network applications: a learning switch, a learning router, and a wire using language features taught during this tutorial.

\subsection{The Learning Switch} \label{tut:learning_switch}

Let's begin by writing the Layer 2 (ethernet) learning switch. The learning switch shall receive packets. With each packet, the switch will "learn" which MAC addresses are found on which ports by checking the \texttt{src} field of ethernet headers. The switch forwards packets by looking at the \texttt{dst} field and checking if it has learned that MAC address yet. If it has not learned the address, it floods the packet.

Here we need to extract the ethernet header's \texttt{src}, and \texttt{dst} fields. No other headers are necessary. It will not be necessary to extract \texttt{eth.type} or proceed to another decoder. First, we declare the layout needed to decode. We can use the ethernet layout given earlier in Figure \ref{fg:eth_layout_ex}. Next we produce the ethernet decoder which proceeds directly to the \texttt{learn} table after extracting \texttt{ethernet.src} and \texttt{ethernet.dst} fields.

\begin{lstlisting}
decoder eth_d(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  
  goto learn;
}
\end{lstlisting}

From here, we will need two tables: a learning table and a forwarding table. The learning table is responsible for learning MAC addresses and installing learned addresses into the forwarding table. The learning table matches on the \texttt{ethernet.src} field and ensures that the same MAC address is not learned multiple times. To learn the needed flow entries, the \texttt{learn} table raises an event called \texttt{learn\_mac} which will insert these flow entries for us.

\begin{lstlisting}
exact_table learn(ethernet.src)
{
  miss ->
  {
  	// We raise an event to learn the appropriate flow entries.
  	raise learn_mac;
    goto switch;
  }
}
\end{lstlisting}

The forwarding table ultimately forwards the packet to the correct port based on its destination MAC address. The forwarding table thus matches on the \texttt{ethernet.dst} field. Any un-learned destinations get flooded by the miss case.

\begin{lstlisting}
exact_table forward(ethernet.dst)
{
  // Flood any packet which hasn't been learned yet.
  miss -> { flood; }
}
\end{lstlisting}

Note that no initial flow entries other than miss cases are declared with either table. The tables have not learned anything yet. The first packet matched against these tables thus have the miss case applied by default.

So how do we write the \texttt{learn\_mac} event? Recall that we need the \texttt{insert} action to make tables "learn" flow entries. Additionally, this event will require that \texttt{ethernet.src} have been extracted. First we must insert a flow entry into the \texttt{learn} table with the \texttt{ethernet.src} field value of the current packet being learned. This prevents packets with the same \texttt{ethernet.src} field from triggering the \texttt{learn\_mac} event more than once. 

Next, we insert the appropriate flow entry into the \texttt{forward} table. Here, we insert a flow entry whose \texttt{ethernet.dst} field is equal to the current packet's \texttt{ethernet.src} field. Since the \texttt{forward} table matches on \texttt{ethernet.dst} what we are doing is saying any packet whose \texttt{ethernet.dst} is equal to the \textit{current} packet's \texttt{ethernet.src} is forwarded to the \texttt{current} packet's ingress (\texttt{in\_port}) port.

\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}
event learn_mac
	requires(ethernet.src)
{
	// First we insert the src of the packet
	// into the learn table so we don't keep
	// trying to learn something we already have.
	insert
	{ ethernet.src } -> { goto forward; }
	into learn;
	
	// Next we insert the src of the
	// current packet into the forward table.
	//
	// The forward table matches on the dst
	// field of a packet, so what we are doing is
	// saying any packet whose dst is equal to this
	// packet's src is forwarded to this packet's
	// ingress (in_port) port.
	insert
	[timeout = 1000, egress = in_port]
	{ ethernet.src } ->
	{
		// We set the egress property to the current
		// packet's in_port, so when we output egress
		// we send to the current packet's in_port.
		output egress;
	}
	into forward;
}
\end{lstlisting}
\end{minipage}

\subsection{The Learning Router} \label{tut:learning_router}

The learning router is not too different from the learning switch. Instead of learning and forwarding from MAC addresses, this application will learn and forward from IPv4 addresses.

We will need two layouts here: the ethernet layout and the IPv4 layout. Here we can use the ethernet layout given in Figure \ref{fg:eth_layout_ex} and the IPv4 layout given in Figure \ref{fg:ipv4_layout_ex}. We will need to extract the \texttt{ethernet.type} field in order to confirm the ethernet header encapsulates IPv4. Our ethernet decoder will look like the following.
\begin{lstlisting}
decoder eth_d(ethernet)
{
  extract ethernet.type
  match(ethernet.type) {
  	case 0x800: decode ipv4_d;
  }
  drop; // Drop if its not an IPv4 packet.
}
\end{lstlisting}

The IPv4 decoder will need to extract \texttt{ipv4.src} and \texttt{ipv4.dst} in order to learn them. Additionally, we'll need \texttt{ipv4.version\_ihl} to correctly advance past the IPv4 header and \texttt{ipv4.ttl} to decrement.

\begin{lstlisting}
decoder ipv4_d(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.src;
  extract ipv4.dst;
  extract ipv4.ttl;
  goto learn advance (version_ihl & 0x0f);
}
\end{lstlisting}

We will need two tables just like in the learning switch example. Here the \texttt{learn} table matches on \texttt{ipv4.src}. It will be responsible for learning IP addresses and inserting them into the \texttt{routing} table.

\begin{lstlisting}
exact_table learn(ipv4.src)
{
  miss ->
  {
	raise learn_ip;
    goto route;
  }
}
\end{lstlisting}

The \texttt{routing} table matches on \texttt{ipv4.dst}. It will route all packets whose destination IP address it has learned. Any IP addresses not yet learned are flooded by default.

\begin{lstlisting}
exact_table forward(ipv4.dst)
{
  miss -> { flood; }
}
\end{lstlisting}

Lastly we need to define the \texttt{learn\_ip} event which is, once again, largely the same as the \texttt{learn\_mac} event from the learning switch.

\begin{lstlisting}
event learn_ip
	requires(ipv4.src)
{
	insert
	{ ipv4.src } -> { goto route; }
	into learn;

	insert
	[timeout = 1000, egress = in_port]
	{ ipv4.src } -> { output egress; }
	into route;
}
\end{lstlisting}

\subsection{The Wire} \label{tut:wire}

A wire is a network application which has two ports. It receives from one port and outputs out of the other port. The only caveat is that the application is not aware of the ports comprising the wire at first. It must learn that those ports exist.

This example demonstrates a number of more unintuitive features of Steve. First we declare two uninitialized ports named \texttt{p1} and \texttt{p2}. Uninitialized ports have a port identifier of 0 and are invalid.

\begin{lstlisting}
Port p1;
Port p2;
\end{lstlisting}

Next we'll use the ethernet layout from prior examples and write a decoder. The only caveat as we do not need any of the fields. We only care about the \texttt{in\_port} of the packet.

\begin{lstlisting}
decoder start eth_d(ethernet)
{
  goto learn;
}
\end{lstlisting}

To enable our wire application to learn about ports, we once again need two tables and an event which adds flow entries to those tables. First we declare our \texttt{learn} and \texttt{forward} tables. Here we show that \texttt{in\_port} is a valid matching field.

\begin{lstlisting}
exact_table learn(in_port)
{
  miss -> 
  {
  	raise learn_port;
    goto forward;
  }
}

exact_table forward(in_port)
{
  miss -> { drop; }
}
\end{lstlisting}

Then we must declare our \texttt{learn\_port} event. This event demonstrates that ports can be compared with comparisong and equality expressions, which implicitly compare the integer identifiers assigned to those ports. We also show that port declarations can be assigned to (\texttt{p1 = in\_port}) as long as what is being assigned is also a port.

Once both ports are valid, the application installs the appropriate flow entries and the wire will function appropriately.

\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}
event learn_port
{
  // Prevent the same port from being learned twice.
  insert
  { in_port } -> { goto forward; }
  into learn;

  // If neither p1 nor p2 is set, then we assume this packet 
  // is coming off p1.
  // Note: The assumption is that port 0 is an 
  // invalid port since valid port IDs begin at 1.
  if (p1 == 0 && p2 == 0)
    p1 = in_port;
  // If p1 is learned and this packet is not from p1, 
  // then this is from p2. At this point we would have 
  // both ports learned so we can add the flow entries.
  else if (p1 > 0 && p1 != in_port)
  {
    p2 = in_port;
    insert
    { p1 } -> { output p2; }
    into forward;

    insert
    { p2 } -> { output p1; }
    into forward;
  }
}
\end{lstlisting}
\end{minipage}