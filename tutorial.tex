\chapter{The Steve Language} \label{ch:tutorial}

% It might be worthwhile to divide this into three major sections:
%
% 1. General purpose computing
% 2. Packet specification
% 3. Pipeline specification
%    - decoders
%    - flow tables

The Steve Programming Language provides features for
defining and connecting the pipeline processing stages and event handlers. Together, these components comprise a network application.

%After the first example, this chapter will delve into all the individual pieces of a Steve program with additional details and use cases.
This chapter will describe all of the language features for Steve in greater detail with use cases.
Specifically, this chapter will discuss how headers are represented (Section \ref{tut:layout}), how to
write decoders (Section \ref{tut:decoder}), how to write flow tables (Section \ref{tut:table}), how to apply actions to packets (Section \ref{tut:action}), and how to write event handlers (Section \ref{tut:event}).

Semantics and limitations of Steve will be mentioned throughout this chapter, 
but not in complete detail. For the complete semantic description of
Steve, including grammar, typing rules, and other restrictions, see the Reference Guide in Appendix \ref{ch:users_guide}.

\section{General Purpose Language Features} \label{tut:gen_purp}

Steve supports language features that can be considered
\textit{general purpose}. They are common to most programming
languages and are not explicitly for packet processing, though they may prove
useful.

%\subsection{Literals} \label{tut:literal}
%
%Steve supports decimal, binary, and hexadecimal integer literals. Steve does not
%currently support things like IP address literals or MAC address literals.
%
%Hexadecimal literals all start with the prefix \texttt{0x} followed by any
%number of digits between \texttt{0} and \texttt{9}. Binary literals all start with the prefix \texttt{0b} followed by any number of
%\texttt{0}'s and \texttt{1}'s.
%These integer literals can be written as follows.
%
%\begin{codepage}
%\begin{lstlisting}
%17 // Decimal literal
%0x11 // Hexadecimal 17
%0x00010001 // Binary 17
%\end{lstlisting}
%\end{codepage}
% 
%The underscore (\texttt{\_}) can optionally be used as a digit separator (like 
%Java) for hexadecimal and binary literals with no impact on the value of that 
%literal.
%This is purely for organization and readability.
%
%\begin{codepage}
%\begin{lstlisting}
%0b10101010
%0b1010_1010
%
%0x0800
%0x08_00
%\end{lstlisting}
%\end{codepage}
%
%Steve also supports character and string literals which are useful for
%logging through C library functions (described in Section \ref{tut:foreign}).

\subsection{Variables} \label{tut:variable}

Steve allows for the allocation of both local and global variables. 
A variable named \texttt{x} which holds an integer \texttt{10} is written
as follows. 

\begin{codepage}
\begin{lstlisting}
var x : int = 10;
x = 9; // Assign a new value.
\end{lstlisting}
\end{codepage}

\subsection{Conditional and Loop Statements} \label{tut:condition}

Steve supports two conditional statements for decision making: the \texttt{if} statement and the \texttt{match} statement. 
The \texttt{if} statement is the same as C.

A \texttt{match} statement allows for a decision to be made given a number of 
possible case values. 
This is similar to a C-like switch statement, with the only
major difference being that there is no \textit{fall-through} behavior. In other
words, after the execution of a \texttt{case} statement, control jumps out of the 
\texttt{match} statement rather than moving to the next case (i.e. an implied 
\texttt{break}). 
The condition and labels must be integers just like in C. 
A \texttt{match} statement can be written as follows.

\begin{codepage}
\begin{lstlisting}
match (x) {
  case 0: x = x + 1;
  // Multiple statements following the label must be
  // enclosed in a block.
  case 1: {
    x = x + 2;
    y = y * x;
  }
  // The default case statement.
  miss: x = 0;
}
\end{lstlisting}
\end{codepage}

Steve also supports the \texttt{while} loop which is the same as C-like languages. 
It also supports the \texttt{break} and \texttt{continue} statements for limited
branching abilities inside a loop. 

\subsection{Functions} \label{tut:function}

Steve supports writing simple functions, though the syntax is a little different
from C-like languages.
A function named \texttt{sum} which takes two
integers, \texttt{a} and \texttt{b}, and returned their sum is written as follows.
The return type follows the \texttt{->} in Steve functions.

\begin{codepage}
\begin{lstlisting}
def sum(a : int, b : int) -> int {
  return a + b;
}

sum(1, 2);
\end{lstlisting}
\end{codepage}

\subsection{Foreign Functions} \label{tut:foreign}

By default, all Steve compiled applications are linked against the C runtime
library. Steve applications may also be linked against other libraries.
Steve programmers may call functions in linked libraries by first declaring
them in the Steve application using a \emph{foreign function} with the same
function signature.

\begin{codepage}
\begin{lstlisting}
foreign def puts(input : char[]) -> int;

puts("Hello, World.");
\end{lstlisting}
\end{codepage}

Here, this foreign function links to the C standard \texttt{puts} function
for text output. It may be called like any other function.

\section{Layouts} \label{tut:layout}

A \textit{layout} is used to describe 
the \textit{structure} of a packet header.
More specifically, they describe \textit{what} fields are present, their
\textit{lengths}, the \textit{order} in which they appear, and their
\textit{relative offset} from the beginning of the header. 
Decoders use layout information to reason about extracting fields.

%A layout and a header are two different concepts.
%It is important to make this distinction clear. A layout is like a blueprint for
%a header. It gives us information; it \textit{describes} that header. The header
%is an actual sequence of bits, a portion of the packet, which is taken off of the
%network. The header \textit{exists} whereas a layout helps the Steve application
%\textit{understand} it.

A \emph{layout declaration} (see \ref{guide:layout}) is used to write a layout.
The simplest example to begin with is the Ethernet frame header \cite{eth_std}.
The corresponding layout would look like the following.  

\begin{codepage}
\begin{lstlisting}
layout ethernet {
	dst  : uint(48); // 48 bits.
	src  : uint(48); // 48 bits.
	type : uint(16); // 16 bits.
}
\end{lstlisting}
\end{codepage}

Every layout has a name (\texttt{ethernet}) and a sequence of field declarations
which describe the fields contained within the header.
This layout has three such field declarations (\texttt{dst}, \texttt{src},
and \texttt{type}).
Each field declaration has a name and a type that describes valid operations and
value ranges for that field.
To reduce errors related to working with byte buffers, Steve allows header fields to
be represented as fixed-precision, signed or unsigned, integer types.
The precision denotes the length of the field in bits.
Here, \texttt{dst} and \texttt{src} fields are 48 bits long and \texttt{type} is
16 bits long.

The \textit{relative offset} of each field is the number of bits it is away
from the beginning of the header. The first field will always have a relative
offset of 0 bits. The relative offset of each subsequent field is equal to the
sum of the lengths of all fields preceding it. Here, \texttt{dst} has a relative
offset of 0 bits, \texttt{src} has one of 48 bits (6 bytes), and \texttt{type} has one of
96 bits (12 bytes).

The field declarations must appear in the order with which they would normally appear
in an Ethernet header. Field ordering should always be
preserved when declaring layouts. If the ordering is incorrect, decoders will
assume a sequence of bits is a certain field when it truly is not. 

Not all header structures are as simple as the Ethernet header. Sometimes one
must deal with structures encapsulated inside a header. Steve supports composition of layouts to describe such header structures.
The following presents an OpenFlow protocol message which contains such a case \cite{openflow_spec}.

\begin{codepage}
\begin{lstlisting}
layout ofp_instr_stat_trigger {
	type : uint(16); 
	len : uint(16); 
	flags : uint(32); 
	threshold : ofp_stats;
};

layout ofp_stats {
	reserved : uint(16); 
	length : uint(16); 
	oxs_field : uint(8);
	padding : uint(32);
};
\end{lstlisting}
\end{codepage}

In this example, two layouts are presented: \texttt{ofp\_instr\_stat\_trigger} and \texttt{ofp\_stats}. 
To express the \texttt{ofp\_stats} structure within the OpenFlow message, a field named \texttt{threshold} is added to
\texttt{ofp\_instr\_stat\_trigger} and its type is given as the name of another layout (\texttt{ofp\_stats}). The length of the \texttt{threshold} field would be the sum of the lengths
its fields, in this case, 72 bits (9 bytes).

With the way
layouts are described and written, it is easy to draw the comparison between 
layouts and
class types (or record types). \textit{Layouts are not 
classes.} Layouts are much stricter.

First, \textit{the types of fields are restricted}. Fields may only
have two types: integer (see \ref{guide:integer_type}) and layout
(see \ref{guide:layout_type}). There may be varying kinds of integer (e.g.
precisions, signed, unsigned, etc.), but the precision of each integer must also
be \textit{byte-aligned}, that is, a multiple of 8.

Second, the most important distinction is that \textit{objects of layout type
can never be created}. Layouts may not appear as the type of parameters, nor may
they appear as return types. All of the following are considered ill-formed.

\begin{codepage}
\begin{lstlisting}
layout L1 { f1 : uint; f2 : uint(16); }
var x : L1 = 0; // Error.
def foo(y : L1) -> L1 { ... } // Error.
\end{lstlisting}
\end{codepage}

Layouts are distinct from the headers that they describe.
The sole purpose of layouts is to allow decoders to reason about the logical 
structure of a header in memory.
The memory for packets and their headers exist independent of a running Steve 
application.
To create an object of layout type would imply the need to create new headers,
which is not currently supported by Steve.

%Additionally, there are a number
%of concerns related to constructing objects of layout type, thus such behavior
%is not allowed. For further details on layout limitations, refer to Section
%\ref{guide:no_dst} in the Reference Guide.

Another important thing to note is that Steve does not currently support dynamically
sized types (DST). A DST is a type whose size is predicated upon some value
known only during runtime. These DST's are used to represent fields whose
lengths are dynamic. Some examples of dynamic length fields are the
\texttt{options} fields in IPv4, IPv6 extended, and TCP headers \cite{ipv4_std, ipv6_std,
tcp_std}.

DST's are a language feature that will eventually be added, but are outside the
current implementation. Because of this, fields whose lengths are dynamic cannot
currently be declared, extracted, nor used. The existence and eventual support
of DST's is one of the reasons why objects of layout type cannot be created.
This is further discussed in Section \ref{guide:no_dst}.

The following example presents a case where some of these limitations become relevant -- the IPv4 layout.

\begin{codepage}
\begin{lstlisting}
layout ipv4 {
  version_ihl : uint(8); // Non-byte aligned fields are merged
  dscp_ecn    : uint(8); // This is merged, too.
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16); // Fragment flags and offset merged.
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
  // Options field omitted because it is a DST.
}
\end{lstlisting}
\end{codepage}

In this example, \texttt{version} (a 4 bit field) has to be
merged with \texttt{ihl} (internet header length) (also a 4 bit field) to
achieve byte alignment. The same is true for \texttt{dscp} and \texttt{ecn}. The
\texttt{fragment} field, typically composed of three 1 bit flags and a 13 bit
fragment offset field, is merged into a single 16 bit field. 
Bitwise-AND and bit shifting is needed to recover the needed bits.
Examples will come up later when an IPv4 decoder is discussed in
Section \ref{tut:decoder_access}.

\section{Decoders} \label{tut:decoder}

Decoders are special purpose functions
used to extract fields from a single header. 
They implicitly take context data structures as arguments and 
operate on them.
A decoder conforms to a layout specification.
Layout information allows the decoder to determine where fields
are located in a header and how long they are.


%\begin{itemize}
%\item Which header is being decoded?
%
%\item What fields from the header are needed and why?
%
%\item How will these fields be used? Will they be used in arithmetic or 
%
%\item \textit{Actions} (described later in Section \ref{tut:action}) are used to manipulate packet fields, forward packets,
%and add/remove flow entries from tables. What actions must be be taken on the packet?
%
%\item Where must the packet be sent next? Must it be further decoded or can it be sent to table matching for decision making?
%\end{itemize}

\subsection{The Basic Decoder Form} \label{tut:basic_decoder}

A decoder is written using a \textit{decoder declaration} (see \ref{guide:decoder}).
The most common decoder written is likely the Ethernet decoder. The following
is the basic form of an Ethernet decoder.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) { ... }
\end{lstlisting}
\end{codepage}

A decoder declaration has four important parts: 
1) a name (\texttt{eth\_d}), 
2) a \textit{layout rule} (\texttt{ethernet}),
3) a body, and
4) the optional \texttt{start} keyword.

The decoding process conforms to the layout rule and uses it to reason
about the location and lengths of fields within the header it is decoding.
Decoder operations are placed in the body delimited by $\lbrace\rbrace$.
The \texttt{start} keyword identifies this decoder as the \emph{starting
decoder}. 

A starting decoder is the root of the pipeline.
By extension there can only be one starting decoder.
Every packet must be processed by the starting decoder first.
Since Ethernet is the most common Layer 2 framing protocol, it will
likely be the root of almost all pipelines.

\subsection{Extractions} \label{tut:decoder_extract}

An \textit{extract declaration} (see \ref{guide:extract}) in the decoder's body
instructs it to extract the given field. Extracted fields, or \emph{extractions},
for short, may then be used by the program as a variable.
The following example expands the body of the \texttt{eth\_d} decoder 
with extract declarations.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) {
	extract ethernet.dst;
	extract ethernet.type;
	// ...
}
\end{lstlisting}
\end{codepage}

Each extract declaration gives a \emph{field name} (see \ref{guide:field_name}) 
which tells the decoder which field is being extracted. 
In this example, there are
two such extract declarations which instruct the decoder to extract
the fields \texttt{ethernet.dst} and \texttt{ethernet.type}.
The compiler generates \textit{(offset, length)} pairs 
denoting the relative offset and length of the field within the decoder's view using the given field names and layout rule. 

Only field names which refer to fields in the layout rule may be used. It obviously make no sense to extract a field not in the header. 
For example, it would not be possible to extract \texttt{ipv4.protocol} in the \texttt{eth\_d} decoder. 

\subsection{Accessing Extracted Fields} \label{tut:decoder_access}

Once a field has been extracted, getting its value is similar to using
it as variable.
To get the value of an extraction
the \textit{field access expression} (see \ref{guide:field_access_expr}) is used.
A field access expression is a field name being used where
an expression is expected. This is similar to using a variable name
in an expression to represent the value of the variable.

A typical operation on an Ethernet header is determining which protocol
it encapsulates, i.e. the header which comes next. This is indicated
by the value stored in \texttt{ethernet.type}.
The following example demonstrates how the value of the \texttt{ethernet.type} 
extraction might be used.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) {
  extract ethernet.dst;
  extract ethernet.type;
  if (ethernet.type >= 0x600) {
    // The type determines what header comes next...
  }
  else if (ethernet.type <= 0x05dc) {
    // The type is the length of the entire packet...
  }
}
\end{lstlisting}
\end{codepage}


The IEEE Ethernet standard says that \texttt{ethernet.type} fields greater than 
or equal to \texttt{0x600} indicate the next header's protocol \cite{eth_std}. 
Any \texttt{type} fields less than \texttt{0x05dc} indicate the Ethernet frame's 
length. 
Here, field access is used to compare \texttt{ethernet.type} to 
hexadecimal literals in an \texttt{if-else} statement to determine the meaning of 
that field.

Extraction values can also be used in arithmetic operations, comparison 
operations, bitwise operations, function calls,
and can be stored and assigned to variables. The following example presents
a trivial IPv4 decoder demonstrating some of these basic operations.

\begin{codepage}
\begin{lstlisting}
decoder ipv4_d(ipv4) {
  extract ipv4.version_ihl; // Use this to get header length.
  extract ipv4.dscp_ecn;
  extract ipv4.len;
  extract ipv4.id;
  extract ipv4.fragment;
  extract ipv4.ttl;
  extract ipv4.protocol;
  extract ipv4.checksum;
  extract ipv4.src;
  extract ipv4.dst;
  
  var pktlen : uint = ipv4.len; // Variable assignment
  var ihl : uint(8) = ipv4.version_ihl & 0x0f; // Bitwise AND
  var version : uint(8) = ipv4.version_ihl >> 4; // Shift
  // ...
}
\end{lstlisting}
\end{codepage}

This example presents a solution for recovering non-byte aligned
fields. A bitwise-AND (see \ref{guide:bitwise_expr}) is used on \texttt{ipv4.version\_ihl}
with \texttt{0x0f} to recover the \texttt{ihl} field. The 
\texttt{ipv4.version\_ihl} is left-shift by 4 bits to get the \texttt{version} field.

Extractions can be passed to functions as well. A convenient use case is 
calculating the checksum for the IPv4 header. 
The following example extends the IPv4 decoder with a few more operations.

\begin{codepage}
\begin{lstlisting}
decoder ipv4_d(ipv4) {
  // ...
  // Calculate a checksum by calling a function.
  var checksum : uint(16) =
      ipv4_checksum(ipv4.version_ihl, ipv4.dscp_ecn, ipv4.len, 
                    ipv4.id, ipv4.fragment, ipv4.ttl, 
                    ipv4.protocol, ipv4.src, ipv4.dst);
  // Check the checksum against the header's checksum.
  if (checksum != ipv4.checksum)
	  drop;
  // Drop time-to-live expired packets.
  if (ipv4.ttl == 0)
    drop;
  set ipv4.ttl = ipv4.ttl - 1; // Decrement time-to-live
  // The ttl has changed. A new checksum must be calculated.
  set ipv4.checksum =
    ipv4_checksum(ipv4.version_ihl, ipv4.dscp_ecn, ipv4.len, 
                  ipv4.id, ipv4.fragment, ipv4.ttl, 
                  ipv4.protocol, ipv4.src, ipv4.dst);
}
\end{lstlisting}
\end{codepage}

Fields from the IPv4 header are passed to a function named 
\texttt{ipv4\_checksum} (whose definition has been elided for brevity). The 
resulting checksum is compared against the current checksum using an \texttt{if} 
statement. If they do not compare equal, then the packet is dropped using the 
\texttt{drop} action.

Decrementing the time-to-live (\texttt{ipv4.ttl}) is also a common operation. 
First the time-to-live is checked to see if it is \texttt{0}. If it is, then the 
packet's lifetime has expired and it will be dropped. If the packet is still 
valid, the field is decremented using simple subtraction and the 
\texttt{set} action. Because a field has been changed in the IPv4 
header, the checksum must be recalculated and set with the new checksum.

Field access expressions do have a number of limitations. The following example
demonstrates some of them.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) {
  // Error: Cannot use eth.type before its extracted.
  if (ethernet.type >= 0x600) { }
  extract ethernet.type;
  // Error: Cannot assign to a field this way.
  ethernet.type = 0x800;
  // OK: A set action must be used instead.
  set ethernet.type = 0x800;
}

decoder ipv4_decode(ipv4) {
  // Error: This decoder does not decode ethernet.
  extract ethernet.type;
  // Error: ethernet.type was not extracted by this decoder.
  if (ethernet.type == 0x800) { }
}
\end{lstlisting}
\end{codepage}

A field access expression can only be used \textit{after} an extract declaration
is made for that field since it is impossible to recover the value of a
field which has not been extracted. By extensions, they cannot be used inside a
decoder that has not extracted that field even if a prior decoder extracted that field. A decoder focuses on exactly one
header and has no knowledge of previous headers or extractions.
Field access expressions are not the same as variables and may not be assigned to like one. To modify the
value of a field, a \texttt{set} action must be used instead.

\subsection{Rebinding Extracted Fields}

The context binding environment
allows fields to be rebound with different names. This essentially
allows the a field to be referred to using a different name.
When extracting multiple fields of the same name, this allows the
programmer to disambiguate them. 

More commonly it is used to rename fields so that they may be reinterpreted as other fields. For example, assume that an Ethernet
frame has a VLAN tag. The \texttt{ethertype} field of the VLAN tag is what 
actually informs the switch what Layer 3 protocol is encapsulated
by Ethernet. 
A rebind declaration (\ref{guide:rebind}) is used to alias a field with a new name.
So for example:

\begin{codepage}
\begin{lstlisting}
layout vlan {
	tci : uint(16);
	ethertype : uint(16);
}

decoder start eth_d(ethernet) {
	extract ethernet.type;
	match(ethernet.type) {
		case 0x8100: decode vlan_d;
	}
}

decoder start vlan_d(vlan) {
	extract vlan.ethertype as ethernet.type; // Rebind
	goto ethtable;
}
\end{lstlisting}
\end{codepage}

In \texttt{vlan\_d}, the \texttt{extract vlan.ethertype as ethernet.type} allows the extraction of \texttt{vlan.ethertype} to be referred to as
\texttt{ethernet.type} in future stages. The \texttt{vlan.ethertype}
is the \emph{original} field and \texttt{ethernet.type} is the \emph{alias} field.
Consider the following table:

\begin{codepage}
\begin{lstlisting}
exact_table ethtable(ethernet.type) {
	{ 0x8100 } -> { ... }
	{ 0x86dd } -> { ... }
}
\end{lstlisting}
\end{codepage}

Assume that \texttt{vlan.ethertype} has a value of \texttt{0x86dd}.
When \texttt{vlan\_d} sends the packet to \texttt{ethtable}, it will
match the flow entry whose match field is \texttt{0x86dd}. Because of
the rebind \texttt{ethernet.type} refers to the extracted \texttt{vlan.ethertype}.


\subsection{Stage Transition} \label{tut:decoder_next}

Once the current stage has finished its work, the programmer may decide
to send the packet to another pipeline stage.
Section \ref{pipeline_comp_desc} describes that decoding and
table matching stages can be chained together in a number of flexible ways.
Any stage may move a packet to a new decoder or a new table.

To move to another decoding stage, the \texttt{decode} action (see \ref{tut:decode_action})
is used. The following example bridges the Ethernet and IPv4 decoders
declared in earlier examples. Extract declarations are elided for
brevity.

\begin{codepage}
\begin{lstlisting}
decoder start eth_d(ethernet) {
	// ...
	if (ethernet.type >= 0x600)
	    match (ethernet.type) {
	      case 0x800: decode ipv4_d;
	    }
}

decoder ipv4_d(ipv4) { ... }
\end{lstlisting}
\end{codepage}

The \texttt{match} statement is used to check if \texttt{ethernet.type} is equal to
\texttt{0x800}. If it is, then it confirms the next header is IPv4 and the \texttt{decode} action moves the packet to the IPv4 decoder.

To transition to a table matching stage, a \texttt{goto} action (see \ref{tut:goto_action}) (not
to be confused with a C-like \texttt{goto}) is used.

\begin{codepage}
\begin{lstlisting}
decoder ipv4_d(ipv4) {
  // ...
  var ihl : uint(8) = (ipv4.version_ihl & 0x0f) * 4;
  // Advance specifier shifts the view by N bytes.
  goto tcp_filter advance ihl; // tcp_filter names a table.
}
\end{lstlisting}
\end{codepage}

In this example, the \texttt{goto} action sends the packet to a hypothetical table
named \texttt{tcp\_filter}. Details about writing tables follows in Section \ref{tut:table}. 
The most important thing to notice from this example is the
\texttt{advance} specifier.

Section \ref{tut:extract_how} explains that a decoder shifts the
\textit{view} of a packet before moving to the next stage. That shift is by the
length of the header. IPv4 headers are dynamic in length. Even though Steve does not
currently support extracting dynamic length fields, one must still account for
them. To correctly do this, the \texttt{advance} specifier is applied to
explicitly shift the view by the given number of \textit{bytes}. 
Here, the \texttt{ihl} calculation determines the number of bytes in the header.
The assumption is made that all headers are byte-aligned, therefore advancing by
a number of bytes (rather than bits) is appropriate. 

The \texttt{advance} specifier may appear on both \texttt{goto} and \texttt{decode} actions. However, it may only appear in a decoder, as decoders are the only
stage concerned with views.

A stage is \textit{complete} once it executes a \texttt{decode} or \texttt{goto} action, or
finishes executing without either action being executed. 
These two actions are similar in semantics to a function return
in that the stage will not execute anything after them.
If no stage transition happens at all,
the packet exits the pipeline and enters egress processing.

Actions appended to the context's action list are executed before a forwarding decision is made.
The original packet is forwarded based on the egress port field stored
within the packet context. This field is set when executing an
output action that has been written to the context's action list
(see \ref{tut:write_action}) for an example). If this field was not set,
then the packet is implicitly dropped.

\section{Tables} \label{tut:table}

The next stage is the table matching stage which uses the flow table mechanism described in Section \ref{table_desc} to direct network flows. Flow tables are decision tables that are built into the language.

\subsection{The Basic Table} \label{tut:basic_table}

The following example presents the basic form of a table which
groups TCP packets by destination port. The definition of the TCP
layout has been elided here, but may be found in Section \ref{tut:firewall}.

\begin{codepage}
\begin{lstlisting}
exact_table tcp_filter(tcp.dst) {
	// Flow entries...
}
\end{lstlisting}
\end{codepage}

Each flow table is comprised of three parts: 
1) a name (\texttt{tcp\_filter}), 
2) a \textit{key}, and
3) a set of \textit{flow entries}. 
Additionally, there may be three kinds of flow tables: 
\textit{exact}, \textit{prefix}, and \textit{wildcard}. 
This is an exact match table (Steve currently only supports exact
match tables).

A table's \textit{key} provides a comma-separated list of field names, known as
\textit{key fields}, which indicate which protocol fields a table matches on.
They are the equivalent of decision attributes. 
The \texttt{tcp\_filter} table matches on a single field (\texttt{tcp.dst}).

It is important to note that a \texttt{goto} action may only dispatch
a packet to a table if the key fields have been extracted in prior decoders. This ensures that the key fields actually exist before matching begins. If they have not been extracted, the program is ill-formed. How the compiler checks this is explained in Section \ref{guide:requirements}.

Flow entries define the criteria for a network flow, and
what actions are taken on packets belonging to those flows.
They are the rules of a decision table.
To write a flow entry, a \textit{flow entry declaration}
(see \ref{guide:tables}) is used.
The following example presents three flow entries:
two regular ones followed by a special one known as the \emph{miss case}.

\begin{codepage}
\begin{lstlisting}
exact_table tcp_filter(tcp.dst) {
	{ 80 } -> { goto forward; }
	{ 443 } -> { goto forward; }
	miss -> { drop; }
}
\end{lstlisting}
\end{codepage}

A flow entry declaration has two parts: 1) \textit{match
fields} and 2) an \textit{action sequence} (also called the body of the entry). 
Match fields appear as a comma-separated list of expressions 
in the brace-enclosed block (\{\}) before the \texttt{->}. 
The first two flow entries have a single match field each --
\texttt{80} and \texttt{443}, respectively.

Match fields are values which correspond to the table's key fields. 
When a packet is matched against a table,
the table compares the packet's fields with the match fields of each flow entry.
A packet \textit{matches} a flow entry if each field (which is part of the
table's key) in the packet matches each corresponding match field in the flow 
entry. 

The action sequence is given in the brace-enclosed block (\{\}) after the \texttt{->}. When a packet matches a flow entry, actions in this
sequence are executed.
In this example, if a packet's TCP destination port field is equal to \texttt{80},
then it will match the first flow entry and it will be sent to another flow table
named \texttt{forward}. The same is true for packets whose TCP destination
port field is equal to \texttt{443}.

The third flow entry is a special entry known as the \textit{miss case}. The miss 
case uses the keyword \texttt{miss} rather than providing match fields. If no 
other flow entry in a table can match a packet, the miss case is used. A table 
may only have one miss case. If one is not given, an implicit one exists which 
is the equivalent to the second flow entry in the example. That is, by default 
miss cases drop a packet.

Flow entries declared within a flow table body are known
as \textit{initial flow entries}. 
They get installed when a Steve application is loaded by the runtime.
Flow entries may also be added to a flow table after it has begun processing packets. 
An example of adding and removing flow entries can be found in Section \ref{tut:insert_flow_action} and \ref{tut:remove_flow_action}, respectively.

\subsection{A More Complex Table} \label{tut:complex_table}

The \texttt{tcp\_filter} table from Section \ref{tut:basic_table} is only the most basic of flow tables. 
Flow tables can have more complicated use cases.
Not all flow tables will match on a single field. In fact, most flow tables will
match on many fields. The following table declaration demonstrates this.

\begin{codepage}
\begin{lstlisting}
exact_table ip_proto(ipv4.fragment, ipv4.protocol) {
  { 0x0, 0x11 } -> { decode udp_d; }
  // And so on...
}
\end{lstlisting}
\end{codepage}

This table classifies packets into flows based on their fragment value
and the IP encapsulated transport layer protocol. This flow entry
groups non-fragmented, UDP packets.

Flow entries may also have \textit{properties}. Properties are additional
information stored alongside flow entries. 
Steve currently supports two properties: timeout and egress.
The following example extends the previous \texttt{ip\_proto} table with a new flow entry using the timeout property.

\begin{codepage}
\begin{lstlisting}
exact_table ip_proto(ipv4.fragment, ipv4.protocol) {
  { 0x0, 0x06 } ->
  [timeout = 1000] { decode tcp_d; }
  // And so on...
}
\end{lstlisting}
\end{codepage}

Properties are given in a comma-separated list within the block (\texttt{[ ]}) 
immediately following the \texttt{->}. 
If the timeout property is set, the flow entry will be ejected from its table
after a given number of seconds. This value may be between 1 and 65,535.

The egress property is used to store a reference to a port.
The reason this is needed is not immediately obvious without context.
Suppose a flow entry is being inserted into a table using an
\texttt{insert} action.

\begin{codepage}
\begin{lstlisting}
insert into tcp_filter
{ 22 } -> { output in_port; }
\end{lstlisting}
\end{codepage}

Within the inserted flow entry, there is the \texttt{output in\_port} action.
The problem is that the meaning of \texttt{in\_port} is ambiguous. 
Does it refer to the current packet's ingress port, or the ingress port of
future packets that will match this flow entry? Because the packet is
an implicit object within all of these stages, this ambiguity can
arise.

To solve this problem, flow entries may capture the current packet's ingress
port (or any port name in scope) with a new name (\texttt{egress}). So for example:

\begin{codepage}
\begin{lstlisting}
insert into tcp_filter
{ 22 } -> [egress = in_port] { output egress; }
\end{lstlisting}
\end{codepage}

The \texttt{output egress} action now unambiguously says to forward all future
matched packets to the current packet's ingress port.
This is particularly useful for learning applications such as the MAC learning switch in Section
\ref{tut:learning_switch}).

\subsection{Flow Entries as Lambda Closures}

The reason flow entry properties work is because the properties block and body are a lambda closure. 
The body defines the lambda function which executes when a packet matches; the properties block is the environment being closed over.

\subsection{Table Requirements} \label{tut:table_req}

Key fields are typically used to match specific values or sets of values. However, some flow tables may need fields extracted, yet not
necessarily care what the values of those fields are. 
For example, an IPv6 table
may want to decrement the hop-limit field (equivalent to time-to-live).
For these cases, there is the \texttt{requires} specifier.
The following example is a table which matches on one field and also requires
\texttt{ipv6.next\_hop}.

\begin{codepage}
\begin{lstlisting}
exact_table ipv6_proto(ipv6.next_header)
  requires (ipv6.hop_limit) 
{
  { 0x01 } -> {
  	set ipv6.hop_limit = ipv6.hop_limit - 1; 
  	decode icmp_d;
  }
}
\end{lstlisting}
\end{codepage}

The \texttt{requires} specifier is a comma-separated sequence of field names
which must be extracted before the table may match the packet.
Each \textit{required field} can be thought of as a wildcard value (*).

Tables implicitly require their key fields so placing key fields
in the \texttt{requires} specifier is redundant and has no effect. 
Requirements are used by the language to reason about what
fields must be extracted before it is safe to reach a given stage.
It forces the programmer to be aware that they have extracted
a field before using it, otherwise the program is ill-formed. 
How this is enforced is explained in Section \ref{guide:requirements}.

\subsection{When To Use a Flow Table} \label{tut:why_tables}

There are certain scenarios that must be considered before using a
flow table. Flow tables have certain distinct advantages over
static decision structures (\texttt{if} or \texttt{match}).

\textit{Tables can match on one or more fields at once.} The more fields
required in the decision making process, the more complex using nested decision
structures gets. Tables can also match on a packet's ingress port
(\texttt{in\_port}) and physical ingress port (\texttt{in\_phys\_port}) fields
(described in Section \ref{tut:output_action}).

\textit{Tables can match on and use fields from different headers.} Unlike
decoders, tables have access to all extractions. The only limitation is that
field access in the table's flow entries only works on key fields or required fields. For example, the
following is a valid table.

\begin{codepage}
\begin{lstlisting}
exact_table T(in_port, in_phys_port, ethernet.dst, ipv4.dst)
{ ... }
\end{lstlisting}
\end{codepage}

\textit{Flow entries can be added and removed from tables using the appropriate
actions.} This allows decision making on packets to change dynamically during
runtime. It is obviously impossible to add new branches to conditional
statements. The ability to add, or \textit{learn}, new entries allows us to
write applications which can evolve, such as learning switches and routers.

\textit{In some cases conditional statements are preferred over tables.} 
Table matching can be slow. If none of the advantages of using a table are 
needed, it is almost always more beneficial to use a conditional statement. Table 
matching is inherently slower than conditional branching and should actually be 
avoided when possible.

\section{Actions} \label{tut:action}

Actions modify packets, action lists, and pipeline state. Steve supports ten
actions with more anticipated in the future. Actions may appear in decoders,
flow entries, and event handlers.

\subsection{Decode Action} \label{tut:decode_action}

The \texttt{decode} action is used to move a packet from the current stage to a
decoding stage. This action was present throughout a number of examples so far.
For example:

\begin{codepage}
\begin{lstlisting}
decode ipv4_d; // ipv4_d names a decoder
\end{lstlisting}
\end{codepage}


There is also an optional \texttt{advance} specifier which is used if
the \textit{view} of the packet must be explicitly shifted by some special
number of bytes. For example:

\begin{codepage}
\begin{lstlisting}
decode udp_d advance (ipv4.version_ihl & 0x0f) * 4;
\end{lstlisting}
\end{codepage}

The \texttt{advance} specifier may only be attached if the action is executed by a
decoder. Only decoders are responsible for view shifts.

\subsection{Goto Action} \label{tut:goto_action}

The \texttt{goto} action is used to move a packet from the current stage to a
table matching stage. For example:

\begin{codepage}
\begin{lstlisting}
goto t1; // t1 names a table
\end{lstlisting}
\end{codepage}

Similar to the \texttt{decode} action, the \texttt{goto} action also supports an
optional advance specifier. For example, if the current decoder is for IPv4, and
the table is named \texttt{t1}, the action would be written as:

\begin{codepage}
\begin{lstlisting}
goto t1 advance (ipv4.version_ihl & 0x0f) * 4;
\end{lstlisting}
\end{codepage}

The \texttt{advance} specifier may only be attached if the action is executed by a
decoder. Only decoders are responsible for view shifts.

\subsection{Output Action} \label{tut:output_action}

Output actions forward a \textit{copy} of the current packet to a port. 
For example, the following forwards to the reserved flood port. 

\begin{codepage}
\begin{lstlisting}
output flood;
\end{lstlisting}
\end{codepage}

More on ports and how to use the \texttt{output} action with them can
be found in Section \ref{tut:ports}. The flood port is only one
of a number of reserved ports which Steve supports.

There are certain implications to the \texttt{output} action forwarding a copy of the packet. 
Output actions do \emph{not} end pipeline processing on a packet.
Multiple output actions can be executed in the same processing stage. 
Pipeline processing will continue
on the original packet after the \texttt{output} action.

The \textit{original} packet is forwarded after pipeline processing completes,
during egress processing.
At that point the context's action list is executed.
Output actions which have been written to the action list modify the
egress port field in the context when executed.
This field determines where the original packet gets forwarded.

\subsection{Drop Action} \label{tut:drop_action}

A packet can be dropped by the Steve application using the \texttt{drop} action.
The \texttt{drop} action terminates the pipeline processing of a packet.

\begin{codepage}
\begin{lstlisting}
drop;
\end{lstlisting}
\end{codepage}

\subsection{Insert Flow Action} \label{tut:insert_flow_action}

This action is for inserting flow entries into a table.
This allows forwarding decisions to evolve at runtime.

Flow entries can be inserted with constant key values and no properties. Here,
a flow entry is inserted into the table presented in Section
\ref{tut:complex_table}.

\begin{codepage}
\begin{lstlisting}
insert into ip_proto
{ 0x0, 0x89 } -> { decode mpls_d; };
\end{lstlisting}
\end{codepage}

They can also be inserted with recent extraction values and with
optional properties.

\begin{codepage}
\begin{lstlisting}
insert into ip_proto
{ ipv4.fragment, ipv4.protocol } ->
[timeout = 1000] { ... };
\end{lstlisting}
\end{codepage}

If a new flow entry's match fields already exist in the table, the old flow
entry is replaced by the new flow entry. A miss case may be inserted into a
table as well.

\begin{codepage}
\begin{lstlisting}
insert into ip_proto
miss -> { output flood; };
\end{lstlisting}
\end{codepage}

\subsection{Remove Flow Action} \label{tut:remove_flow_action}

A flow entry can be removed from a table by providing match field values and the
name of the table to remove the flow entry from. This can be done with constant
values or extraction values of the current packet. If the flow entry with
those match field values does not exist, nothing is done.

\begin{codepage}
\begin{lstlisting}
remove from ip_proto { 0x0, 0x89 };

remove from ip_proto {ipv4.fragment, ipv4.protocol};
\end{lstlisting}
\end{codepage}

Miss cases can also be removed from tables. When a miss case is removed, it is
replaced by the default miss case (which drops the packet).

\begin{codepage}
\begin{lstlisting}
remove from ip_proto miss;
\end{lstlisting}
\end{codepage}

\subsection{Set Action} \label{tut:set_action}

A \texttt{set} action can be used to write to any extracted field within a
packet. 
The \texttt{set} action is guaranteed to never overflow or underflow when
writing bytes into the packet buffer.
The correct amount of bytes is always written, and always into the correct position in the packet.
To enforce this, the value being written must have the same integer type (specifically precision) as the field being written to. If they mismatch, implicit integer conversion (see \ref{guide:int_conv}) ensures that the value being written gets converted to the correct type.

The time-to-live field from an IPv4 header may be set as follows.

\begin{codepage}
\begin{lstlisting}
set ipv4.ttl = ipv4.ttl - 1;
\end{lstlisting}
\end{codepage}

The \texttt{set} action is only valid if the field access expression is valid in
that stage. For decoders, this means the field has to have been extracted first.
For tables, this means the field must be a key field or a required field. For
events, the field must be a required field. This ensures that a field
has been extracted before it can be written to. Its obviously not possible
to write to a field if its location and length are unknown.

\subsection{Write Action} \label{tut:write_action}

The context data structure described in Section \ref{context_desc} keeps an
\textit{action list}. Actions get written to the action list using the
\texttt{write} action. Written actions get executed once pipeline processing
completes and the packet enters egress processing (described in Section \ref{egress_desc}).
Only two actions may be written to a packet right now: \texttt{output} and \texttt{set}.

\begin{codepage}
\begin{lstlisting}
write set ipv4.ttl = ipv4.ttl - 1;

write output reflow;
\end{lstlisting}
\end{codepage}

The written \texttt{output} action has a slightly different semantic from the immediately
applied \texttt{output} action. When immediately applied, the \texttt{output} action forwards a
\textit{copy} of the packet. The written \texttt{output} action changes the egress port field
in the packet context when executed. This field ultimately decides where to forward the
\textit{original} packet.

\subsection{Clear Action} \label{tut:clear_action}

The \texttt{clear} action removes all actions from the context's action list. If the list is empty, nothing is done.

\begin{codepage}
\begin{lstlisting}
clear;
\end{lstlisting}
\end{codepage}

\subsection{Raise Action} \label{tut:raise_action}

A \texttt{raise} action is used to raise an \textit{event}. Events are used to
signal the control plane that an exceptional situation has happened.
\textit{Event handlers} (described in Section \ref{tut:event}) are used to
deal with these events.

A \texttt{raise} action sends a copy of the context to a reserved port called the controller port that connects to the control plane.
The controller port then offloads the context to the appropriate event handler.
For example:

\begin{codepage}
\begin{lstlisting}
raise log_tcp_port;
\end{lstlisting}
\end{codepage}


Here, \texttt{log\_tcp\_event} names the event handler which will be executed. Its definition can be found in Section \ref{tut:event}. The execution is asynchronous to the pipeline, meaning the pipeline will not wait for it to complete before executing the next action.

Because an event handler may choose to re-enter the context into the pipeline, the raise action may also use an \texttt{advance} specifier when done in a decoder. However, decoders should rarely, if ever, explicitly raise events.

\section{Ports} \label{tut:ports}

Steve supports limited access to ports.
There are two categories of ports to consider when working with Steve: 
\textit{reserved ports} and
\textit{non-reserved ports}.

\subsection {Reserved Ports} \label{tut:reserved_ports}

Reserved ports are named ports which are always present on the system. Some ports may
be directly forwarded to using the \texttt{output} action. Other reserved ports 
are forwarded to implicitly by other actions.

The following reserved ports may be forwarded to by the \texttt{output} action.

\begin{itemize}
\item \emph{All port}. Forwarding to the \textit{all} port will forward copies of the packet to
every port on the system.

\item \emph{Reflow port}. Forwarding to the \textit{reflow} port will send the packet back into
ingress processing. From there it will be processed again by the pipeline from
the beginning.

\item \emph{Flood port}. Forwarding to the \textit{flood} port sends copies of the packet to all
ports on the system \textit{except} the packet's ingress port.
\end{itemize}

Each of these reserved ports can be accessed using a reserved keyword. In the
following, the \texttt{output} action is used to send a packet to these three
ports.

\begin{codepage}
\begin{lstlisting}
output all;
output reflow;
output flood;
\end{lstlisting}
\end{codepage}

The following reserved ports are forwarded to implicitly by other actions.

\begin{itemize}
\item Packets are forwarded to the \textit{drop} port by the \texttt{drop} action.
Packets which are dropped get deleted.

\item Packets are forwarded to the \textit{controller} port when the 
\texttt{raise} action is used.
The controller port is logically connected to the controller (or control plane).
This controller is responsible for dispatching and executing the 
appropriate event handlers.
\end{itemize}

\subsection{Non-reserved Ports} \label{tut:regular_ports}

Non-reserved ports are not guaranteed to be present on all systems.
These ports can be further categorized into \textit{physical} and
\textit{logical} ports. A physical port is a hardware interface on the system. A
logical port is a software defined port which may map to multiple physical ports
and include additional abstractions.

Steve applications currently do not support a way of directly discovering all
these ports and their capabilities. Steve applications can indirectly learn
about these ports by observing the ingress ports of packets passing
through the pipeline.
There are two reserved keywords for getting the logical ingress port and physical ingress port of a packet.

\begin{codepage}
\begin{lstlisting}
in_port; // The logical ingress port.
in_phys_port; // The physical ingress port.
\end{lstlisting}
\end{codepage}

\subsection{Port Variables} \label{tut:declared_ports}

Port variables can be used to \textit{remember} ports for later usage. They are
written using \textit{port declarations} (see \ref{guide:port}).
They work as port variables.

\begin{codepage}
\begin{lstlisting}
Port p1;
Port p2;
\end{lstlisting}
\end{codepage}

Other ports can be assigned to them. This does not copy the port. It just saves
a handle to that port inside the port variable.

\begin{codepage}
\begin{lstlisting}
p1 = in_port; 
p2 = in_phys_port;

output p1; // Forward to these ports.
output p2;
\end{lstlisting}
\end{codepage}

Here, the ingress ports of a packet are saved to port variables \texttt{p1} and \texttt{p2}. An \texttt{output} action may specify a port variable, in which case the packet is forwarded to the port whose handle is stored by the port variable.

\section{Events} \label{tut:event}

An \textit{event handler} is a processing stage executed in the control plane outside the regular
run-to-completion pipeline. They are
functions that operate on packet contexts. 
Event handlers provide an interface for the pipeline to access the control
plane. Certain slower operations
are best performed by event handlers. Since they execute asynchronous to the
data plane's pipeline, they do not bottleneck it.
Specifically, inserting and removing flow entries are best executed inside
events. These operations are multiple times slower
than any other actions in Steve.

Another advantage of event handlers is that they are not subject to the same
limitations on operations as flow tables. They may call functions,
write to files through the C standard library, allocate variables, etc., as
well as execute actions.

To write an event handler, an \textit{event declaration}
(see \ref{guide:event}) is used. The following is a simple example
of an event handler.

\begin{codepage}
\begin{lstlisting}
event log_tcp_port requires(ipv4.dst, tcp.dst) {
	var file : uint(8)& = fopen("blocked.txt", "a");
	fprintf(file, "Blocked packet from %x to TCP port %d", 
			ipv4.dst, ipv4.dst);
	fclose(file);
}
\end{lstlisting}
\end{codepage}

This event handler is used to log IP destination addresses and
TCP destination ports. It is useful for firewall applications.
Event declarations have a \texttt{requires} specifier
like tables. An event may only be raised if all fields listed in its
\texttt{requires} specifier have been extracted.

The \texttt{raise} action described in Section \ref{tut:raise_action}
sends a copy of the context to the event handler.
Any changes made in the event handler does not modify the
original packet or its context.

Steve provides the advantage of being able to write event handlers
in the same language as the pipeline. 
Steve event handlers are thus subject to the same safety
guarantees applied to pipeline stages.
This is possible because Steve targets switches that do not require
centralized control planes.

%\section{Examples} \label{tut:examples}
%
%This section provides four basic network applications: a MAC learning switch, an IPv4 learning switch, a stateless TCP/UDP firewall, and a
%full-duplex wire using language features taught during this tutorial.


