\chapter{Tutorial} \label{tutorial}

This chapter provides a tutorial on the syntax of Steve and using its language features. Steve's primary focus is to provide language features for declaring, specifying, and constructing the pipeline processing stages described in Chapter \ref{pipeline_model}. This chapter will explain how to represent packet headers, how to write decoding stages, how to write table stages, and how to use actions.

By the end of this chapter, a user should be able to write many basic network applications using Steve. Two such applications will be presented; a simple learning switch and a simple learning router. Each example will be composed of smaller components described in this tutorial. 

This chapter will briefly mention semantic details and limitations of each language feature. For complete look at the semantics and limitations of Steve, see the User's Guide in Chapter \ref{users_guide}. For a complete reference of all Steve syntax, see Appendix \ref{ap:a}.

\section{General Purpose Language Features} \label{gen_purp_tut}

\begin{figure}
\begin{mdframed}
\begin{grammar}

<function-decl> ::=
\textbf{def} <function-name> \textbf{-\textgreater} <type> 
\textbf{(} [<parameter-decl-sequence>] \textbf{)} <block-statement>

<parameter-decl> ::=
<parameter-name> \textbf{:} <type-id>

<variable-decl> ::=
\textbf{var} <variable-name> \textbf{:} <type-id> \textbf{=} <expression>

<stmt> ::=
<expr-stmt>
\alt <decl-stmt>
\alt <block-stmt>
\alt <return-stmt>
\alt <assign-stmt>
\alt <match-stmt>
\alt <case-stmt>
\alt <if-then-stmt>
\alt <if-else-stmt>
\alt <while-stmt>
\alt <break-stmt>
\alt <continue-stmt>

<expr-stmt> ::= <expr> \textbf{;}

<decl-stmt> ::= <decl> \textbf{;}


<block-stmt> ::= 
\textbf{\{}
	[ <stmt> + ]
\textbf{\}}

<return-stmt> ::= \textbf{return;}

<assign-stmt> ::= <decl-id> \textbf{=} <expr>

<match-stmt> ::= \textbf{match} \textbf{(} <expr> \textbf{)}
\textbf{\{}
	[ <case-stmt> + ]
\textbf{\}}

<case-stmt> ::=
\textbf{case} <literal-expr> \textbf{:} <stmt>
\alt \textbf{miss:} <stmt>

<if-then-stmt> ::= \textbf{if} \textbf{(} <expr> \textbf{)}
<stmt>

<if-else-stmt> ::= \textbf{if} \textbf{(} <expr> \textbf{)}
<stmt> \textbf{else} <stmt>

<while-stmt> ::= \textbf{while} \textbf{(} <expr> \textbf{)}
<stmt>

<break-stmt> ::= \textbf{break;}

<continue-stmt> ::= \textbf{continue;}

\end{grammar}
\end{mdframed}
\caption{"General purpose" language feature syntax for Steve in BNF.}
\label{fg:general_syntax}
\end{figure}

Figure \ref{fg:general_syntax} provides syntax for these features in BNF notation. Before we delve into language features specifically designed for packet processing, first we must mention a few language features which are more "general purpose." These language features are common to most programming languages and are not explicitly for packet processing, though they are useful and can appear in parts of Steve. These language features are provided as part of the Beaker programming language \footnote{https://github.com/asutton/beaker} from which Steve derives.

\subsection{Variables} \label{variable_tut}

Suppose we wanted to write a variable named \texttt{x} which holds an integer value \texttt{10}. We would write it as follows.

\begin{lstlisting}
var x : int = 10;
\end{lstlisting}

We can assign a new value to it.

\begin{lstlisting}
x = 1;
\end{lstlisting}

We can perform arithmetic and bitwise operations as well. The complete set of arithmetic and bitwise operations can be found in Appendex \cite{ap:a}.

\begin{lstlisting}
var y : int = 2;
var z : int = 3;
y = x + y; // Adding
z = y + z + 1; 
z = z << 4; // Left shift.
var a : int = y & z; // bitwise and
\end{lstlisting}

\subsection{Conditional Statements} \label{condition_tut}

Steve supports three conditional statements: the if-statement, the if-else statement, and match-statement.

An if-statements and if-else statements can be written as follows.

\begin{lstlisting}
var a : bool = true;
var b : bool = false;

// If statement
if (a || b) { }

// If else statement
if (a && b) { }
else if (a) { }
else { }
\end{lstlisting}

A match statement is similar to a C-like switch statement with an implied \texttt{break} after every case. The condition and labels must be integers just like in C. A match statements can be written as follows.

\begin{lstlisting}
// Assuming there are integer variables named x and y.
match (x)
{
  case 0: x = x + 1;
  // Multiple statements following the label must be enclosed in a block.
  case 1:
  {
    x = x + 1;
    y = y * x;
  }
  // The default case statement.
  miss: x = 0;
}
\end{lstlisting}

\subsection{While Loops} \label{while_tut}

While loops appear in Steve just like they appear in C-like languages. They also support the \texttt{break} and \texttt{continue} statements for limited branching abilities inside a loop.

\begin{lstlisting}
var x : int = 0;
var z : int = 0;
while (x < 5) {
  x = x + 1;
  if (x == 3)
    continue;
	
  if (z == 3) 
    break;
  z = z + 1;
}
\end{lstlisting}

\subsection{Functions} \label{function_tut}

Suppose we wanted to write a function named \texttt{sum} which takes two integers, \texttt{a} and \texttt{b}, and returned an integer which is the sum of those two integers. We would write \texttt{sum} as follows.

\begin{lstlisting}
def sum(a : int, b : int) -> int
{
  return a + b;
}
\end{lstlisting}

To call that function we would write the following.

\begin{lstlisting}
var x : int = 1;
var y : int = 2;
var z : int = sum(x, y);
\end{lstlisting}

\section{Layouts} \label{layout_tut}

Before pipeline processing stages can be written, a \textbf{layout} is used to describe the physical structure of a packet header, i.e. what fields they have and the respective lengths of those fields. Steve decoding stages use these layouts to determine two things: what the offset of a given field is relative to the beginning of the header and the length of the field. This information is used to guide the process of extracting fields during decoding stages like a blueprint might be used to find places in a building.

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<layout-decl> ::=
\textbf{layout} <layout-name> 
\textbf{\{}
	<field-decl> +
\textbf{\}}

<field-decl> ::=
<field-name> \textbf{:} <type> \textbf{;}

<type> ::=
<scalar-type>
\alt <layout-type>

<scalar-type> ::= <integer-type>

<integer-type> ::=
\textbf{int} [ \textbf{(} <integer-literal> \textbf{)} ]
\alt \textbf{uint} [ \textbf{(} <integer-literal> \textbf{)} ]

<layout-type> ::=
<layout-decl-id>

\end{grammar}
\end{mdframed}
\caption{Layout syntax for Steve in BNF.}
\label{fg:layout_syntax}
\end{figure}

Suppose we wanted to write a standard ethernet header in Steve \cite{eth_std}. An ethernet header has three fields; \texttt{dst} and \texttt{src} which are both 6 bytes (or 48-bits) long, and a type field which is 2 bytes (or 16-bits long). To write this in Steve, we would use a \texttt{layout} declaration as in Figure \ref{fg:eth_layout_ex}.

\begin{figure}[ht]
\begin{lstlisting}
layout ethernet
{
  dst  : uint(48);
  src  : uint(48);
  type : uint(16);
}
\end{lstlisting}
\caption{An example of the ethernet layout in Steve.}
\label{fg:eth_layout_ex}
\end{figure}

A \textbf{\texttt{layout} declaration} is composed of a sequence of \textbf{field declarations}. Each field declaration corresponds to a field in a header. The type of each field declaration defines the length of the corresponding field in a header. Each field declaration in a layout must be written in the same order with which the field appears in a real instance of the header. If the ordering does not match, layouts will not function correctly during decoding stages.   

A field declaration within a layout is limited to being one of two different types. The first of these types is scalar type (most often a signed/unsigned integer type). Integer types can be given with an optional bit-length precision, with the default being 32-bits if no precision is specified. This bit-length precision is used to determine the length of the field. With Figure \ref{fg:eth_layout_ex} we have a layout composed of fields of only integer type.

The second supported type is layout type. This allows layouts to be nested together in case a programmer must deal structures nested within headers. In this case, a field declaration is used whose type is given as the identifier to layout declaration. In Figure \ref{fg:nested_layout_ex} we give a trivial extension of the ethernet example where we nest a \texttt{vlan} tag.

\begin{figure}[ht]
\begin{lstlisting}
layout ethernet
{
  dst  : uint(48);
  src  : uint(48);
  vlan_tag : vlan;
  type : uint(16);
}

layout vlan
{
  tpid : uint(16);
  tci  : uint(16);
}
\end{lstlisting}
\caption{An example of the ethernet layout with a nested vlan in Steve.}
\label{fg:nested_layout_ex}
\end{figure}

When using layouts it is important to know that there exist distinct differences between layouts and C++-like classes. A layout, though similar to a class, is not a class. Their fields must all be of scalar or layout type. Objects of layout type can never be created and they cannot contain member functions. For further details on layout limitations, refer to Section \ref{layout_guide} in the User's Guide.

Another important note is that Steve does not currently support dynamically sized types (DST) which are types whose size is predicated upon some value known only during program runtime). These DSTs are used to represent header fields whose lengths are dynamic, e.g. predicated upon some value found earlier in the header. Some examples of fields whose types are represented using DSTs are the \texttt{options} fields in IPv4, IPv6, and TCP headers, or the \texttt{ICV} field in the IPSec header.

DSTs are a language feature that will eventually be added, but is outside the scope of this thesis. Because of this, fields whose lengths are dynamic cannot currently be declared, extracted, nor used. The existence and eventual support of DSTs is one of the reasons why objects of layout type cannot be created which is further discussed in Section \ref{layout_guide}.

An IPv4 header example can be seen in Figure \ref{fg:ipv4_layout_ex}. Note that the \texttt{options} field is skipped due to the lack of DSTs. Also note that Steve does not support non-byte aligned data types, and thus the precision of all integers are multiples of 8. Fields which are non-byte aligned must be merged to byte alignment and recovered using arithmetic operations (see Figure \ref{fg:assign_arith_ex} in Section \ref{decoder_tut} for an example). 

\begin{figure}[ht]
\begin{lstlisting}
layout ipv4
{
  version_ihl : uint(8);
  dscp_ecn    : uint(8);
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16);
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
}
\end{lstlisting}
\caption{An example of how the IPv4 header is written in Steve. Note that the "options" field is not included because Steve does not currently support extraction or usage of dynamic length fields.}
\label{fg:ipv4_layout_ex}
\end{figure}

\section{Decoders} \label{decoder_tut}

\textbf{Decoders} represent the decoding stages in the pipeline. In Steve these decoders  are special purpose functions used to handle decoding and extracting fields in a given header. By chaining multiple decoders together, a user can construct a set of functions used to parse an entire packet. \textbf{Decoder declarations} are Steve's way of defining decoding stages. Decoder declarations provide users the ability to:

\begin{itemize}
\item Declare which header is being decoded and which fields to extract from it.
\item Perform arithmetic and logical operations on fields.
\item Perform actions on the header. See Section \ref{action_tut} for examples of action usage.
\item Decide what processing stage comes next. Either the next header is determined and the packet is dispatched to that decoding stage, or the packet is dispatch to table matching.
\end{itemize}

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<decoder-decl> ::=
\textbf{decoder} <decoder-name> [\textbf{start}] 
\textbf{(} <layout-id> \textbf{)}
<block-statement>

<extract-decl> ::=
\textbf{extract} <field-name> \textbf{;}

<rebind-decl> ::=
\textbf{extract} <field-name> \textbf{as} <field-name-expr> \textbf{;}

<field-name> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-name> \textbf{.} <field-id>

<field-access-expr> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-access-expr> \textbf{.} <field-id>

\end{grammar}
\end{mdframed}
\caption{Decoder syntax for Steve in BNF.}
\label{fg:decoder_syntax}
\end{figure}

\subsection{Extractions} \label{decoder_extract_tut}

The primary goal of decoders is to extract fields from headers. Assume we wanted to write a decoder to extract the \texttt{src} and \texttt{dst} fields from the ethernet header. Remember, Steve allows for the partial decoding of packets, so if we do not need a field, in this case \texttt{type}, its not necessary to extract it. 

First, a layout for the ethernet header must be defined. Steve decoders use layouts to determine where fields are relative to the beginning of the header and how long those fields are. More details on this process can be found in Section \ref{decoder_guide}. Here we can use the layout defined in Figure \ref{fg:eth_layout_ex}. 

After that, we can proceed to writing the decoder declaration. Figure \ref{fg:extract_ex} demonstrates how the decoder is written. We give this decoder declaration the name \texttt{eth\_decode}. The layout used to decode is given in the parenthesis following the name (in this case \texttt{ethernet}).

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  // More code to follow...
}
\end{lstlisting}
\caption{An example of how to extract \texttt{src} and \texttt{dst} fields from the ethernet header using a decoder. Note we do not extract the \texttt{type} field here.}
\label{fg:extract_ex}
\end{figure}

A decoder can only extract fields from a header defined by this layout. If an attempt is made to extract a field from a different header a compiler error is emitted. The optional \texttt{start} keyword is attached to this decoder to denote that this decoder is the first stage in the pipeline. Ethernet is the most commonly used data link layer protocol, making it the most common header to start with. There can only be one starting decoder.

To extract a field, the programmer writes an \textbf{extract declaration} which requires that a field be specified using a \textbf{field name}. A field name is used to refer to a field of a layout. For example \texttt{eth.dst} refers to the \texttt{dst} field of the \texttt{ethernet} layout.  Note that this is distinctly different from member access as the \texttt{ethernet} layout is not an object. 

The first extract declaration (\texttt{extract ethernet.dst}) says that the decoder extracts the \texttt{dst} field of the \texttt{ethernet} header. The second extract declaration (\texttt{extract ethernet.src}) says that the decoder extracts the \texttt{src} field of the \text{ethernet} header. 

\subsection{Accessing Extracted Fields} \label{decoder_access_tut}

After extracting a field from a header, we generally want to use the \textit{value} of that field. To use the value of an extracted field, we need the \textbf{field access expression}. Field access expressions have the same grammar as field names, but they can be used wherever any expression is valid.  The field access expression is a lexical place-holder which refers to some field that has been extracted with the same name. A good analogy would be field access expressions are to extracted fields what variable identifiers are to variables.

Figure \ref{fg:access_ex} demonstrates how the value of extracted fields can be used. In this scenario, we extract \texttt{ethernet.type}. Here we want to make a decision about what the value of \texttt{ethernet.type} means. The IEEE ethernet standard says that if the \texttt{type} field is greater than or equal to hexadecimal \texttt{0x600}, then the value of the field is used to determine the kind of header encapsulated by the ethernet header \cite{eth_std}. Otherwise, if the \texttt{type} field is less than hexadecimal \texttt{0x05dc}, the field refers to the length of the ethernet frame. Here we use field access expressions in comparison expressions and an if-else statement to determine how to proceed with the packet. 

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  extract ethernet.type;
  
  // Using a field access expression 
  // with logical operator >=
  if (ethernet.type >= 0x600)
  {
    // Then this field determines what
    // header comes next.
  }
  // Using a field access expression 
  // with logical operator <=
  else if (ethernet.type <= 0x05dc)
  {
    // Then this field describes the
    // length of the entire packet.
  }
  // ...
}
\end{lstlisting}
\caption{An example of accessing a field using the field access expression in an if-else statement.}
\label{fg:access_ex}
\end{figure}

Field access expressions can also be used in arithmetic operations, bitwise operations, and can be stored and assigned to local variables. Figure \ref{fg:assign_arith_ex} demonstrates how this can be done using an IPv4 decoder as an example.

\begin{figure}[ht]
\begin{lstlisting}
decoder ipv4_decode(ipv4)
{
  extract ipv4.len;
  extract ipv4.version_ihl;
  extract ipv4.ttl;
  
  // We can assign to variables
  var pktlen : uint = ipv4.len;
  
  // We can perform bitwise operations.
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  // We can also perform shifts.
  var version : uint(8) = ipv4.version_ihl >> 4;
  
  // Determine what the Time-to-Live is after this
  // device finishes with the packet.
  var next_ttl : uint = ipv4.ttl - 1;
  
  // ...
}
\end{lstlisting}
\caption{Using arithmetic operations, bitwise operations, and variable assignment with fields in a Steve program.}
\label{fg:assign_arith_ex}
\end{figure}

First we assign \texttt{ipv4.len} field to a local variable named \texttt{pktlen}. We attempt to recover the \texttt{ihl} value by using bitwise-and to mask the first 4 bits (to deal with the limitation of supporting only byte aligned fields). After that we recover the version field by performing a right shift operation by 4 bits. In case we wanted to know the time-to-live value after the packet leaves this device, we perform subtraction on the \texttt{ipv4.ttl} field.

Field access expressions do have a number of limitations. A field access expression can only be used \textit{after} an extract declaration is used for that field. After all, it is impossible to recover the value of a field which has not been extracted. They cannot be used in decoders which have not extracted that field. A decoder focuses on exactly one header and has no knowledge of previous headers or extractions. Field access expressions cannot be assigned to like a variable identifier. To modify the value of a field in a header, an action must be used (see Section \ref{action_tut}). Figure \ref{fg:bad_access_ex} shows incorrect usage of field access expressions.

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  // Error: Cannot use eth.type before its extracted.
  if (ethernet.type >= 0x600) 
  {
    // Do something...
  }
  
  extract eth.type;
  
  // Now that its been extracted ...
  // Error: Cannot assign to a field this way.
  ethernet.type = 0x800;
  // ...
}

decoder ipv4_decode(ipv4)
{
  // Error: eth.type was not extracted by this decoder.
  if (ethernet.type == 0x800)
  // ...
}
\end{lstlisting}
\caption{An example of incorrect field access.}
\label{fg:bad_access_ex}
\end{figure}

\subsection{Moving to Other Stages} \label{decoder_next_tut}

As mentioned earlier, decoding and table matching stages can be chained together in a number of flexible ways. A decoder can transition a packet to another decoder, it can transition to a table matching stage, or it can forward/drop the packet. Its up to the programmer to decide which is appropriate. Every stage in the pipeline is \textbf{required} to do one of these three.

To transition to another decoding stage, a \texttt{decode} action is used. To transition to a table matching stage, a \texttt{goto} action (not to be confused with a C-like \texttt{goto}) is used. 

Figure \ref{fg:transition_ex} demonstrates how to move from a decoder to a decoder, from a decoder to a table, then from a table to another decoder. We present two decoders and one table. The \texttt{eth\_decode} decoder transitions to \texttt{ipv4\_decode} if the \texttt{ethernet.type} field is equal to \texttt{0x800}. The line \texttt{decode ipv4\_decode} causes the transition of the packet that decoding stage.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.type;
  if (ethernet.type >= 0x600) 
  {
  	// Check to see if the next header is ipv4.
    match (ethernet.type)
    {
      case 0x800: decode ipv4_decode;
    }
  }
  
  // Do something else...
}

decoder ipv4_decode(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.dst;
  extract ipv4.protocol;
  
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  
  goto t1 advance ihl;
}

exact_table t1(ipv4.protocol)
{
  {0x11} ->
  {
    // Assuming a udp decoder exists named "udp_decode"
    decode udp_decode;
  }
  
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of using \texttt{decode} and \texttt{goto} to transition between stages.}
\label{fg:transition_ex}
\end{figure}

When we decode headers from packets, there is a concept of a \textit{current view} of the packet. The \textit{current view} begins at the byte offset in the packet where the current header starts and ends where the header ends. Imagine it like a window which the decoder uses to "look" in on the current header. Remember that decoders use layouts to determine the location of fields by calculating their offset from the beginning of their respective header. By extension, the location of a field is its offset from the beginning of the \textit{current view}. 

When a packet transitions away from a decoder towards another stage, the \textit{current view} of the packet must shift. Normally, the view is implicitly shifted by the length of the header. The user does not have to quantify how far the view must shift. However, in cases where a header's length is dynamic and predicated on some value, the user must quantify exactly how far the view must shift. To do this, an \textit{optional} \texttt{advance} clause can be attached to both \texttt{decode} and \texttt{goto} actions. Further details about how this view and shifting process work can be found in Chapter \ref{users_guide} Section \ref{decoder_guide}.

In this case, the \texttt{ipv4\_decode} decoder transitions to table \texttt{t1} using a \texttt{goto} action. Remember that real IPv4 headers can have a dynamic length \texttt{options} field even if we cannot extract it in Steve yet. The length of an IPv4 header (in bytes) is the value of its \texttt{ihl} field times 4. When we transition, we must quantify the length of this header with the \texttt{advance} clause which explicitly shifts the view by the given amount.

Then from table \texttt{t1}, if the \texttt{ipv4.protocol} field is equal \texttt{0x11}, the packet is transitioned to a hypothetical UDP decoder.

\section{Tables} \label{table_tut}

The next stage to explore is the table matching stage. Table matching allows the programmer to \textbf{classify} packets based on the values of their fields and perform a specific sequence of actions on like-classified packets. This is done through a mechanism known as a flow table \cite{openflow_spec}. A \textbf{flow table} is composed of a set of \textbf{flow entries}. A flow entry is a mapping of unique keys to flows. A \textbf{key} is defined as a field value or unique combination of field values such that every key in the flow table can be uniquely identified. A \textbf{flow} is defined as a sequence of actions (operations that can affect a packet, its action set, or the pipeline).

There are three commonly used types of flow tables: \textbf{exact}, \textbf{prefix}, and \textbf{wildcard} matching tables. Steve currently only supports the exact match table. 

With an exact match table, each field in the packet must \textit{exactly} match the corresponding field value in a flow entry's key for the packet to match that flow entry. If a flow entry match is found by the table, the flow is executed on the packet.

Figure \ref{fg:table_syntax} provides the syntax for writing tables and flow entries in Steve. Tables are written using \textbf{table declarations} and flow entries are written using \textbf{flow declarations}.

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}
<table-decl> ::=
\textbf{exact\_table} <table-name> \textbf{(} <key-decl-sequence> \textbf{)} 
[ <requires-clause> ]
\textbf{\{} 
<flow-decl> + 
\textbf{\}}

<key-decl> ::=
<layout-id> \textbf{.} <field-id>
\alt <key-decl> \textbf{.} <field-id>
\alt \textbf{in\_port}
\alt \textbf{in\_phys\_port}

<requires-clause> ::=
\textbf{requires} \textbf{(} <field-name-sequence> \textbf{)}

<flow-decl> ::=
<properties-block>
\textbf{\{} [<expr-sequence>] \textbf{\}} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\alt <miss-flow-decl>

<properties-block> ::=
\textbf{[} <property-sequence> \textbf{]}

<property> ::=
<property-kind> \textbf{=} <expr>

<property-kind> ::=
\textbf{timeout}
\alt \textbf{egress}

<miss-flow-decl> ::=
\textbf{miss} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\end{grammar}
\end{mdframed}
\caption{Table syntax for Steve in BNF.}
\label{fg:table_syntax}
\end{figure}

Assume we have an IPv4 header already decoded. We want to decode the data portion following the IPv4 header, but to do that we must know what kind of data that is there. The data following an IPv4 header is determined by the value \texttt{ipv4.protocol} field. Now we also add the additional restriction that we only want to deal with non-fragmented packets. Whether or not an IPv4 packet is fragmented can be determined by checking the \texttt{ipv4.fragment} field. To solve this problem, we can use table \texttt{ip\_data\_table} presented in Figure \ref{fg:ip_table_ex}.

\begin{figure}
\begin{lstlisting}
exact_table ip_data_table(ipv4.fragment, ipv4.protocol)
	requires (ipv4.ttl)
{
  // NOTE: The fragment field is typically 0 when a packet
  // is not fragmented.
  
  // Flow entry #1 
  // The protocol field is 0x01 for ICMP data.
  { 0x0, 0x01 } ->
  {
    // Using the Set action to decrement the ttl.
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode icmp_decode advance ipv4.version_ihl & 0x0f;
  } 
  
  // Flow entry #2
  // The protocol field is 0x06 for TCP data.
  { 0x0, 0x06 } ->
  {
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode tcp_decode advance ipv4.version_ihl & 0x0f;
  } 
  
  // Flow entry #3
  // The protocol field is 0x11 for UDP data.
  [timeout = 1000]
  { 0x0, 0x11 } ->
  {
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the UDP Decoder.
  	decode udp_decode advance ipv4.version_ihl & 0x0f;
  } 
  
  // Miss Case
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of a simple static routing table which matches on two fields.}
\label{fg:ip_table_ex}
\end{figure}

To write a complete exact match table, the programmer must specify 1) what fields are being used for classification, 2) what additional fields need to be extracted by a decoder before reaching the table, and 3) a set of flow entries. 

The table \texttt{ip\_data\_table} classifies packets based on their \texttt{ipv4.fragment} and \texttt{ipv4.protocol} fields. It requires that \texttt{ipv4.ttl} also be extracted. There are three flow entries and one miss case entry installed in the table. Each key here is unique. If a packet's fields match any of the keys, then their \texttt{ipv4.ttl} field is decremented and their dispatched the next appropriate decoder. If a match does not exist, then the miss case is used. Here, the result is the packet gets dropped. 

In the third flow entry we have a special case where we set the timeout \textbf{property} of the flow entry to \texttt{1000}. Flow entries currently support two properties. The first is \texttt{timeout}. A flow entry is removed from a table after a \texttt{timeout} number of milliseconds. The other is the \texttt{egress} port property which allows flows to use the \texttt{\color{blue}output \color{green}egress} action described in Section \ref{output_action_tut}.

So what makes using a table different from decision structures like an if-else or match statements? As one may have noticed, the table example given in Figure \ref{fg:ip_table_ex} could just as easily be written using a combination of if-else and match statements like we used with the ethernet decoder earlier in Figure \ref{fg:transition_ex}. 

First of all, a table can match on one or more fields at once. The more fields required in the decision making process, the more complex using nested decision structures get.

Second, a table can match on and use fields from different headers. Unlike decoders, tables have a wider perspective on packets. They have access to every field that has been extracted before them using \textbf{field access expressions}. The only limitation is that field access can only occur on fields which the table either matches on or requires explicitly. For example, the following is a perfectly valid table.

\begin{lstlisting}
exact_table t1(ethernet.dst, ipv4.dst)
{
  // ...
}
\end{lstlisting}

Lastly, flow entries can be added and removed from flow entries using the appropriate actions. This allows decision making on packets to change dynamically during runtime. It is obviously impossible to add new branches to if-else and match statements. The ability to add, or \textbf{learn}, new entries allows us to write learning switches and routers.

\section{Actions} \label{action_tut}

Actions change packets, action sets, and pipeline state. Steve supports eleven actions with more anticipated in the future. Actions can be used in both decoders and flows in Steve. The syntax for supported actions can be found in Figure \ref{fg:action_syntax}.

\begin{figure}
\begin{mdframed}
\begin{grammar}
<action-stmt> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <drop-action>
\alt <flood-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>

<decode-action> ::=
\textbf{decode} <decoder-decl-id> \textbf{;}

<goto-action> ::=
\textbf{goto} <table-decl-id> \textbf{;}

<output-action> ::=
\textbf{output} <port-expr> \textbf{;}

<drop-action> ::= \textbf{drop;}

<flood-action> ::= \textbf{flood;}

<clear-action> ::= \textbf{clear;}

<set-field-action> ::= \textbf{set} <field-access-expr> \textbf{=} <expr> \textbf{;}

<insert-flow-action> ::= \textbf{insert} <flow-decl> \textbf{into} <table-id> \textbf{;}

<remove-flow-action> ::= \textbf{remove} \textbf{\{} [ <expr> + ] \textbf{\}}
\textbf{from} <table-id> \textbf{;}

<raise-action> ::= \textbf{raise} <event-id> \textbf{;}

<write-action> ::= \textbf{write} <action-stmt>

\end{grammar}
\end{mdframed}
\caption{Action syntax for Steve in BNF.}
\label{fg:action_syntax}
\end{figure}

\subsection{Decode Action} \label{decode_action_tut}

The \texttt{decode} action is used to move a packet from the current stage to a decoding stage. Assume we want to move to an IPv4 decoder named \texttt{ipv4\_decode}, the action would be written as:

\begin{lstlisting}
decode ipv4_decode;
\end{lstlisting}

Remember that there is also an optional \texttt{advance} clause which can occur if the "view" of the packet must be explicitly shifted by some special number of bytes. For example, if the current decoder is for IPv4, and the next decoder is named \texttt{udp\_decode}, the action would be written as:

\begin{lstlisting}
decode udp_decode advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Goto Action} \label{goto_action_tut}

The \texttt{goto} action is used to move a packet from the current stage to a table matching stage. Assume we want to move to a table named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1;
\end{lstlisting}

Similar to the \texttt{decode} action, the \texttt{goto} action also supports an optional advance clause. For example, if the current decoder is for IPv4, and the table the programmer wants to dispatch to is named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1 advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Output Action} \label{output_action_tut}

The \texttt{output} action is used to egress the packet on a certain port. The action requires that either a user-declared or reserved port is specified. Assuming that a port named \texttt{p1} was declared, to output to this port the action would be written as:

\begin{lstlisting}
output p1;
\end{lstlisting}

Every packet implicitly has an \texttt{in\_port} and \texttt{in\_phys\_port} which can be used as such:

\begin{lstlisting}
output in_port;

output in_phys_port;
\end{lstlisting}

Flow entries all have an (optional) \texttt{egress} port property which can be set. When executing a flow, if this property has been set, the packet can be output to this \texttt{egress} port using:

\begin{lstlisting}
output egress;
\end{lstlisting}

Steve also supports the number of reserved ports which can be used.

\begin{lstlisting}
// Outputs to all ports on the system.
output all; 

// Outputs to a controller
output controller; 

// Sends the packet back to the beginning of the pipeline
output reflow; 
\end{lstlisting}

\subsection{Drop Action} \label{drop_action_tut}

A packet can be dropped by the Steve application using the \texttt{drop} action. No further processing can be done on a dropped packet.

\begin{lstlisting}
drop;
\end{lstlisting}

\subsection{Flood Action} \label{flood_action_tut}

A packet can be flooded to all ports except the packet's ingress port using the \texttt{flood} action.

\begin{lstlisting}
flood;
\end{lstlisting}

\subsection{Set Action} \label{set_action_tut}

A \texttt{set} action can be used to write to any extracted field within a packet. The \texttt{set} action is only valid if the field given by the field access expression is valid in that stage.

\begin{lstlisting}
set ipv4.ttl = ipv4.ttl - 1;
\end{lstlisting}

\subsection{Insert Flow Action} \label{insert_flow_action_tut}

Inserting flow entries into a table is a Steve action not explicitly supported by the OpenFlow standard. Flow entries can be inserted with constant key values and no properties. They can also be inserted with field values of the current packet and with optional properties.

\begin{lstlisting}[float]
// Constant key values.
insert
{ 0x0, 0x89 } ->
{
  set ipv4.ttl = ipv4.ttl - 1;
  decode mpls_decode;
} into ip_data_table;

// Dynamic key values
insert
[timeout = 1000, egress = in_port]
{ ipv4.fragment, ipv4.protocol } ->
{
  output egress;
} into ip_data_table;
\end{lstlisting}

In this case, the flow entry uses the \texttt{ipv4.src} and \texttt{ipv4.dst} fields of current packet as values for the inserted flow entry's key. It also sets the timeout to 1000 and sets the \texttt{egress} property to the current packet's \texttt{in\_port}, making the \texttt{output egress} action valid.

\subsection{Remove Flow Action} \label{remove_flow_action_tut}

A flow entry can be removed from a table by providing a key and the name of the table to remove the flow entry from. This can be done with constant values or dynamic field values of the current packet.

\begin{lstlisting}
// Removal with constant values
remove { 0x0, 0x11 } from ip_data_table;

// Or dynamic values.
remove {ipv4.dst, ipv4.protocol } from ip_data_table;
\end{lstlisting}

\subsection{Write Action} \label{write_action_tut}

The context data structure keeps an \textbf{action set}. This action set is a set of actions which are written to the context using the \texttt{write} action. All actions in this section except the \texttt{raise}, \texttt{insert}, and \texttt{remove} action can be written to an action set.

\begin{lstlisting}
// Writing a set action
write set ipv4.ttl = ipv4.ttl - 1;
// Writing an output action.
write output reflow;
// Writing a drop action.
write drop;
// etc...
\end{lstlisting}

\subsection{Clear Action} \label{clear_action_tut}

The clear action removes all actions from the context's action set.

\begin{lstlisting}
clear;
\end{lstlisting}

\subsection{Raise Action} \label{raise_action_tut}

A \texttt{raise} action is used to trigger an \textbf{event}. Events are Steve's lightweight way of supporting asynchronous execution during pipeline processing. Section \ref{event_tut} demonstrates how to write events. To trigger an event, you use a \texttt{raise} action and give an event identifier as follows.

\begin{lstlisting}
// Assuming we have an event named "learn"
raise learn;
\end{lstlisting}

\section{Events} \label{event_tut}

Steve supports \textbf{events} which are lightweight asynchronous pipeline processing stages. These stages are special because their processing occurs outside of the run-to-completion model that tables and decoders have. 

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<event-decl> ::=
\textbf{event} <event-name> <requires-clause> 
<block-statement>

\end{grammar}
\end{mdframed}
\caption{Event syntax for Steve in BNF.}
\label{fg:event_syntax}
\end{figure}

Each \textbf{event declaration} in Steve declares an \textbf{event handler} which (optionally) declares which fields must be extracted before that event can be raised. When a user raises an event using the \texttt{raise} action, they trigger the execution of the event handler in a separate event thread.

Events are most useful when performing slower actions, namely \texttt{insert} and \texttt{remove}. Inserting flow entries and removing flow entries from a table can be a bottleneck for execution. Events allow these bottleneck actions to be performed when convenient while the packet continues through the run-to-completion model.

In Figure \ref{fg:event_ex}, we declare an event named \texttt{learn\_mac} which inserts flow entries into a table named \texttt{learn} and a table named \texttt{switch}. To raise this event, we would use the action \texttt{\color{blue}raise} \texttt{learn\_mac}. 

\begin{figure}[ht]
\begin{lstlisting}
event learn_mac
	requires(ethernet.src)
{
	insert
	{ ethernet.src } ->
	{
		goto switch;
	}
	into learn;


	insert
	[timeout = 1000, egress = in_port]
	{ eth.src } ->
	{
		output egress;
	}
	into switch;
}
\end{lstlisting}
\caption{An example of an event used to learn which ports are receiving packets from which MAC addresses.}
\label{fg:event_ex}
\end{figure}

An important thing to know when using events is that a \textbf{copy} of the packet and context are sent to the event handler. Any changes made to a packet using an action in the event handler does not modify the original packet or its context. The original packet continues moving through the pipeline after a \texttt{raise} occurs and does not wait for the event handler to execute.

\section{Examples} \label{examples_tut}