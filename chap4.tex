\chapter{Tutorial} \label{tutorial}

This chapter provides a tutorial on the syntax of Steve and using its language features. Steve's primary focus is to provide language features for declaring, specifying, and constructing the pipeline processing stages described in Chapter \ref{pipeline_model}. This chapter will explain how to represent packet headers, how to write decoding stages, how to write table stages, and how to use actions.

Throughout this chapter there be small semantic details mentioned when necessary. For complete details on the semantics of Steve, see the User's Guide in Chapter \ref{users_guide}.

For a complete reference of all Steve syntax, see Appendix \ref{ap:a}.

\section{Layouts} \label{layout_tut}

Before pipeline processing stages can be written, programmers must specify the physical structure of a packet header. To do this, they must use a \textbf{layout declaration}. A layout declaration is composed of a sequence of field declarations. Each field declaration corresponds to a field in the header. The type of each field must be given as a scalar type (usually integer) whose length corresponds to the field's length or a layout type (to allow nested headers). Figure \ref{fg:layout_syntax} provides the syntax for layout declarations in BNF notation.

\begin{figure}
\begin{mdframed}
\begin{grammar}

<layout-declaration> ::=
\textbf{layout} <layout-name> 
\textbf{\{}
	<field-declaration> +
\textbf{\}}

<field-decl> ::=
<field-name> \textbf{:} <type> \textbf{;}

\end{grammar}
\end{mdframed}
\caption{Layout syntax for Steve in BNF.}
\label{fg:layout_syntax}
\end{figure}


An example can be seen in Figure \ref{fg:ethernet_layout_ex} which declares a layout corresponding to the ethernet header \cite{eth_std}. 

The ordering of field declarations in a layout must match the ordering that the corresponding fields appear in a real instance of that header for layouts to function correctly during decoding stages. 

Keep in mind that a layout, though similar to a class, is not a class. Objects of layout type can never be created, they cannot contain member functions, and their fields must all be of scalar or layout type. Layouts are use to determine two things: what the offset of a given field is relative to the beginning of the header and the length of the field. These two pieces of information are important during decoding stages where these fields are extracted. In this way, layouts more closely translate to extraction rules used during the decoding process. Classes, on the other hand, define the shape of objects in memory.

\begin{figure}
\begin{lstlisting}
layout eth
{
  dst  : uint(48);
  src  : uint(48);
  type : uint(16);
}
\end{lstlisting}
\caption{An example of how the ethernet header is written in Steve.}
\label{fg:ethernet_layout_ex}
\end{figure}

The primary reason for this differentiation in Steve are dynamically-sized fields in packet headers. Headers potentially have fields whose memory size is predicated upon some value discovered during runtime. These fields are said to have \textbf{dynamically sized type}. Some examples of this are the \texttt{options} fields in IPv4, IPv6, and TCP headers. Consider that when objects of any type are constructed, stack space must be allocated for them. Except, it is impossible to stack allocate an object whose size is not known during compilation without some hint about its maximum size. Such objects can only be heap allocated, which Steve does not currently support. 

Furthermore, accessing these dynamically-sized fields, recovering their values, and performing operations on them would have to be done through special pointers to ensure the safety of such operations. For further details on layout limitations, refer to Section \ref{layout_guide} in the User's Guide.

Steve does not currently support dynamically sized types. This is a language feature that will eventually be added, but is outside the scope of this thesis. Because of this, fields whose lengths are dynamic cannot currently be declared, extracted, nor used. 

An IPv4 header example can be seen in Figure \ref{fg:ipv4_layout_ex}. Though most fields can be declared correctly, the \texttt{options} field is skipped due to this limitation. Also note that Steve does not support non-byte aligned data types, and thus the precision of all integers are multiples of 8.

\begin{figure}
\begin{lstlisting}
layout ipv4
{
  version_ihl : uint(8);
  dscp_ecn    : uint(8);
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16);
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
}
\end{lstlisting}
\caption{An example of how the IPv4 header is written in Steve. Note that the "options" field is not included because Steve does not currently support extraction or usage of dynamic length fields.}
\label{fg:ipv4_layout_ex}
\end{figure}

Layouts can be nested together in case a programmer must deal with a header with structures nested inside them. In this case, a field declaration is used whose type is given as the identifier to layout declaration. Figure \ref{fg:nested_layout_ex} gives a trivial example of nested layouts.


\begin{figure}
\begin{lstlisting}
layout eth
{
  dst  : uint(48);
  src  : uint(48);
  vlan_tag : vlan;
  type : uint(16);
}

layout vlan
{
  tpid : uint(16);
  tci  : uint(16);
}
\end{lstlisting}
\caption{An example of a layout being nested inside another layout.}
\label{fg:ethernet_layout_ex}
\end{figure}


\section{Decoders} \label{decoder_tut}

\textbf{Decoders}, also referred to as decoding stages in the pipeline processing model,  are special purpose functions in Steve used to handle decoding and extracting fields in a given header. By chaining multiple decoders together, a user can construct a set of functions used to parse an entire packet. \textbf{Decoder declarations} are Steve's way of defining decoding stages. Figure \ref{fg:decoder_syntax} presents the syntax used to write decoders. Decoder declarations provide users the ability to:

\begin{itemize}
\item Declare which header is being decoded and which fields to extract from it.
\item Perform arithmetic and logical operations on fields.
\item Perform actions on the header. See Section \ref{action_tut} for examples of action usage.
\item Decide what processing stage comes next. Either the next header is determined and the packet is dispatched to that decoding stage, or the packet is dispatch to table matching.
\end{itemize}

\begin{figure}
\begin{mdframed}
\begin{grammar}

<decoder-decl> ::=
\textbf{decoder} <decoder-name> [\textbf{start}] 
\textbf{(} <layout-id> \textbf{)}
<block-statement>

<extract-decl> ::=
\textbf{extract} <field-name> \textbf{;}

<rebind-decl> ::=
\textbf{extract} <field-name> \textbf{as} <field-name-expr> \textbf{;}

<field-name> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-name> \textbf{.} <field-id>

<field-access-expr> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-access-expr> \textbf{.} <field-id>

\end{grammar}
\end{mdframed}
\caption{Decoder syntax for Steve in BNF.}
\label{fg:decoder_syntax}
\end{figure}

\subsection{Extractions} \label{decoder_extract_tut}

The primary goal of decoders is to extract fields from headers. Assume we wanted to write a decoder to extract the \texttt{src} and \texttt{dst} fields from an ethernet header. We will need to use the layout defined in Figure \ref{fg:ethernet_layout_ex}. This layout will be used to determine the offset (location) and length of each field in the packet during decoding. More details on this process can be found in Section \ref{decoder_guide}. Remember, as stated in Section \ref{decoder_desc}, Steve allows for the partial decoding of packets, so if we do not need a field, in this case \texttt{type}, its not necessary to extract it.

Figure \ref{fg:extract_ex} demonstrated how the extraction is written. The optional \texttt{start} keyword is used in the declaration to denote that this decoder is the first stage in the pipeline. Ethernet is the most commonly used data link layer protocol, making it the most common header to start with \cite{something}. There can only be one starting decoder. 

To extract a field, the programmer writes an \textbf{extract declaration} which requires that a field be specified using a \textbf{field name}. A field name is used to refer to a field of a layout. In this case, \texttt{eth.dst} refers to the \texttt{dst} field of the \texttt{eth} layout.  Note that this is distinctly different from member access as the \texttt{eth} layout is not an object. 

In Figure \ref{fg:extract_ex}, the first extract declaration (\texttt{extract eth.dst;}) says that the decoder extracts the \texttt{dst} field of the \texttt{eth} header. The second extract declaration (\texttt{extract eth.src;}) says that the decoder extracts the \texttt{src} field of the \text{eth} header. 

A decoder can only extract fields from a single header. If an attempt is made to extract a field from a different header than the one specified for that decoder, a compiler error is emitted.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  extract eth.dst;
  extract eth.src;
  // More code to follow...
}
\end{lstlisting}
\caption{An example of how to extract \texttt{src} and \texttt{dst} fields from the ethernet header using a decoder. Note we do not extract the \texttt{type} field here.}
\label{fg:extract_ex}
\end{figure}

\subsection{Accessing Extracted Fields} \label{decoder_access_tut}

After extracting a field from a header, a programmer will almost certainly want to use the field in some kind of operation whether that be arithmetic or logical. To use the \textit{value} of an extracted field, a programmer uses a \textbf{field access expression}. Field access expressions have the same grammar as field names, but they can be used wherever any expression is valid. The behaviour of field access expressions is similar to how the name of a variable can be used to mean the value stored in that variable in C-like languages.

Figure \ref{fg:access_ex} demonstrates how the value of extracted fields can be used in Steve. In this scenario, we extract \texttt{eth.type} and use the value as a condition in a C-like if-else statement. We use this if-else statement to determine what the \texttt{type} field means. The IEEE ethernet standard says that if the \texttt{type} field is greater than or equal to hexadecimal \texttt{0x600}, then the value of the field is used to determine the kind of header encapsulated by the ethernet header \cite{eth_std}. Otherwise, if the \texttt{type} field is less than hexadecimal \texttt{0x05dc} used to refer to the length of the ethernet frame.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  extract eth.type;
  
  // Using a field access expression 
  // with logical operator >=
  if (eth.type >= 0x600)
  {
    // Then this is determines what 
  }
  // Using a field access expression 
  // with logical operator <=
  else if (eth.type <= 0x05dc)
  {
    // Then this is the length field.
  }
}
\end{lstlisting}
\caption{An example of accessing a field using the field access expression in an if-else statement.}
\label{fg:access_ex}
\end{figure}

Field access expressions can also be used in arithmetic operations, bitwise operations, and can be stored and assigned to in local variables. Figure \ref{fg:assign_arith_ex} demonstrates how this can be done using an IPv4 decoder as an example. First it's shown that it's possible to assign the value of the header's \texttt{len} field to a local variable named \texttt{pktlen}. Next the example shows how to recover \texttt{ihl} and \texttt{version} from a single field (to deal with the limitation of only supporting byte-aligned fields) and store them in variables, as well as demonstrating bitwise-and and left-shift operations on fields. After that, the example demonstrates subtraction on the \texttt{ipv4.len} field to determine what the time-to-live will be after the packet leaves the current device.

\begin{figure}
\begin{lstlisting}
decoder ipv4_decode(ipv4)
{
  extract ipv4.len;
  extract ipv4.version_ihl;
  extract ipv4.ttl;
  
  // We can assign to variables
  var pktlen : uint = ipv4.len;
  
  // We can perform bitwise operations.
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  // We can also perform shifts.
  var version : uint(8) = (ipv4.version_ihl & 0xf0) >> 4;
  
  // Determine what the Time-to-Live is after this
  // device finishes with the packet.
  var next_ttl : uint = ipv4.ttl - 1;
}
\end{lstlisting}
\caption{Using arithmetic operations, bitwise operations, and variable assignment with fields in a Steve program.}
\label{fg:assign_arith_ex}
\end{figure}

Field access expressions do have a number of limitations.
A field access expression can only be used \textit{after} an extract declaration is used for that field. After all, it is impossible to recover the value of a field which has not been extracted. They cannot be used in decoders which have not extracted that field. A decoder focuses on exactly one header and has no knowledge of previous headers or extractions. Field access expressions cannot be assigned to. To modify the value of a field in a header, an action must be used (see Section \ref{action_tut}). Figure \ref{fg:bad_access_ex} shows incorrect usage of field access expressions.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  // Error: Cannot use eth.type before its extracted.
  if (eth.type >= 0x600) 
  {
    // Do something...
  }
  
  extract eth.type;
  
  // Error: Cannot assign to a field this way.
  eth.type = 0x800;
}

decoder ipv4_decode(ipv4)
{
  // Error: eth.type was not extracted by this decoder.
  if (eth.type == 0x800)
  {
    // Do something...
  }
}
\end{lstlisting}
\caption{An example of incorrect field access.}
\label{fg:bad_access_ex}
\end{figure}

\subsection{Moving to Other Stages} \label{decoder_next_tut}

\section{Tables} \label{table_tut}

\section{Actions} \label{action_tut}

\section{Events} \label{event_tut}

\section{Examples} \label{examples_tut}