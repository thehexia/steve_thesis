\chapter{Tutorial} \label{tutorial}

This chapter provides a tutorial on the syntax of Steve and using its language features. Steve's primary focus is to provide language features for declaring, specifying, and constructing the pipeline processing stages described in Chapter \ref{pipeline_model}. This chapter will explain how to represent packet headers, how to write decoding stages, how to write table stages, and how to use actions.

Throughout this chapter there be small semantic details mentioned when necessary. For complete details on the semantics of Steve, see the User's Guide in Chapter \ref{users_guide}.

For a complete reference of all Steve syntax, see Appendix \ref{ap:a}.

\section{Layouts} \label{layout_tut}

Before pipeline processing stages can be written, a \textbf{layout} is used to describe the physical structure of a packet header, i.e. what fields they have and the respective lengths of those fields. Figure \ref{fg:layout_syntax} provides the syntax for layout declarations in BNF notation.

A \textbf{layout declaration} is composed of a sequence of \textbf{field declarations}. Each field declaration corresponds to a field in a header. The type of each field declaration defines the length of the corresponding field in a header. Each field declaration in a layout must be written in the same order with which the field appears in a real instance of the header. If the ordering does not match, layouts will not function correctly during decoding stages. 

\begin{figure}
\begin{mdframed}
\begin{grammar}

<layout-decl> ::=
\textbf{layout} <layout-name> 
\textbf{\{}
	<field-decl> +
\textbf{\}}

<field-decl> ::=
<field-name> \textbf{:} <type> \textbf{;}

<type> ::=
<scalar-type>
\alt <layout-type>

<scalar-type> ::= <integer-type>

<integer-type> ::=
\textbf{int} [ \textbf{(} <integer-literal> \textbf{)} ]
\alt \textbf{uint} [ \textbf{(} <integer-literal> \textbf{)} ]

<layout-type> ::=
<layout-decl-id>

\end{grammar}
\end{mdframed}
\caption{Layout syntax for Steve in BNF.}
\label{fg:layout_syntax}
\end{figure}

A field declaration within a layout is limited to being one of two different types. The first of these types is scalar type (most often a signed/unsigned integer type). Integer types can be given with an optional bit-length precision, with the default being 32-bits if no precision is specified. This bit-length precision is used to determine the length of the field. An example of a layout corresponding to the ethernet header \cite{eth_std} can be seen in Figure \ref{fg:ethernet_layout_ex}. The \texttt{src} and \texttt{dst} fields are 48-bits, or 6 bytes, long. The \texttt{type} field is 16-bits, or 2 bytes, long.

\begin{figure}
\begin{lstlisting}
layout eth
{
  dst  : uint(48);
  src  : uint(48);
  type : uint(16);
}
\end{lstlisting}
\caption{An example of how the ethernet header is written in Steve.}
\label{fg:ethernet_layout_ex}
\end{figure}

The second supported type is layout type. This allows layouts to be nested together in case a programmer must deal with a header with structures nested inside them. In this case, a field declaration is used whose type is given as the identifier to layout declaration. Figure \ref{fg:nested_layout_ex} gives a trivial example of nested layouts.

\begin{figure}
\begin{lstlisting}
layout eth
{
  dst  : uint(48);
  src  : uint(48);
  vlan_tag : vlan;
  type : uint(16);
}

layout vlan
{
  tpid : uint(16);
  tci  : uint(16);
}
\end{lstlisting}
\caption{An example of a layout being nested inside another layout.}
\label{fg:nested_layout_ex}
\end{figure}

Keep in mind that a layout, though similar to a class, is not a class. Objects of layout type can never be created, they cannot contain member functions, and their fields must all be of scalar or layout type. Layouts are use to determine two things: what the offset of a given field is relative to the beginning of the header and the length of the field. These two pieces of information are important during decoding stages where these fields are extracted. In this way, layouts more closely translate to extraction rules used during the decoding process. 

The primary reason for this differentiation in Steve are dynamically-sized fields in packet headers. Headers potentially have fields whose memory size is predicated upon some value discovered during runtime. These fields are said to have \textbf{dynamically sized type}. Some examples of this are the \texttt{options} fields in IPv4, IPv6, and TCP headers. Consider that when objects of any type are constructed, stack space must be allocated for them. Except, it is impossible to stack allocate an object whose size is not known during compilation without some hint about its maximum size. Such objects can only be heap allocated, which Steve does not currently support. 

Furthermore, accessing these dynamically-sized fields, recovering their values, and performing operations on them would have to be done through special pointers to ensure the safety of such operations. For further details on layout limitations, refer to Section \ref{layout_guide} in the User's Guide.

Steve does not currently support dynamically sized types. This is a language feature that will eventually be added, but is outside the scope of this thesis. Because of this, fields whose lengths are dynamic cannot currently be declared, extracted, nor used. 

An IPv4 header example can be seen in Figure \ref{fg:ipv4_layout_ex}. Note that the \texttt{options} field is skipped due to the lack of dynamically sized types. Also note that Steve does not support non-byte aligned data types, and thus the precision of all integers are multiples of 8. Fields which are non-byte aligned must be merged to byte alignment and recovered using arithmetic operations (see Figure \ref{fg:assign_arith_ex} in Section \ref{decoder_tut} for an example). 

\begin{figure}
\begin{lstlisting}
layout ipv4
{
  version_ihl : uint(8);
  dscp_ecn    : uint(8);
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16);
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
}
\end{lstlisting}
\caption{An example of how the IPv4 header is written in Steve. Note that the "options" field is not included because Steve does not currently support extraction or usage of dynamic length fields.}
\label{fg:ipv4_layout_ex}
\end{figure}


\section{Decoders} \label{decoder_tut}

\textbf{Decoders}, also referred to as decoding stages in the pipeline processing model,  are special purpose functions used to handle decoding and extracting fields in a given header. By chaining multiple decoders together, a user can construct a set of functions used to parse an entire packet. \textbf{Decoder declarations} are Steve's way of defining decoding stages. Figure \ref{fg:decoder_syntax} presents the syntax used to write decoders. Decoder declarations provide users the ability to:

\begin{itemize}
\item Declare which header is being decoded and which fields to extract from it.
\item Perform arithmetic and logical operations on fields.
\item Perform actions on the header. See Section \ref{action_tut} for examples of action usage.
\item Decide what processing stage comes next. Either the next header is determined and the packet is dispatched to that decoding stage, or the packet is dispatch to table matching.
\end{itemize}

\begin{figure}
\begin{mdframed}
\begin{grammar}

<decoder-decl> ::=
\textbf{decoder} <decoder-name> [\textbf{start}] 
\textbf{(} <layout-id> \textbf{)}
<block-statement>

<extract-decl> ::=
\textbf{extract} <field-name> \textbf{;}

<rebind-decl> ::=
\textbf{extract} <field-name> \textbf{as} <field-name-expr> \textbf{;}

<field-name> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-name> \textbf{.} <field-id>

<field-access-expr> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-access-expr> \textbf{.} <field-id>

\end{grammar}
\end{mdframed}
\caption{Decoder syntax for Steve in BNF.}
\label{fg:decoder_syntax}
\end{figure}

\subsection{Extractions} \label{decoder_extract_tut}

The primary goal of decoders is to extract fields from headers. Assume we wanted to write a decoder to extract the \texttt{src} and \texttt{dst} fields from an ethernet header. Remember, Steve allows for the partial decoding of packets, so if we do not need a field, in this case \texttt{type}, its not necessary to extract it. 

First, a layout for the ethernet header must be defined. In this case, the layout defined in Figure \ref{fg:ethernet_layout_ex} can be used. This layout will be used to determine the offset (location) and length of each field in the header during decoding. More details on this process can be found in Section \ref{decoder_guide}. 

After that, we can proceed to writing the decoder declaration. Figure \ref{fg:extract_ex} demonstrates how the extraction is written. We give this decoder declaration the name \texttt{eth\_decode} and specify the layout used to decode in the parenthesis following the name (in this case \texttt{eth}). A decoder can only extract fields from a header defined by this layout. If an attempt is made to extract a field from a different header a compiler error is emitted. The optional \texttt{start} keyword is attached to this decoder to denote that this decoder is the first stage in the pipeline. Ethernet is the most commonly used data link layer protocol, making it the most common header to start with. There can only be one starting decoder. 

To extract a field, the programmer writes an \textbf{extract declaration} which requires that a field be specified using a \textbf{field name}. A field name is used to refer to a field of a layout. For example \texttt{eth.dst} refers to the \texttt{dst} field of the \texttt{eth} layout.  Note that this is distinctly different from member access as the \texttt{eth} layout is not an object. 

The first extract declaration (\texttt{extract eth.dst;}) says that the decoder extracts the \texttt{dst} field of the \texttt{eth} header. The second extract declaration (\texttt{extract eth.src;}) says that the decoder extracts the \texttt{src} field of the \text{eth} header. 

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  extract eth.dst;
  extract eth.src;
  // More code to follow...
}
\end{lstlisting}
\caption{An example of how to extract \texttt{src} and \texttt{dst} fields from the ethernet header using a decoder. Note we do not extract the \texttt{type} field here.}
\label{fg:extract_ex}
\end{figure}

\subsection{Accessing Extracted Fields} \label{decoder_access_tut}

After extracting a field from a header, a programmer will almost certainly want to use the field in some kind of operation whether that be arithmetic or logical. To use the \textit{value} of an extracted field, a programmer uses a \textbf{field access expression}. Field access expressions have the same grammar as field names, but they can be used wherever any expression is valid. The behaviour of field access expressions is similar to how the name of a variable can be used to mean the value stored in that variable in C-like languages.

Figure \ref{fg:access_ex} demonstrates how the value of extracted fields can be used in Steve. In this scenario, we extract \texttt{eth.type} and use the value as a condition in a C-like if-else statement. We use this if-else statement to determine what the \texttt{type} field means. The IEEE ethernet standard says that if the \texttt{type} field is greater than or equal to hexadecimal \texttt{0x600}, then the value of the field is used to determine the kind of header encapsulated by the ethernet header \cite{eth_std}. Otherwise, if the \texttt{type} field is less than hexadecimal \texttt{0x05dc}, the field refers to the length of the ethernet frame.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  extract eth.type;
  
  // Using a field access expression 
  // with logical operator >=
  if (eth.type >= 0x600)
  {
    // Then this is determines what
    // header comes next.
  }
  // Using a field access expression 
  // with logical operator <=
  else if (eth.type <= 0x05dc)
  {
    // Then this is the length field.
  }
  // ...
}
\end{lstlisting}
\caption{An example of accessing a field using the field access expression in an if-else statement.}
\label{fg:access_ex}
\end{figure}

Field access expressions can also be used in arithmetic operations, bitwise operations, and can be stored and assigned to local variables. Figure \ref{fg:assign_arith_ex} demonstrates how this can be done using an IPv4 decoder as an example. First it's shown that it's possible to assign the value of the header's \texttt{len} field to a local variable named \texttt{pktlen}. Next the example shows how to recover \texttt{ihl} and \texttt{version} from a single field (to deal with the limitation of only supporting byte-aligned fields). Note that it is possible to use bitwise and shift operations on fields as well. After that, the example demonstrates subtraction on the \texttt{ipv4.len} field to determine what the time-to-live will be after the packet leaves the current device.

\begin{figure}
\begin{lstlisting}
decoder ipv4_decode(ipv4)
{
  extract ipv4.len;
  extract ipv4.version_ihl;
  extract ipv4.ttl;
  
  // We can assign to variables
  var pktlen : uint = ipv4.len;
  
  // We can perform bitwise operations.
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  // We can also perform shifts.
  var version : uint(8) = (ipv4.version_ihl & 0xf0) >> 4;
  
  // Determine what the Time-to-Live is after this
  // device finishes with the packet.
  var next_ttl : uint = ipv4.ttl - 1;
  
  // ...
}
\end{lstlisting}
\caption{Using arithmetic operations, bitwise operations, and variable assignment with fields in a Steve program.}
\label{fg:assign_arith_ex}
\end{figure}

Field access expressions do have a number of limitations. A field access expression can only be used \textit{after} an extract declaration is used for that field. After all, it is impossible to recover the value of a field which has not been extracted. They cannot be used in decoders which have not extracted that field. A decoder focuses on exactly one header and has no knowledge of previous headers or extractions. Field access expressions cannot be assigned to. To modify the value of a field in a header, an action must be used (see Section \ref{action_tut}). Figure \ref{fg:bad_access_ex} shows incorrect usage of field access expressions.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  // Error: Cannot use eth.type before its extracted.
  if (eth.type >= 0x600) 
  {
    // Do something...
  }
  
  extract eth.type;
  
  // Error: Cannot assign to a field this way.
  eth.type = 0x800;
  // ...
}

decoder ipv4_decode(ipv4)
{
  // Error: eth.type was not extracted by this decoder.
  if (eth.type == 0x800)
  {
    // Do something...
  }
  // ...
}
\end{lstlisting}
\caption{An example of incorrect field access.}
\label{fg:bad_access_ex}
\end{figure}

\subsection{Moving to Other Stages} \label{decoder_next_tut}

As mentioned earlier, decoding and table matching stages can be chained together in a number of flexible ways. A decoder can transition a packet to another decoder, it can transition to a table matching stage, or it can forward/drop the packet. Its up to the programmer to decide which is appropriate. Every stage in the pipeline is \textbf{required} to do one of these three.

To transition to another decoding stage, a \texttt{decode} statement is used. To transition to a table matching stage, a \texttt{goto} statement (not to be confused with a C-like \texttt{goto}) is used. 

Figure \ref{fg:transition_ex} demonstrates how to move from a decoder to a decoder, from a decoder to a table, then from a table to another decoder. There are a few important things to note. First, inside the if-statement, we have a match statement. A match statement is similar to a C-like switch statement in every way, except there is an implied \texttt{break} at the end of every case. From the \texttt{eth\_decode} decoder, we move to the \texttt{ipv4\_decode} decoder if the value of \texttt{eth.type} is \texttt{0x800}. 

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(eth)
{
  extract eth.type;
  if (eth.type >= 0x600) 
  {
  	// Check to see if the next header is ipv4.
    match (eth.type)
    {
      case 0x800: decode ipv4_decode;
    }
  }
  
  // Do something else...
}

decoder ipv4_decode(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.dst;
  extract ipv4.protocol;
  
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  
  goto t1 advance ihl;
}

exact_table t1(ipv4.dst, ipv4.protocol)
{
  {0x0a_16_21_2c, 0x11} ->
  {
    // Assuming a udp decoder exists named "udp_decode"
    decode udp_decode;
  }
  
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of using \texttt{decode} and \texttt{goto} to transition between stages.}
\label{fg:transition_ex}
\end{figure}

In the \texttt{ipv4\_decode} decoder, fields get extracted as usual. A \texttt{goto} statement is used to move the packet from the decoder to a table matching stage name \texttt{t1}. However, the \texttt{advance ihl} clause added is not typical. By default, when transitioning from a decoding stage to another stage (either by using \texttt{decode} or \texttt{goto}), the "view" of the current header automatically shifts to a "view" of the next header. This shift implicitly moves the "view" over by the length of the current header. However, with \textbf{all headers of dynamic length} such as IPv4, the shift has to be done explicitly through the advance clause. Further details about how this "view" and shifting process work can be found in Chapter \ref{users_guide} Section \ref{decoder_guide}.

From table \texttt{t1}, if the packet's \texttt{ipv4.dst} and \texttt{ipv4.type} fields match certain values, the packet is sent to a UDP decoder. Otherwise, the miss case is triggered and the packet gets dropped. A tutorial on using tables can be found in Section \ref{table_tut}. 

\section{Tables} \label{table_tut}

The next stage to explore is the table matching stage. Table matching allows the programmer to \textbf{classify} packets and perform a specific sequence of actions on like-classified packets. This is done through a mechanism known as a flow table. A \textbf{flow table} is composed of a set of \textbf{flow entries}. A flow entry is a mapping of unique keys to flows. A \textbf{key} is defined as a field value or unique combination of field values such that every key in the flow table can be uniquely identified. A \textbf{flow} is defined as a sequence of actions (operations that can affect a packet, its action set, or the pipeline).

There are three commonly used types of flow tables: \textbf{exact}, \textbf{prefix}, and \textbf{wildcard} matching tables. Steve currently only supports the exact match table. 

With an exact match table, each field in the packet must \textit{exactly} match the corresponding field value in a flow entry's key for the packet to match that flow entry. If a flow entry match is found by the table, the flow is executed on the packet.

Figure \ref{fg:table_syntax} provides the syntax for writing tables and flow entries in Steve. Tables are written using \textbf{table declarations} and flow entries are written using \textbf{flow declarations}.

\begin{figure}
\begin{mdframed}
\begin{grammar}
<table-decl> ::=
\textbf{table} <table-name> \textbf{(} <key-decl-sequence> \textbf{)} 
[ <requires-clause> ]
\textbf{\{} 
<flow-decl> + 
\textbf{\}}

<key-decl> ::=
<layout-id> \textbf{.} <field-id>
\alt <key-decl> \textbf{.} <field-id>
\alt \textbf{in\_port}
\alt \textbf{in\_phys\_port}

<requires-clause> ::=
\textbf{requires} \textbf{(} <field-name-sequence> \textbf{)}

<flow-decl> ::=
<properties-block>
\textbf{\{} [<expr-sequence>] \textbf{\}} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\alt <miss-flow-decl>

<properties-block> ::=
\textbf{[} <property-sequence> \textbf{]}

<property> ::=
<property-kind> \textbf{=} <expr>

<property-kind> ::=
\textbf{timeout}
\alt \textbf{egress}

<miss-flow-decl> ::=
\textbf{miss} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\end{grammar}
\end{mdframed}
\caption{Table syntax for Steve in BNF.}
\label{fg:table_syntax}
\end{figure}

To write a complete exact match table, the programmer must specify 1) what fields are being used for classification, 2) what additional fields need to be extracted by a decoder before reaching the table, and 3) a set of flow entries. 

A basic static routing table can found in Figure \ref{fg:basic_table_ex}. This code declares a table named \texttt{route} which matches on \texttt{ipv4.dst} and \texttt{ipv4.protocol}. In addition, it requires that \texttt{ipv4.ttl} be extracted. All fields which are part of the table's key are implicitly required to be extracted. Assume that the system has some preconfigured ports with the configuration given in \texttt{p1} and \texttt{p2}. We define two initial flow entries and a miss case for when packets cannot be classified as either entry. 

The first flow entry matches packets whose IP destination address is 69.89.31.226 and whose data protocol is UDP (0x11). The first flow entry matches packets whose IP destination address is 10.24.200.50 and whose data protocol is also UDP.

\begin{figure}
\begin{lstlisting}

// Open sockets with given configuration.
Port p1 = ":5000"
Port p2 = ":5001"

exact_table t1(ipv4.dst, ipv4.protocol)
	requires (ipv4.ttl)
{
  // Flow Entry #1
  // This brace enclosed list defines the key.
  // 0x45_59_1f_e2 == 69.89.31.226
  { 0x45_59_1f_e2, 0x11 } ->
  // This block defines the sequence of actions.
  {
    set ipv4.ttl = ipv4.ttl - 1;
    // output the packet to port p1
    output p1;
  }
  
  // Flow Entry #2
  // 0x0a_18_c8_32 == 10.24.200.50
  {	0x0a_18_c8_32, 0x11 } ->
  {
    set ipv4.ttl = ipv4.ttl - 1;
    // output the packet to port p2
    output p2;
  }
  
  // Miss Case
  miss ->
  {
    // drop the packet
  }
}
\end{lstlisting}
\caption{An example of a simple static routing table which matches on two fields.}
\label{fg:basic_table_ex}
\end{figure}


\section{Actions} \label{action_tut}

Actions are used to change packets, action sets, and the pipeline. Steve supports ten actions with more anticipated in the future.

\begin{figure}
\begin{mdframed}
\begin{grammar}
<action-stmt> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <drop-action>
\alt <flood-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>

<decode-action> ::=
\textbf{decode} <decoder-decl-id> \textbf{;}

<goto-action> ::=
\textbf{goto} <table-decl-id> \textbf{;}

<output-action> ::=
\textbf{output} <port-expr> \textbf{;}

<drop-action> ::= \textbf{drop;}

<flood-action> ::= \textbf{flood;}

<clear-action> ::= \textbf{clear;}

<set-field-action> ::= \textbf{set} <field-access-expr> \textbf{=} <expr> \textbf{;}

<insert-flow-action> ::= \textbf{insert} <flow-decl> \textbf{into} <table-id> \textbf{;}

<remove-flow-action> ::= \textbf{remove} \textbf{\{} [ <expr> + ] \textbf{\}}
\textbf{from} <table-id> \textbf{;}

<raise-action> ::= \textbf{raise} <event-id> \textbf{;}

<write-action> ::= \textbf{write} <action-stmt>

\end{grammar}
\end{mdframed}
\caption{Action syntax for Steve in BNF.}
\label{fg:action_syntax}
\end{figure}

\section{Events} \label{event_tut}

\section{Examples} \label{examples_tut}