\chapter{Tutorial} \label{tutorial}

This chapter provides a tutorial on the syntax of Steve and using its language features. Steve's primary focus is to provide language features for declaring, specifying, and constructing the pipeline processing stages described in Chapter \ref{pipeline_model}. This chapter will explain how to represent packet headers, how to write decoding stages, how to write table stages, and how to use actions.

By the end of this chapter, a user should be able to write many basic network applications using Steve. Three such applications will be presented; a simple learning switch, a simple learning router and a wire. Each example will be composed of smaller components described in this tutorial. To skip directly to these examples, move to Section \ref{examples_tut}.

This chapter will briefly mention semantic details and limitations of each language feature. For the complete anatomy of Steve, see the User's Guide in Chapter \ref{users_guide}. For a complete reference of all Steve syntax, see Appendix \ref{ap:a}.

\section{General Purpose Language Features} \label{gen_purp_tut}

\begin{figure}
\begin{mdframed}
\begin{grammar}

<function-decl> ::=
\textbf{def} <function-name> \textbf{-\textgreater} <type> 
\textbf{(} [<parameter-decl-sequence>] \textbf{)} <block-statement>

<parameter-decl> ::=
<parameter-name> \textbf{:} <type-id>

<variable-decl> ::=
\textbf{var} <variable-name> \textbf{:} <type-id> \textbf{=} <expression>

<stmt> ::=
<expr-stmt>
\alt <decl-stmt>
\alt <block-stmt>
\alt <return-stmt>
\alt <assign-stmt>
\alt <match-stmt>
\alt <case-stmt>
\alt <if-then-stmt>
\alt <if-else-stmt>
\alt <while-stmt>
\alt <break-stmt>
\alt <continue-stmt>

<expr-stmt> ::= <expr> \textbf{;}

<decl-stmt> ::= <decl> \textbf{;}

<block-stmt> ::= 
\textbf{\{}
	[ <stmt> + ]
\textbf{\}}

<return-stmt> ::= \textbf{return;}

<assign-stmt> ::= <decl-id> \textbf{=} <expr>

<match-stmt> ::= \textbf{match} \textbf{(} <expr> \textbf{)}
\textbf{\{}
	[ <case-stmt> + ]
\textbf{\}}

<case-stmt> ::=
\textbf{case} <literal-expr> \textbf{:} <stmt>
\alt \textbf{miss:} <stmt>

<if-then-stmt> ::= \textbf{if} \textbf{(} <expr> \textbf{)}
<stmt>

<if-else-stmt> ::= \textbf{if} \textbf{(} <expr> \textbf{)}
<stmt> \textbf{else} <stmt>

<while-stmt> ::= \textbf{while} \textbf{(} <expr> \textbf{)}
<stmt>

<break-stmt> ::= \textbf{break;}

<continue-stmt> ::= \textbf{continue;}

\end{grammar}
\end{mdframed}
\caption{"General purpose" language feature syntax for Steve in BNF.}
\label{fg:general_syntax}
\end{figure}

Figure \ref{fg:general_syntax} provides syntax for these features in BNF notation. Before we delve into language features specifically designed for packet processing, first we must mention a few language features which are more "general purpose." These language features are common to most programming languages and are not explicitly for packet processing, though they are useful and can appear in parts of Steve. These language features are provided as part of the Beaker programming language \footnote{https://github.com/asutton/beaker} from which Steve derives.

\subsection{Variables} \label{variable_tut}

Suppose we wanted to write a variable named \texttt{x} which holds an integer value \texttt{10}. We would write it as follows.

\begin{lstlisting}
var x : int = 10;
\end{lstlisting}

We can assign a new value to it.

\begin{lstlisting}
x = 1;
\end{lstlisting}

We can perform arithmetic and bitwise operations as well. The complete set of arithmetic and bitwise operations can be found in Appendex \cite{ap:a}.

\begin{lstlisting}
var y : int = 2;
var z : int = 3;
y = x + y; // Adding
z = y + z + 1; 
z = z << 4; // Left shift.
var a : int = y & z; // bitwise and
\end{lstlisting}

\subsection{Conditional Statements} \label{condition_tut}

Steve supports three conditional statements: the if-statement, the if-else statement, and match-statement.

An if-statements and if-else statements can be written as follows.

\begin{lstlisting}
var a : bool = true;
var b : bool = false;

// If statement
if (a || b) { }

// If else statement
if (a && b) { }
else if (a) { }
else { }
\end{lstlisting}

A match statement is similar to a C-like switch statement with an implied \texttt{break} after every case. The condition and labels must be integers just like in C. A match statements can be written as follows.

\begin{lstlisting}
// Assuming there are integer variables named x and y.
match (x)
{
  case 0: x = x + 1;
  // Multiple statements following the label must be enclosed in a block.
  case 1:
  {
    x = x + 1;
    y = y * x;
  }
  // The default case statement.
  miss: x = 0;
}
\end{lstlisting}

\subsection{While Loops} \label{while_tut}

While loops appear in Steve just like they appear in C-like languages. They also support the \texttt{break} and \texttt{continue} statements for limited branching abilities inside a loop.

\begin{lstlisting}
var x : int = 0;
var z : int = 0;
while (x < 5) {
  x = x + 1;
  if (x == 3)
    continue;
	
  if (z == 3) 
    break;
  z = z + 1;
}
\end{lstlisting}

\subsection{Functions} \label{function_tut}

Suppose we wanted to write a function named \texttt{sum} which takes two integers, \texttt{a} and \texttt{b}, and returned an integer which is the sum of those two integers. We would write \texttt{sum} as follows.

\begin{lstlisting}
def sum(a : int, b : int) -> int
{
  return a + b;
}
\end{lstlisting}

To call that function we would write the following.

\begin{lstlisting}
var x : int = 1;
var y : int = 2;
var z : int = sum(x, y);
\end{lstlisting}

\subsection{Literals} \label{literal_tut}

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}
<literal-expr> ::=
<integer-literal>
\alt <binary-literal>
\alt <hexadecimal-literal>

<decimal-digit> ::= \textbf{0} | \textbf{1} | \textbf{2} | \textbf{3} | \textbf{4} | \textbf{5} | \textbf{6} | \textbf{7} | \textbf{8} | \textbf{9}

<hexadecimal-digit> ::= \textbf{\_} | <decimal-digit> | \textbf{a} | \textbf{b} | \textbf{c} | \textbf{d} | \textbf{e} | \textbf{f}             

<binary-digit> ::= \textbf{\_} | \textbf{0} | \textbf{1}

<integer-literal> ::=
<decimal-digit> +

<hexadecimal-literal> ::=
\textbf{0x} <hexadecimal-digit> +

<binary-literal> ::=
\textbf{0b} <binary-digit> +

\end{grammar}
\end{mdframed}
\caption{Syntax for literals in Steve in BNF.}
\label{fg:literal_syntax}
\end{figure}

Steve supports decimal, binary, and hexadecimal integer literals. Steve does not currently support things like IP address literals or MAC address literals. Decimal integers can be written like any other language.

Binary literals all start with the prefix \texttt{0b} followed by any number of \texttt{0} and \texttt{1}. The underscore (\texttt{\_}) can optionally occur anywhere in the literal following the prefix similar to P4 \cite{p4_spec}. This is purely for organization and readability.

\begin{lstlisting}
// These are the same value.
0b10101010
0b1010_1010
\end{lstlisting}

Hexadecimal literals all start with the prefix \texttt{0x} followed by any number of digits between \texttt{0} and \texttt{9}. The underscore (\texttt{\_}) can optionally occur anywhere in the literal following the prefix similar to binary literals.

\begin{lstlisting}
// These are the same value.
0x0800
0x08_00
\end{lstlisting}

\section{Layouts} \label{layout_tut}

Before pipeline processing stages can be written, a \textbf{layout} is used to describe the physical structure of a packet header, i.e. what fields they have and the respective lengths of those fields. Steve decoding stages use these layouts to determine two things: what the offset of a given field is relative to the beginning of the header and the length of the field. This information is used to guide the process of extracting fields during decoding stages like a blueprint might be used to find places in a building.

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<layout-decl> ::=
\textbf{layout} <layout-name> 
\textbf{\{}
	<field-decl> +
\textbf{\}}

<field-decl> ::=
<field-name> \textbf{:} <type> \textbf{;}

<type> ::=
<scalar-type>
\alt <layout-type>

<scalar-type> ::= <integer-type>

<integer-type> ::=
\textbf{int} [ \textbf{(} <integer-literal> \textbf{)} ]
\alt \textbf{uint} [ \textbf{(} <integer-literal> \textbf{)} ]

<layout-type> ::=
<layout-decl-id>

\end{grammar}
\end{mdframed}
\caption{Layout syntax for Steve in BNF.}
\label{fg:layout_syntax}
\end{figure}

Suppose we wanted to write a standard ethernet header in Steve \cite{eth_std}. An ethernet header has three fields; \texttt{dst} and \texttt{src} which are both 6 bytes (or 48-bits) long, and a type field which is 2 bytes (or 16-bits long). To write this in Steve, we would use a \texttt{layout} declaration as in Figure \ref{fg:eth_layout_ex}.

\begin{figure}[ht]
\begin{lstlisting}
layout ethernet
{
  dst  : uint(48);
  src  : uint(48);
  type : uint(16);
}
\end{lstlisting}
\caption{An example of the ethernet layout in Steve.}
\label{fg:eth_layout_ex}
\end{figure}

A \textbf{\texttt{layout} declaration} is composed of a sequence of \textbf{field declarations}. Each field declaration corresponds to a field in a header. The type of each field declaration defines the length of the corresponding field in a header. Each field declaration in a layout must be written in the same order with which the field appears in a real instance of the header. If the ordering does not match, layouts will not function correctly during decoding stages.   

A field declaration within a layout is limited to being one of two different types. The first of these types is scalar type (most often a signed/unsigned integer type). Integer types can be given with an optional bit-length precision, with the default being 32-bits if no precision is specified. This bit-length precision is used to determine the length of the field. With Figure \ref{fg:eth_layout_ex} we have a layout composed of fields of only integer type.

The second supported type is layout type. This allows layouts to be nested together in case a programmer must deal structures nested within headers. In this case, a field declaration is used whose type is given as the identifier to layout declaration. In Figure \ref{fg:nested_layout_ex} we give a trivial extension of the ethernet example where we nest a \texttt{vlan} tag.

\begin{figure}[ht]
\begin{lstlisting}
layout ethernet
{
  dst  : uint(48);
  src  : uint(48);
  vlan_tag : vlan;
  type : uint(16);
}

layout vlan
{
  tpid : uint(16);
  tci  : uint(16);
}
\end{lstlisting}
\caption{An example of the ethernet layout with a nested vlan in Steve.}
\label{fg:nested_layout_ex}
\end{figure}

When using layouts it is important to know that there exist distinct differences between layouts and C++-like classes. A layout, though similar to a class, is not a class. Their fields must all be of scalar or layout type. Objects of layout type can never be created and they cannot contain member functions. For further details on layout limitations, refer to Section \ref{layout_guide} in the User's Guide.

Another important note is that Steve does not currently support dynamically sized types (DST) which are types whose size is predicated upon some value known only during program runtime). These DSTs are used to represent header fields whose lengths are dynamic, e.g. predicated upon some value found earlier in the header. Some examples of fields whose types are represented using DSTs are the \texttt{options} fields in IPv4, IPv6, and TCP headers, or the \texttt{ICV} field in the IPSec header.

DSTs are a language feature that will eventually be added, but is outside the scope of this thesis. Because of this, fields whose lengths are dynamic cannot currently be declared, extracted, nor used. The existence and eventual support of DSTs is one of the reasons why objects of layout type cannot be created which is further discussed in Section \ref{layout_guide}.

An IPv4 header example can be seen in Figure \ref{fg:ipv4_layout_ex}. Note that the \texttt{options} field is skipped due to the lack of DSTs. Also note that Steve does not support non-byte aligned data types, and thus the precision of all integers are multiples of 8. Fields which are non-byte aligned must be merged to byte alignment and recovered using arithmetic operations (see Figure \ref{fg:assign_arith_ex} in Section \ref{decoder_tut} for an example). 

\begin{figure}[ht]
\begin{lstlisting}
layout ipv4
{
  version_ihl : uint(8);
  dscp_ecn    : uint(8);
  len         : uint(16);
  id          : uint(16);
  fragment    : uint(16);
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
}
\end{lstlisting}
\caption{An example of how the IPv4 header is written in Steve. Note that the "options" field is not included because Steve does not currently support extraction or usage of dynamic length fields.}
\label{fg:ipv4_layout_ex}
\end{figure}

\section{Decoders} \label{decoder_tut}

\textbf{Decoders} represent the decoding stages in the pipeline. In Steve these decoders  are special purpose functions used to handle decoding and extracting fields in a given header. By chaining multiple decoders together, a user can construct a set of functions used to parse an entire packet. \textbf{Decoder declarations} are Steve's way of defining decoding stages. Decoder declarations provide users the ability to:

\begin{itemize}
\item Declare which header is being decoded and which fields to extract from it.
\item Perform arithmetic and logical operations on fields.
\item Perform actions on the header. See Section \ref{action_tut} for examples of action usage.
\item Decide what processing stage comes next. Either the next header is determined and the packet is dispatched to that decoding stage, or the packet is dispatch to table matching.
\end{itemize}

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<decoder-decl> ::=
\textbf{decoder} <decoder-name> [\textbf{start}] 
\textbf{(} <layout-id> \textbf{)}
<block-statement>

<extract-decl> ::=
\textbf{extract} <field-name> \textbf{;}

<rebind-decl> ::=
\textbf{extract} <field-name> \textbf{as} <field-name-expr> \textbf{;}

<field-name> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-name> \textbf{.} <field-id>

<field-access-expr> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-access-expr> \textbf{.} <field-id>

\end{grammar}
\end{mdframed}
\caption{Decoder syntax for Steve in BNF.}
\label{fg:decoder_syntax}
\end{figure}

\subsection{Extractions} \label{decoder_extract_tut}

The primary goal of decoders is to extract fields from headers. Assume we wanted to write a decoder to extract the \texttt{src} and \texttt{dst} fields from the ethernet header. Remember, Steve allows for the partial decoding of packets, so if we do not need a field, in this case \texttt{type}, its not necessary to extract it. 

First, a layout for the ethernet header must be defined. Steve decoders use layouts to determine where fields are relative to the beginning of the header and how long those fields are. More details on this process can be found in Section \ref{decoder_guide}. Here we can use the layout defined in Figure \ref{fg:eth_layout_ex}. 

After that, we can proceed to writing the decoder declaration. Figure \ref{fg:extract_ex} demonstrates how the decoder is written. We give this decoder declaration the name \texttt{eth\_decode}. The layout used to decode is given in the parenthesis following the name (in this case \texttt{ethernet}).

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  // More code to follow...
}
\end{lstlisting}
\caption{An example of how to extract \texttt{src} and \texttt{dst} fields from the ethernet header using a decoder. Note we do not extract the \texttt{type} field here.}
\label{fg:extract_ex}
\end{figure}

A decoder can only extract fields from a header defined by this layout. If an attempt is made to extract a field from a different header a compiler error is emitted. The optional \texttt{start} keyword is attached to this decoder to denote that this decoder is the first stage in the pipeline. Ethernet is the most commonly used data link layer protocol, making it the most common header to start with. There can only be one starting decoder.

To extract a field, the programmer writes an \textbf{extract declaration} which requires that a field be specified using a \textbf{field name}. A field name is used to refer to a field of a layout. For example \texttt{eth.dst} refers to the \texttt{dst} field of the \texttt{ethernet} layout.  Note that this is distinctly different from member access as the \texttt{ethernet} layout is not an object. 

The first extract declaration (\texttt{extract ethernet.dst}) says that the decoder extracts the \texttt{dst} field of the \texttt{ethernet} header. The second extract declaration (\texttt{extract ethernet.src}) says that the decoder extracts the \texttt{src} field of the \text{ethernet} header. 

\subsection{Accessing Extracted Fields} \label{decoder_access_tut}

After extracting a field from a header, we generally want to use the \textit{value} of that field. To use the value of an extracted field, we need the \textbf{field access expression}. Field access expressions have the same grammar as field names, but they can be used wherever any expression is valid.  The field access expression is a lexical place-holder which refers to some field that has been extracted with the same name. A good analogy would be field access expressions are to extracted fields what variable identifiers are to variables.

Figure \ref{fg:access_ex} demonstrates how the value of extracted fields can be used. In this scenario, we extract \texttt{ethernet.type}. Here we want to make a decision about what the value of \texttt{ethernet.type} means. The IEEE ethernet standard says that if the \texttt{type} field is greater than or equal to hexadecimal \texttt{0x600}, then the value of the field is used to determine the kind of header encapsulated by the ethernet header \cite{eth_std}. Otherwise, if the \texttt{type} field is less than hexadecimal \texttt{0x05dc}, the field refers to the length of the ethernet frame. Here we use field access expressions in comparison expressions and an if-else statement to determine how to proceed with the packet. 

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  extract ethernet.type;
  
  // Using a field access expression 
  // with logical operator >=
  if (ethernet.type >= 0x600)
  {
    // Then this field determines what
    // header comes next.
  }
  // Using a field access expression 
  // with logical operator <=
  else if (ethernet.type <= 0x05dc)
  {
    // Then this field describes the
    // length of the entire packet.
  }
  // ...
}
\end{lstlisting}
\caption{An example of accessing a field using the field access expression in an if-else statement.}
\label{fg:access_ex}
\end{figure}

Field access expressions can also be used in arithmetic operations, bitwise operations, and can be stored and assigned to local variables. Figure \ref{fg:assign_arith_ex} demonstrates how this can be done using an IPv4 decoder as an example.

\begin{figure}[ht]
\begin{lstlisting}
decoder ipv4_decode(ipv4)
{
  extract ipv4.len;
  extract ipv4.version_ihl;
  extract ipv4.ttl;
  
  // We can assign to variables
  var pktlen : uint = ipv4.len;
  
  // We can perform bitwise operations.
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  // We can also perform shifts.
  var version : uint(8) = ipv4.version_ihl >> 4;
  
  // Determine what the Time-to-Live is after this
  // device finishes with the packet.
  var next_ttl : uint = ipv4.ttl - 1;
  
  // ...
}
\end{lstlisting}
\caption{Using arithmetic operations, bitwise operations, and variable assignment with fields in a Steve program.}
\label{fg:assign_arith_ex}
\end{figure}

First we assign \texttt{ipv4.len} field to a local variable named \texttt{pktlen}. We attempt to recover the \texttt{ihl} value by using bitwise-and to mask the first 4 bits (to deal with the limitation of supporting only byte aligned fields). After that we recover the version field by performing a right shift operation by 4 bits. In case we wanted to know the time-to-live value after the packet leaves this device, we perform subtraction on the \texttt{ipv4.ttl} field.

Field access expressions do have a number of limitations. A field access expression can only be used \textit{after} an extract declaration is used for that field. After all, it is impossible to recover the value of a field which has not been extracted. They cannot be used in decoders which have not extracted that field. A decoder focuses on exactly one header and has no knowledge of previous headers or extractions. Field access expressions cannot be assigned to like a variable identifier. To modify the value of a field in a header, an action must be used (see Section \ref{action_tut}). Figure \ref{fg:bad_access_ex} shows incorrect usage of field access expressions.

\begin{figure}[ht]
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  // Error: Cannot use eth.type before its extracted.
  if (ethernet.type >= 0x600) 
  {
    // Do something...
  }
  
  extract eth.type;
  
  // Now that its been extracted ...
  // Error: Cannot assign to a field this way.
  ethernet.type = 0x800;
  // ...
}

decoder ipv4_decode(ipv4)
{
  // Error: eth.type was not extracted by this decoder.
  if (ethernet.type == 0x800)
  // ...
}
\end{lstlisting}
\caption{An example of incorrect field access.}
\label{fg:bad_access_ex}
\end{figure}

\subsection{Moving to Other Stages} \label{decoder_next_tut}

As mentioned earlier, decoding and table matching stages can be chained together in a number of flexible ways. A decoder can transition a packet to another decoder, it can transition to a table matching stage, or it can forward/drop the packet. Its up to the programmer to decide which is appropriate. Every stage in the pipeline is \textbf{required} to do one of these three.

To transition to another decoding stage, a \texttt{decode} action is used. To transition to a table matching stage, a \texttt{goto} action (not to be confused with a C-like \texttt{goto}) is used. 

Figure \ref{fg:transition_ex} demonstrates how to move from a decoder to a decoder, from a decoder to a table, then from a table to another decoder. We present two decoders and one table. The \texttt{eth\_decode} decoder transitions to \texttt{ipv4\_decode} if the \texttt{ethernet.type} field is equal to \texttt{0x800}. The line \texttt{decode ipv4\_decode} causes the transition of the packet that decoding stage.

\begin{figure}
\begin{lstlisting}
decoder start eth_decode(ethernet)
{
  extract ethernet.type;
  if (ethernet.type >= 0x600) 
  {
  	// Check to see if the next header is ipv4.
    match (ethernet.type)
    {
      case 0x800: decode ipv4_decode;
    }
  }
  
  // Do something else...
}

decoder ipv4_decode(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.dst;
  extract ipv4.protocol;
  
  var ihl : uint(8) = ipv4.version_ihl & 0x0f;
  
  goto t1 advance ihl;
}

exact_table t1(ipv4.protocol)
{
  {0x11} ->
  {
    // Assuming a udp decoder exists named "udp_decode"
    decode udp_decode;
  }
  
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of using \texttt{decode} and \texttt{goto} to transition between stages.}
\label{fg:transition_ex}
\end{figure}

When we decode headers from packets, there is a concept of a \textit{current view} of the packet. The \textit{current view} begins at the byte offset in the packet where the current header starts and ends where the header ends. Imagine it like a window which the decoder uses to "look" in on the current header. Remember that decoders use layouts to determine the location of fields by calculating their offset from the beginning of their respective header. By extension, the location of a field is its offset from the beginning of the \textit{current view}. 

When a packet transitions away from a decoder towards another stage, the \textit{current view} of the packet must shift. Normally, the view is implicitly shifted by the length of the header. The user does not have to quantify how far the view must shift. However, in cases where a header's length is dynamic and predicated on some value, the user must quantify exactly how far the view must shift. To do this, an \textit{optional} \texttt{advance} clause can be attached to both \texttt{decode} and \texttt{goto} actions. Further details about how this view and shifting process work can be found in Chapter \ref{users_guide} Section \ref{decoder_guide}.

In this case, the \texttt{ipv4\_decode} decoder transitions to table \texttt{t1} using a \texttt{goto} action. Remember that real IPv4 headers can have a dynamic length \texttt{options} field even if we cannot extract it in Steve yet. The length of an IPv4 header (in bytes) is the value of its \texttt{ihl} field times 4. When we transition, we must quantify the length of this header with the \texttt{advance} clause which explicitly shifts the view by the given amount.

Then from table \texttt{t1}, if the \texttt{ipv4.protocol} field is equal \texttt{0x11}, the packet is transitioned to a hypothetical UDP decoder.

\section{Tables} \label{table_tut}

The next stage to explore is the table matching stage. Remember that a table specifies a \textbf{key} and is comprised of a set of \textbf{flow entries}. Each flow entry specifies a priority, values for its \textbf{match fields}, and a set of \textbf{actions} to perform against matching packets. All flow entries in the table must be uniquely identifiable from its match fields and priority.

Figure \ref{fg:table_syntax} provides the syntax for writing tables and flow entries in Steve. Tables are written using \textbf{table declarations} and flow entries are written using \textbf{flow declarations}.

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}
<table-decl> ::=
\textbf{exact\_table} <table-name> \textbf{(} <key-decl-sequence> \textbf{)} 
[ <requires-clause> ]
\textbf{\{} 
<flow-decl> + 
\textbf{\}}

<key-decl> ::=
<layout-id> \textbf{.} <field-id>
\alt <key-decl> \textbf{.} <field-id>
\alt \textbf{in\_port}
\alt \textbf{in\_phys\_port}

<requires-clause> ::=
\textbf{requires} \textbf{(} <field-name-sequence> \textbf{)}

<flow-decl> ::=
<properties-block>
\textbf{\{} [<expr-sequence>] \textbf{\}} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\alt <miss-flow-decl>

<properties-block> ::=
\textbf{[} <property-sequence> \textbf{]}

<property> ::=
<property-kind> \textbf{=} <expr>

<property-kind> ::=
\textbf{timeout}
\alt \textbf{egress}

<miss-flow-decl> ::=
\textbf{miss} \textbf{-\textgreater}
\textbf{\{} 
<action> +
\textbf{\}}
\end{grammar}
\end{mdframed}
\caption{Table syntax for Steve in BNF.}
\label{fg:table_syntax}
\end{figure}

There are three commonly used types of flow tables: \textbf{exact}, \textbf{prefix}, and \textbf{wildcard} matching tables. Steve currently only supports the exact match table. 

With an exact match table, each field in the packet must \textit{exactly} match a flow entry's match fields. By default, the priority of all flow entries in an exact match table are the same. The exception is the miss case which always has a priority lower than every other flow entry.

Consider that the objective of tables is to classify packets based on their fields and perform the same actions on like-classified packets. Assume we have one such problem. We want to decode the data portion following the IPv4 header. The data following an IPv4 header is determined by the value \texttt{ipv4.protocol} field. All packets whose \texttt{ipv4.protocol} field equal \texttt{0x01} get sent to the ICMP decoder. All packets whose \texttt{ipv4.protocol} field equal \texttt{0x06} get sent to the TCP decoder, and so on.

Now we also add the additional restriction that we only want to deal with non-fragmented packets. Whether or not an IPv4 packet is fragmented can be determined by checking the \texttt{ipv4.fragment} field. To solve this problem, we can use table \texttt{ip\_data\_table} presented in Figure \ref{fg:ip_table_ex}.

\begin{figure}
\begin{lstlisting}
// A table declaration declares which fields comprise its
// key. In this case, we have ipv4.fragment and ipv4.protocol.
exact_table ip_data_table(ipv4.fragment, ipv4.protocol)
	requires (ipv4.ttl)
{
  // NOTE: The fragment field is typically 0 when a packet
  // is not fragmented.
  
  // Flow entry #1 
  // Here we declare a flow entry. The first part of the
  // entry specifies the values for the "Match Fields".
  // Here we have 0x0 for the ipv4.fragment match field
  // and 0x01 (ICMP) for the ipv4.protocol field.
  { 0x0, 0x01 } ->
  {
    // Using the Set action to decrement the ttl.
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode icmp_decode advance ipv4.version_ihl & 0x0f;
  } 
  
  // Flow entry #2
  // The protocol field is 0x06 for TCP data.
  [timeout = 1000]
  { 0x0, 0x06 } ->
  {
  	set ipv4.ttl = ipv4.ttl - 1;
  	// Dispatch to the TCP Decoder.
  	decode tcp_decode advance ipv4.version_ihl & 0x0f;
  } 
    
  // And so on...
  
  // Miss Case
  miss -> { drop; }
}
\end{lstlisting}
\caption{An example of a simple table used to classify IPv4 packets.}
\label{fg:ip_table_ex}
\end{figure}

To write a complete exact match table, the programmer must specify 1) what fields comprise the key, 2) what additional fields need to be extracted by a decoder before reaching the table, and 3) a set of flow entries. 

The table \texttt{ip\_data\_table} declares that its keys are the \texttt{ipv4.fragment} and \texttt{ipv4.protocol} fields. It is thus limited to classifying packets based on these fields. Additionally, it specifiesthat \texttt{ipv4.ttl} also be extracted using the \texttt{\color{blue}requires} clause. This table is declared with three initial flow entries (two normal entries and one miss case).

A flow entry must specify 1) the values of its match fields, 2) the actions to be applied to the packet.

The first flow declaration declares a flow entry whose \texttt{ipv4.fragment} match field is equal to \texttt{0x0} and whose \texttt{ipv4.protocol} match field is equal to \texttt{0x01}. The second flow entry similarly has an \texttt{ipv4.fragment} match field equal to \texttt{0x0} and an \texttt{ipv4.protocol} match field equal to \texttt{0x06}.In both cases, we use the \texttt{set} action (described in Section \ref{set_action_tut}) to decrement the \textbf{ipv4.ttl} field. We then dispatch to the appropriate decoder using the \texttt{decode} action.

In the second flow entry we have a special case where we set the timeout \textbf{property} of the flow entry to \texttt{1000}. Properties are additional information attached to flow entries. Flow entries currently support two properties. The first is \texttt{timeout}. A flow entry is removed from a table after a \texttt{timeout} number of milliseconds. The other is the \texttt{egress} port property which allows flows to use the \texttt{\color{blue}output \color{green}egress} action described in Section \ref{output_action_tut}.

\textit{So what makes using a table different from decision structures like an if-else or match statements?} As one may have noticed, the table example given in Figure \ref{fg:ip_table_ex} could just as easily be written using a combination of if-else and match statements like we used with the ethernet decoder earlier in Figure \ref{fg:transition_ex}. 

First of all, a table can match on one or more fields at once. The table can also match on a packet's \texttt{in\_port} and \texttt{in\_phys\_port} fields (described in Section \ref{output_action_tut}). The more fields required in the decision making process, the more complex using nested decision structures gets. Tables, on the other hand, are easier to write in this case.

Second, a table can match on and use fields from different headers. Unlike decoders, tables have a wider perspective on packets. For example, the following is a perfectly valid table. 

\begin{lstlisting}
exact_table t1(ethernet.dst, ipv4.dst)
{
  // ...
}
\end{lstlisting}

Tables and their contained flow entries have access to every field that has been extracted before them using \textbf{field access expressions}. The only limitation is that field access can only occur on fields which the table either matches on or requires explicitly.

Lastly, flow entries can be added and removed from tables using the appropriate actions. This allows decision making on packets to change dynamically during runtime. It is obviously impossible to add new branches to if-else and match statements. The ability to add, or \textbf{learn}, new entries allows us to write applications which can learn, such as learning switches and routers.

\section{Actions} \label{action_tut}

Actions change packets, action sets, and pipeline state. Steve supports eleven actions with more anticipated in the future. Actions can be used in both decoders and flows in Steve. The syntax for supported actions can be found in Figure \ref{fg:action_syntax}.

\begin{figure}
\begin{mdframed}
\begin{grammar}
<port-decl> ::=
\textbf{Port} <port-name> \textbf{;}
\alt \textbf{Port} <port-name> \textbf{=} <string-literal> \textbf{;}

<action-stmt> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <drop-action>
\alt <flood-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>

<decode-action> ::=
\textbf{decode} <decoder-decl-id> \textbf{;}

<goto-action> ::=
\textbf{goto} <table-decl-id> \textbf{;}

<output-action> ::=
\textbf{output} <port-expr> \textbf{;}

<drop-action> ::= \textbf{drop;}

<flood-action> ::= \textbf{flood;}

<clear-action> ::= \textbf{clear;}

<set-field-action> ::= \textbf{set} <field-access-expr> \textbf{=} <expr> \textbf{;}

<insert-flow-action> ::= \textbf{insert} <flow-decl> \textbf{into} <table-id> \textbf{;}

<remove-flow-action> ::= \textbf{remove} \textbf{\{} [ <expr> + ] \textbf{\}}
\textbf{from} <table-id> \textbf{;}

<raise-action> ::= \textbf{raise} <event-id> \textbf{;}

<write-action> ::= \textbf{write} <action-stmt>

\end{grammar}
\end{mdframed}
\caption{Action syntax for Steve in BNF.}
\label{fg:action_syntax}
\end{figure}

\subsection{Decode Action} \label{decode_action_tut}

The \texttt{decode} action is used to move a packet from the current stage to a decoding stage. Assume we want to move to an IPv4 decoder named \texttt{ipv4\_decode}, the action would be written as:

\begin{lstlisting}
decode ipv4_decode;
\end{lstlisting}

Remember that there is also an optional \texttt{advance} clause which can occur if the "view" of the packet must be explicitly shifted by some special number of bytes. For example, if the current decoder is for IPv4, and the next decoder is named \texttt{udp\_decode}, the action would be written as:

\begin{lstlisting}
decode udp_decode advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Goto Action} \label{goto_action_tut}

The \texttt{goto} action is used to move a packet from the current stage to a table matching stage. Assume we want to move to a table named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1;
\end{lstlisting}

Similar to the \texttt{decode} action, the \texttt{goto} action also supports an optional advance clause. For example, if the current decoder is for IPv4, and the table the programmer wants to dispatch to is named \texttt{t1}, the action would be written as:

\begin{lstlisting}
goto t1 advance (ipv4.version_ihl & 0x0f) * 4
\end{lstlisting}

\subsection{Ports and the Output Action} \label{output_action_tut}

Ports are an important part of the system. Ports are where packets enter (ingress) and leave (egress) the system. Ports are all given a unique integer identifier by the system.

Steve supports a number of \textbf{reserved} ports which are required to exist on every system Steve applications runs on. These are compliant with OpenFlow port specifications \cite{openflow_spec}.

The \texttt{all} port represents every port on the system that can be forwarded to. This port can only be used for output.

The \texttt{controller} port represents the communication channel between a device and a set of application controllers. A packet might enter from this port or be output through this port.

The \texttt{reflow} port represents the beginning of the pipeline. Packets sent to this port are sent through the pipeline again for re-processing. This is equivalent to the \textbf{TABLE} port in OpenFlow. This port is only valid for output.

To output a packet to a port we can use the \texttt{output} action as follows.

\begin{lstlisting}
// Outputs to all ports on the system.
output all; 

// Outputs to the controller.
output controller; 

// Sends the packet back to the beginning of the pipeline.
output reflow; 
\end{lstlisting}

In addition to the reserved ports, there are a number of keywords in Steve which can be used to access certain ports.

The \texttt{in\_port} port refers to the packet's ingress port. The \texttt{in\_phys\_port} port refers the packets physical ingress port. To output to these port, we write the following.

\begin{lstlisting}
output in_port;

output in_phys_port;
\end{lstlisting}

Flow entries can have an (optional) \texttt{egress} port property which can be set. When executing a flow, if this property has been set, the packet can be output to this \texttt{egress} port using:

\begin{lstlisting}
output egress;
\end{lstlisting}

Steve also provides the limited ability to user-declare ports with certain capabilities. These ports are only valid if the system has a port with the given capabilities, otherwise they produce runtime errors when the system loads the Steve application.

A port bound to logical port \texttt{5000} on a system would be written as follows.

\begin{lstlisting}
Port p1 = ":5000";

// To output to p1...
output p1;
\end{lstlisting}

User-declared ports with no configuration information, like the following, refer to an invalid port whose identifier is always 0. 

\begin{lstlisting}
Port p1;
\end{lstlisting}

These ports can be assigned to later with a valid port. Outputting to invalid ports results in the packet being dropped.

\begin{lstlisting}
p1 = in_port;
output p1;
\end{lstlisting}

\subsection{Drop Action} \label{drop_action_tut}

A packet can be dropped by the Steve application using the \texttt{drop} action. No further processing can be done on a dropped packet.

\begin{lstlisting}
drop;
\end{lstlisting}

\subsection{Flood Action} \label{flood_action_tut}

A packet can be flooded to all ports except the packet's ingress port using the \texttt{flood} action.

\begin{lstlisting}
flood;
\end{lstlisting}

\subsection{Set Action} \label{set_action_tut}

A \texttt{set} action can be used to write to any extracted field within a packet. The \texttt{set} action is only valid if the field given by the field access expression is valid in that stage.

\begin{lstlisting}
set ipv4.ttl = ipv4.ttl - 1;
\end{lstlisting}

\subsection{Insert Flow Action} \label{insert_flow_action_tut}

Inserting flow entries into a table is a Steve action not explicitly supported by the OpenFlow standard \cite{openflow_spec} though it is supported in software switches like OVS \cite{ovs_man_page}. Flow entries can be inserted with constant key values and no properties. 

\begin{lstlisting}
// Constant key values.
insert
{ 0x0, 0x89 } ->
{
  set ipv4.ttl = ipv4.ttl - 1;
  decode mpls_decode;
} 
into ip_data_table;
\end{lstlisting}

They can also be inserted with field values of the current packet and with optional properties.

\begin{lstlisting}
// Dynamic key values
insert
[timeout = 1000, egress = in_port]
{ ipv4.fragment, ipv4.protocol } ->
{
  output egress;
} 
into ip_data_table;
\end{lstlisting}

In this case, the flow entry uses the \texttt{ipv4.src} and \texttt{ipv4.dst} fields of current packet as values for the inserted flow entry's key. It also sets the timeout to 1000 and sets the \texttt{egress} property to the current packet's \texttt{in\_port}, making the \texttt{output egress} action valid.

\subsection{Remove Flow Action} \label{remove_flow_action_tut}

A flow entry can be removed from a table by providing match field values and the name of the table to remove the flow entry from. This can be done with constant values or dynamic field values of the current packet.

\begin{lstlisting}
// Removal with constant values.
remove { 0x0, 0x01 } from ip_data_table;

// Or dynamic values.
remove {ipv4.dst, ipv4.protocol } from ip_data_table;
\end{lstlisting}

\subsection{Write Action} \label{write_action_tut}

The context data structure keeps an \textbf{action set}. This action set is a set of actions which are written to the context using the \texttt{write} action. All actions in this section except the \texttt{raise}, \texttt{insert}, and \texttt{remove} action can be written to an action set. The execution of these written actions is deferred until egress processing.

\begin{lstlisting}
// Writing a set action
write set ipv4.ttl = ipv4.ttl - 1;
// Writing an output action.
write output reflow;
// Writing a drop action.
write drop;
// etc...
\end{lstlisting}

\subsection{Clear Action} \label{clear_action_tut}

The clear action removes all actions from the context's action set.

\begin{lstlisting}
clear;
\end{lstlisting}

\subsection{Raise Action} \label{raise_action_tut}

A \texttt{raise} action is used to trigger an \textbf{event}. Events are Steve's lightweight way of supporting asynchronous execution during pipeline processing. Section \ref{event_tut} demonstrates how to write events. To trigger an event, you use a \texttt{raise} action and give an event identifier as follows.

\begin{lstlisting}
// Assuming we have an event named "learn"
raise learn;
\end{lstlisting}

\section{Events} \label{event_tut}

Steve supports \textbf{events} which are lightweight asynchronous pipeline processing stages. These stages are special because their processing occurs outside of the run-to-completion model that tables and decoders have. 

\begin{figure}[ht]
\begin{mdframed}
\begin{grammar}

<event-decl> ::=
\textbf{event} <event-name> <requires-clause> 
<block-statement>

\end{grammar}
\end{mdframed}
\caption{Event syntax for Steve in BNF.}
\label{fg:event_syntax}
\end{figure}

Each \textbf{event declaration} in Steve declares an \textbf{event handler} which (optionally) declares which fields must be extracted before that event can be raised. When a user raises an event using the \texttt{raise} action, they trigger the execution of the event handler in a separate event thread.

Events are most useful when performing slower actions, namely \texttt{insert} and \texttt{remove}. Inserting flow entries and removing flow entries from a table can be a bottleneck for execution. Events allow these bottleneck actions to be performed when convenient while the packet continues through the run-to-completion model.

In Figure \ref{fg:event_ex}, we declare an event named \texttt{learn\_mac} which inserts flow entries into a table named \texttt{learn} and a table named \texttt{switch}. To raise this event, we would use the action \texttt{\color{blue}raise} \texttt{learn\_mac}. 

\begin{figure}[ht]
\begin{lstlisting}
event learn_mac
	requires(ethernet.src)
{
	insert
	{ ethernet.src } ->
	{
		goto switch;
	}
	into learn;


	insert
	[timeout = 1000, egress = in_port]
	{ eth.src } ->
	{
		output egress;
	}
	into switch;
}
\end{lstlisting}
\caption{An example of an event used to learn which ports are receiving packets from which MAC addresses.}
\label{fg:event_ex}
\end{figure}

An important thing to know when using events is that a \textbf{copy} of the packet and context are sent to the event handler. Any changes made to a packet using an action in the event handler does not modify the original packet or its context. The original packet continues moving through the pipeline after a \texttt{raise} occurs and does not wait for the event handler to execute.

Another thing to note is that this usage of events to learn flow entries is distinct from OpenFlow semantics. Normally packets are sent to the \texttt{controller} port which connects to an application called the \textbf{controller}. The controller then asynchronously processes packets and potentially adds the flow entries.

The advantage here is that Steve events are written as part of the Steve application and are thus subject to the same semantic, logical, and safety guarantees applied to other pipeline stages. 

\section{Examples} \label{examples_tut}

As promised at the beginning of this tutorial, we would demonstrate how to write three basic network applications: a learning switch, a learning router, and a wire using language features taught during this tutorial.

\subsection{The Learning Switch} \label{learning_switch}

Let's begin by writing the Layer 2 (ethernet) learning switch. The learning switch shall receive packets. With each packet, the switch will "learn" which MAC addresses are found on which ports by checking the \texttt{src} field of ethernet headers. The switch forwards packets by looking at the \texttt{dst} field and checking if it has learned that MAC address yet. If it has not learned the address, it floods the packet.

Here we need to extract the ethernet header's \texttt{src}, and \texttt{dst} fields. No other headers are necessary. It will not be necessary to extract \texttt{eth.type} or proceed to another decoder. First, we declare the layout needed to decode. We can use the ethernet layout given earlier in Figure \ref{fg:eth_layout_ex}. Next we produce the ethernet decoder which proceeds directly to the \texttt{learn} table after extracting \texttt{ethernet.src} and \texttt{ethernet.dst} fields.

\begin{lstlisting}
decoder eth_d(ethernet)
{
  extract ethernet.dst;
  extract ethernet.src;
  
  goto learn;
}
\end{lstlisting}

From here, we will need two tables: a learning table and a forwarding table. The learning table is responsible for learning MAC addresses and installing learned addresses into the forwarding table. The learning table matches on the \texttt{ethernet.src} field and ensures that the same MAC address is not learned multiple times. To learn the needed flow entries, the \texttt{learn} table raises an event called \texttt{learn\_mac} which will insert these flow entries for us.

\begin{lstlisting}
exact_table learn(ethernet.src)
{
  miss ->
  {
  	// We raise an event to learn the appropriate flow entries.
  	raise learn_mac;
    goto switch;
  }
}
\end{lstlisting}

The forwarding table ultimately forwards the packet to the correct port based on its destination MAC address. The forwarding table thus matches on the \texttt{ethernet.dst} field. Any un-learned destinations get flooded by the miss case.

\begin{lstlisting}
exact_table forward(ethernet.dst)
{
  // Flood any packet which hasn't been learned yet.
  miss -> { flood; }
}
\end{lstlisting}

Note that no initial flow entries other than miss cases are declared with either table. The tables have not learned anything yet. The first packet matched against these tables thus have the miss case applied by default.

So how do we write the \texttt{learn\_mac} event? Recall that we need the \texttt{insert} action to make tables "learn" flow entries. Additionally, this event will require that \texttt{ethernet.src} have been extracted. First we must insert a flow entry into the \texttt{learn} table with the \texttt{ethernet.src} field value of the current packet being learned. This prevents packets with the same \texttt{ethernet.src} field from triggering the \texttt{learn\_mac} event more than once. 

Next, we insert the appropriate flow entry into the \texttt{forward} table. Here, we insert a flow entry whose \texttt{ethernet.dst} field is equal to the current packet's \texttt{ethernet.src} field. Since the \texttt{forward} table matches on \texttt{ethernet.dst} what we are doing is saying any packet whose \texttt{ethernet.dst} is equal to the \textit{current} packet's \texttt{ethernet.src} is forwarded to the \texttt{current} packet's ingress (\texttt{in\_port}) port.

\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}
event learn_mac
	requires(ethernet.src)
{
	// First we insert the src of the packet
	// into the learn table so we don't keep
	// trying to learn something we already have.
	insert
	{ ethernet.src } -> { goto forward; }
	into learn;
	
	// Next we insert the src of the
	// current packet into the forward table.
	//
	// The forward table matches on the dst
	// field of a packet, so what we are doing is
	// saying any packet whose dst is equal to this
	// packet's src is forwarded to this packet's
	// ingress (in_port) port.
	insert
	[timeout = 1000, egress = in_port]
	{ ethernet.src } ->
	{
		// We set the egress property to the current
		// packet's in_port, so when we output egress
		// we send to the current packet's in_port.
		output egress;
	}
	into forward;
}
\end{lstlisting}
\end{minipage}

\subsection{The Learning Router} \label{learning_router}

The learning router is not too different from the learning switch. Instead of learning and forwarding from MAC addresses, this application will learn and forward from IPv4 addresses.

We will need two layouts here: the ethernet layout and the IPv4 layout. Here we can use the ethernet layout given in Figure \ref{fg:eth_layout_ex} and the IPv4 layout given in Figure \ref{fg:ipv4_layout_ex}. We will need to extract the \texttt{ethernet.type} field in order to confirm the ethernet header encapsulates IPv4. Our ethernet decoder will look like the following.
\begin{lstlisting}
decoder eth_d(ethernet)
{
  extract ethernet.type
  match(ethernet.type) {
  	case 0x800: decode ipv4_d;
  }
  drop; // Drop if its not an IPv4 packet.
}
\end{lstlisting}

The IPv4 decoder will need to extract \texttt{ipv4.src} and \texttt{ipv4.dst} in order to learn them. Additionally, we'll need \texttt{ipv4.version\_ihl} to correctly advance past the IPv4 header and \texttt{ipv4.ttl} to decrement.

\begin{lstlisting}
decoder ipv4_d(ipv4)
{
  extract ipv4.version_ihl;
  extract ipv4.src;
  extract ipv4.dst;
  extract ipv4.ttl;
  goto learn advance (version_ihl & 0x0f);
}
\end{lstlisting}

We will need two tables just like in the learning switch example. Here the \texttt{learn} table matches on \texttt{ipv4.src}. It will be responsible for learning IP addresses and inserting them into the \texttt{routing} table.

\begin{lstlisting}
exact_table learn(ipv4.src)
{
  miss ->
  {
	raise learn_ip;
    goto route;
  }
}
\end{lstlisting}

The \texttt{routing} table matches on \texttt{ipv4.dst}. It will route all packets whose destination IP address it has learned. Any IP addresses not yet learned are flooded by default.

\begin{lstlisting}
exact_table forward(ipv4.dst)
{
  miss -> { flood; }
}
\end{lstlisting}

Lastly we need to define the \texttt{learn\_ip} event which is, once again, largely the same as the \texttt{learn\_mac} event from the learning switch.

\begin{lstlisting}
event learn_ip
	requires(ipv4.src)
{
	insert
	{ ipv4.src } -> { goto route; }
	into learn;

	insert
	[timeout = 1000, egress = in_port]
	{ ipv4.src } -> { output egress; }
	into route;
}
\end{lstlisting}

\subsection{The Wire} \label{wire}

A wire is a network application which has two ports. It receives from one port and outputs out of the other port. The only caveat is that the application is not aware of the ports comprising the wire at first. It must learn that those ports exist.

This example demonstrates a number of more unintuitive features of Steve. First we declare two uninitialized ports named \texttt{p1} and \texttt{p2}. Uninitialized ports have a port identifier of 0 and are invalid.

\begin{lstlisting}
Port p1;
Port p2;
\end{lstlisting}

Next we'll use the ethernet layout from prior examples and write a decoder. The only caveat as we do not need any of the fields. We only care about the \texttt{in\_port} of the packet.

\begin{lstlisting}
decoder start eth_d(ethernet)
{
  goto learn;
}
\end{lstlisting}

To enable our wire application to learn about ports, we once again need two tables and an event which adds flow entries to those tables. First we declare our \texttt{learn} and \texttt{forward} tables. Here we show that \texttt{in\_port} is a valid matching field.

\begin{lstlisting}
exact_table learn(in_port)
{
  miss -> 
  {
  	raise learn_port;
    goto forward;
  }
}

exact_table forward(in_port)
{
  miss -> { drop; }
}
\end{lstlisting}

Then we must declare our \texttt{learn\_port} event. This event demonstrates that ports can be compared with comparisong and equality expressions, which implicitly compare the integer identifiers assigned to those ports. We also show that port declarations can be assigned to (\texttt{p1 = in\_port}) as long as what is being assigned is also a port.

Once both ports are valid, the application installs the appropriate flow entries and the wire will function appropriately.

\noindent\begin{minipage}{\linewidth}
\begin{lstlisting}
event learn_port
{
  // Prevent the same port from being learned twice.
  insert
  { in_port } -> { goto forward; }
  into learn;

  // If neither p1 nor p2 is set, then we assume this packet 
  // is coming off p1.
  // Note: The assumption is that port 0 is an 
  // invalid port since valid port IDs begin at 1.
  if (p1 == 0 && p2 == 0)
    p1 = in_port;
  // If p1 is learned and this packet is not from p1, 
  // then this is from p2. At this point we would have 
  // both ports learned so we can add the flow entries.
  else if (p1 > 0 && p1 != in_port)
  {
    p2 = in_port;
    insert
    { p1 } -> { output p2; }
    into forward;

    insert
    { p2 } -> { output p1; }
    into forward;
  }
}
\end{lstlisting}
\end{minipage}