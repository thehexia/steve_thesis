\chapter{RELATED WORKS} \label{ch:related}

\section{Freeflow} \label{rel:freeflow}

Freeflow is a highly programmable, protocol oblivious data plane being developed
by Flowgrammable \footnote{https://github.com/flowgrammable/freeflow/}. Steve is
designed to program the Freeflow data plane and generates code targeting its
Flowpath runtime environment. Freeflow adopts a component model similar to an OpenFlow switch. A basic OpenFlow switch
has three major components: a packet processing pipeline, ports, and a channel
to an external controller application \cite{openflow_spec}. A Freeflow data
plane loads Steve applications which control the logic behind the packet
processing pipeline.

\section{OpenFlow} \label{rel:openflow}

An OpenFlow pipeline is defined as a sequence
of one or more \textit{flow tables} and a \textit{group table} which handle
packet lookups, decision making, and forwarding \cite{openflow_spec}. Steve's packet processing pipeline differs from the traditional OpenFlow
semantics in a number of ways. First,
Steve provides language features for a user to create flow tables and define
their flow entries, but does not yet support group tables. 

Second, a Steve pipeline has more than \textit{just} flow tables. Steve
pipelines will also have \textit{decoders} which may be interleaved between
tables. Decoders define how fields get decoded (or parsed) and extracted. In
most switches, decoding is handled by specialized hardware that deal with
well-known headers. OpenFlow only supports certain fields from these headers,
known as OXM fields \cite{openflow_spec}. However, the Freeflow data plane is
protocol oblivious, knowing nothing about any specific headers; therefore
decoding must be an explicit user-defined stage of the pipeline. By extension,
Steve does not, by default, support these OXM fields either.

Third, the semantics for packet handling using an external controller are different. An OpenFlow controller is software used to control an OpenFlow switch \cite{openflow_spec}. It will handle "exceptional events" such as inserting,
removing, and updating flow entries or processing packets which the pipeline
could not. However, Steve and Freeflow do not use nor expect an external
OpenFlow controller nor do they use OpenFlow messages to communicate with that
controller. 

Steve and Freeflow attempt to reduce the role of the controller. Controller
functions, which would typically handle exceptional cases (such as table
manipulation and un-handled packets), can be written in Steve using special
"event" handlers functions. These event handlers are executed by the data plane
on a special internal Freeflow "controller" thread rather than relying on an
external controller. 

\section{SDN Data Plane Configuration Languages} \label{rel:p4}

Steve is a language for modifying the packet processing and forwarding functionality of a data plane. Steve is \textit{protocol oblivious}, meaning it does not by default
know of any well-known network protocols (IPv4, IPv6, TCP, etc). Instead, it
provides language features for programmers to deal with any protocol, making the
language more scalable for future protocols. Other SDN languages are pursuing
these idea as well.

The P4 language \cite{p4_spec, p4_spec2} is another high-level language for
defining protocol oblivious packet processing pipelines. It is probably the
most widely adopted SDN language. P4 allows users to define packet headers,
packet parsers and
match+action tables (which are equivalent to OpenFlow flow tables). Parsers are
used to extract entire headers and store them in a "parsed representation"
before entering pipeline processing. When the packet enters the pipeline,
match+action tables match against fields in the parsed representation and
perform actions on matched packets. 

Protocol-Oblivious Forwarding (POF) \cite{pof_fis, pof, pof_impl} is another
project also tackling the problem of protocol oblivious pipeline processing. POF
is a very low-level, assembly-like, instruction set. The POF instruction
set gives the programmer very fine-grained control of which fields get parsed.
The POF programming model uses metadata as a "scratch pad" for parsing fields,
requiring that the
programmer represent fields as generic \{offset, length\} pairs, known as
"search keys" \cite{pof}. When performing table matching, a programmer specifies
an array of these search keys to match against the flow table \cite{pof_impl}.
Essentially, fields only get extracted as they are needed, right before matching
against a given table.

POF also supports additional actions that allow the data plane to manipulate
flow tables \cite{pof}. This includes adding, removing, and updating flow
entries. Though these actions are traditionally left up to the controller, they
are useful because they reduce the load on the controller and provide
flexibility to the data plane. This feature is notably absent from other SDN
languages.

The POF instruction set is difficult to write in and does not have the safety
guarantees of a higher level language. The programmer is burdened with the
error-prone task of parsing by manually specifying which bits comprise a fields. 
A high level language compiling into POF instructions would thus be ideal.

Steve tries to take the best of both worlds. Steve can define decoding functions
similar to P4 parsers, with the added benefit of allowing the programmer to only
extract the fields they need, reducing the amount of time needed to parse
overall. The \{offset, length\} pairs describing each field get generated by the
Steve compiler rather than being manually written by the programmer, thus
reducing
the risk for error. Steve decoders may also be interleaved between tables,
meaning fields can be extracted, as needed, right before table matching like
POF. Like P4,
Steve decoding can also happen all at once "up-front," before any table
matching. 
It is up to the programmer to decide which is better. This makes Steve
decoders a little more robust than either P4 or POF. 

Steve supports high-level definition of flow tables (or match+action tables in
P4). Additionally, Steve also allows the programmer to define flow entries. This
means the match field values and actions for each flow entry can be expressed
within the language, allowing the Steve compiler to ensure safety and
correctness guarantees over them. For example, adding a flow entry that causes
an infinite loop is always prevented. This task is normally left up to the
controller during runtime, which can be slow. Steve also supports instructions
for adding and removing these flow entries from tables like POF.

Unlike P4 and POF, Steve is not \textit{just} an SDN specific language; it is an
extension to a general purpose language. It thus supports features like
functions, function calls, lexical scoping, loops, conditional statements, and
local/global variables. Steve also has support for types, arithmetic
expressions, and comparison expressions. On top of that, it automatically links
against the C Runtime Library, supports calls to external functions, and may be
statically or dynamically linked against any library.

Admittedly, P4 is a more mature language than Steve. P4 supports things like
meters, variable sized fields, table matching methods (Steve only supports exact
matching), and certain actions that Steve does not. P4 can also target more
platforms than Steve, which currently only compiles into modules for Freeflow.
POF also supports certain actions and table matching methods that Steve does not
currently support.

NetASM is an intermediate representation language for programmable data planes
\cite{shahbaz2015netasm}. It aims to solve the same issues as POF, but also provides a language that is target/device independent. The goal is for higher level languages to compile into NetASM which can then be compiled into platform-specific code by device-specific compilers.

\section{Other Languages} \label{rel:frenetic}

Other languages are protocol-dependent and are designed to program the control plane. The Frenetic project has produced a family of network programming
languages. The Frenetic language is a declarative language, embedded in Python,
that uses SQL-like queries to classify packets and a library for describing
packet forwarding policies over a collection of network switches
\cite{foster2011frenetic, foster2013frenetic}. This language is designed to
abstract away the difficulties of programming a centralized SDN controller. Its
sister project, Pyretic, does the same with some divergence in how forwarding
policies are expressed \cite{modularpyretic}. Both languages try to confirm the correctness of a program over an entire network.

NetCore is a network programming language for expressing forwarding policies and
generating classifiers from those policies \cite{monsanto2012netcore}. These
classifiers then get installed on switches. NetKAT is a language, inspired by
NetCore, for expressing packet processing functions and reasoning about a
network using Kleene Algebra \cite{kozen2014netkat, anderson2014netkat}. NetKAT
attempts to prove the correctness of its network programs through mathematical theory.
