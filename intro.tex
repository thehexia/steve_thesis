\chapter{INTRODUCTION} \label{ch:intro}

Steve is a domain-specific programming language tailored toward writing programs for \textbf{network packet processing} on \textbf{software-defined networking (SDN) devices}. 

\textbf{What is a packet?} A network packet is a formatted chunk of data used to send information across computer networks. Packets are comprised of headers and a payload. Headers contain instructions on where to send a packet across a network much like addresses on envelopes. When a network device (e.g. routers, switches, etc) receives a packet, it must decode these headers to determine where the packet must be sent next. Payloads are akin to the content of those envelopes. 

\textbf{What is SDN?} Software defined networking aims to make network devices more programmable. A typical networking device has two components: the data plane (sometimes called the forwarding plane) and the control plane. The data plane handles processing packets and forwarding them. The control plane manages and configures the data plane. The Open Network Foundation (ONF) defines SDN as "the physical separation of the network control plane from the forwarding plane, and where a control plane controls several devices," thus making the control plane more programmable \cite{onf_sdn_def}. The underlying hardware is abstracted making it easier to write software for. To standardize SDN programming, ONF released the OpenFlow specification which defines an interface for control planes to manage data planes \cite{openflow_spec}.

Making the control plane programmable is only the first step of SDN architectures. There are a number of projects focusing on making the data plane programmable as well. It allows the user to change the packet processing and forwarding functionality of a device \textit{without having to change the hardware}. What benefit does this have?

\textbf{Protocol oblivious processing.} By being able to program the packet processing functions, the data plane \textit{does not have to know about any standard protocols} (ethernet, IPv4, TCP, etc). Support for protocol headers is strictly left up to the programmer. This allows users to defined their own protocols in addition to supporting well-known protocols. There is no need to provide specific support for every possible header. Instead, the device provides a generic instruction set that can decode, extract, and process fields from arbitrary headers. This "future-proofs" the data plane.

\textbf{User-defined forwarding rules.} The forwarding rules can be freely manipulated. Because protocol independence is also achieved, these rules can handle any arbitrary header fields. 

\textbf{Arbitrary processing.} Operations performed on a packet do not have to be limited by actions defined by OpenFlow standard switches. They also do not have to be limited by well-known operations performed on well-known protocols. Programmable data plane instruction sets can generically manipulate bytes like a CISC or RISC.

\textbf{Why Steve?} Steve is a protocol oblivious language for specifying packet processing and forwarding functionality for a programmable data plane. It is high level and declarative, being not too different from C-like languages. This makes it familiar to almost all programmers.

Most importantly, Steve abstracts much of the low-level code a programmer would have to write. One could write in C or device-specific assembly, but this process forces the programmer to engage in low-level details such as resource acquisition, port interfaces, device configuration, hardware limitations, etc. Even worse, the user has to worry about manually decoding headers by specifying which bits make up a field. This can be an error-prone nightmare. This type of low-level programming is subject to undefined behavior, logical errors, program crashes, memory leakage, etc. This is unacceptable on important network devices,

Steve and its runtime system, Flowpath, abstract most of these details away from the programmer. Instead, the programmer only focuses on high level aspects such as which headers they are decoding, which fields they need, and what forwarding behavior they want. The language compiler takes care of the rest. It assuring certain safety and logical correctness guarantees through full-program analysis, type analysis, and semantic analysis of the Steve language.

Specifically, Steve provides the following features.

\begin{itemize}
\item The ability to define the layout of any arbitrary header.

\item The ability to specify a pipeline which handles packet processing and forwarding. This pipeline is composed of one or more decoders and flow tables.

\item The ability to define decoding stages, or decoders. Decoders allow programmers to find and extract fields from desired headers. They also provide the mechanics to reason about which packet header comes next based on conditions satisfied by the current packet header.

\item The ability to define flow tables. Flow tables provide a mechanism for making decisions about, or classifying, a packet based on decoded fields \cite{openflow_spec}. Flow tables contain rules known as flow entries which perform \textit{actions} on like-classified packets.

\item
Actions provide a way to modify a packet's fields, modify the state of a table, forward a packet, or drop a packet. They may also be used to move from decoders to flow

\end{itemize}

