\chapter{INTRODUCTION} \label{ch:intro}

Steve is a domain-specific programming language tailored toward writing programs for \textbf{network packet processing} on \textbf{software-defined networking (SDN) devices}. 

\textbf{What is a packet?} A network packet is a formatted chunk of data used to send information across computer networks. Packets are comprised of headers and a payload. Headers contain instructions on where to send a packet across a network much like addresses on envelopes. When a network device (e.g. routers, switches, etc) receives a packet, it must decode these headers to determine where the packet must be sent next. Payloads are akin to the content of those envelopes. 

\textbf{What is SDN?} Software defined networking aims to make network devices more programmable. A typical networking device has two components: the data plane (sometimes called the forwarding plane) and the control plane. The data plane handles processing packets and forwarding them. The control plane manages and configures the data plane. The Open Network Foundation (ONF) defines SDN as "the physical separation of the network control plane from the forwarding plane, and where a control plane controls several devices," thus making the control plane more programmable \cite{onf_sdn_def}. The underlying hardware is abstracted making it easier to write software for. To standardize SDN programming, ONF released the OpenFlow specification which defines an interface for control planes to manage data planes \cite{openflow_spec}.

Making the control plane programmable is only the first step of SDN architectures. There are a number of projects focusing on making the data plane programmable as well. It allows the user to change the packet processing and forwarding functionality of a device \textit{without having to change the hardware}. What benefit does this have?

\textbf{Protocol independence.} By being able to program the packet processing functions, the data plane \textit{does not have to know about any standard protocols} (ethernet, IPv4, TCP, etc). Support for protocols is strictly left up to the programmer. This allows users to defined their own protocols in addition to supporting well-known protocols. There is no need to update the device with new protocol specifications or to support every possible header. Instead, the device provides a generic instruction set that can process arbitrary protocols. This "future-proofs" the data plane.

\textbf{User-defined forwarding rules.} The forwarding rules can be freely manipulated. Because protocol independence is also achieved, these rules can handle any arbitrary header fields. 

\textbf{Arbitrary processing.} Operations performed on a packet do not have to be limited by actions defined by OpenFlow standard switches. They also do not have to be limited by well-known operations performed on well-known protocols. Programmable data plane instruction sets can generically manipulate bytes like a CISC or RISC.

\textbf{Why Steve?} Steve is a language for specifying packet processing and forwarding functionality for a programmable data plane.

Specifically, Steve provides the following features.

\begin{itemize}
\item The ability to specify a packet processing pipeline which is composed of decoding stages and table matching stages.

\item Decoding stages allow programmers to specify which headers get decoded and which fields in those respective headers get decoded. They also provide the mechanics to reason about which packet header comes next in a packet based on conditions satisfied by the current packet header.

\item 
Table matching stages allow programmers to \textbf{classify} packets and perform some set of \textbf{actions} on like-classified packets. This is done through a mechanism known as flow tables, which are not far off from the concept of relational tables.

\item
Actions provide a way to modify fields within a packet or modify the state of a table. Actions can also be used to forward the packet through a port on the system.

\end{itemize}
