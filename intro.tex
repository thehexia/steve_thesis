\chapter{INTRODUCTION} \label{ch:intro}

Steve is a domain-specific programming language tailored toward writing programs for \textbf{network packet processing} on \textbf{software-defined networking (SDN) devices}. 

\textbf{What is a packet?} A network packet is a formatted chunk of data used to send information across computer networks. Packets are comprised of headers and a payload. Headers contain instructions on where to send a packet across a network much like addresses on envelopes. When a network device (e.g. routers, switches, etc) receives a packet, it must decode these headers to determine where the packet must be sent next. Payloads are akin to the content of those envelopes. 

\textbf{What is SDN?} 

\textbf{Why Steve?} Steve is a language designed to make writing these networking applications easier. Even though SDN architectures provide fresh programmability to network devices, the actual practice of programming these devices is incredibly difficult and error prone. These applications, often written in C, must directly work with low-level software and hardware resources. This “low-level” code is often complex enough for programmers to easily make mistakes which can lead to logical errors, program crashes, undefined behavior, memory leakage, and ultimately network downtime which are not acceptable on backbone networking devices.

The Steve programming language and its runtime system (Flowpath) abstracts away this low-level code, making many of the more fine-grained details, such as resource acquisition, of the networking device opaque to the programmer. Steve lets programmers focus primarily on the control and forwarding behavior of the application. It also enforces a set of logical and correctness guarantees, making it more difficult for programmers to “shoot themselves in the foot,” as the saying goes.

Specifically, Steve provides the following features.

\begin{itemize}
\item The ability to specify a packet processing pipeline which is composed of decoding stages and table matching stages.

\item Decoding stages allow programmers to specify which headers get decoded and which fields in those respective headers get decoded. They also provide the mechanics to reason about which packet header comes next in a packet based on conditions satisfied by the current packet header.

\item 
Table matching stages allow programmers to \textbf{classify} packets and perform some set of \textbf{actions} on like-classified packets. This is done through a mechanism known as flow tables, which are not far off from the concept of relational tables.

\item
Actions provide a way to modify fields within a packet or modify the state of a table. Actions can also be used to forward the packet through a port on the system.

\end{itemize}
