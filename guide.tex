\chapter{The Steve User's Guide} \label{ch:users_guide}

This chapter will explore the "anatomy" of Steve. It will dissect the semantics and limitations for each language feature. It will also provide a grammar for the language. There is an expectation that the user has read the Tutorial and has a basic understanding of Steve.

This section elaborates on the conventional and illegal uses of the language. In many cases, the syntax used by the programmer has been abstracted away from much grittier details via "compiler magic". This chapter shall also elaborate on these inner mechanics.

Steve makes guarantees about the logical correctness and safety of pipeline stage composition. This section will detail how the Steve language enforces those guarantees and prove that these guarantees can be correctly enforced.

\section{Identifiers} \label{guide:identifiers}

An \textit{identifier} is an arbitrarily long sequence of characters. Supported characters include uppercase Latin letters (\texttt{A - Z}), lowercase Latin letters (\texttt{a - z}), digits (\texttt{0 - 9}), and underscores (\_). A valid identifier must begin with a non-digit character. Identifiers are case sensitive. The grammar of identifiers is as follows:

\begin{minip}
\begin{grammar}
<identifier> ::= <letter><identifier-characters>+

<identifier-character> :: <letter>
\alt <digit>
\alt \textbf{\_}

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z"

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end{grammar}
\end{minip}

Identifiers are subject to the following limitations:

\begin{itemize}
\item Identifiers which are keywords cannot be used for other purposes (see Section \ref{guide:keyword}).

\item Identifiers beginning with double underscores (\_\_) or an underscore followed by a capital letter (ex. \_F) are reserved by the compiler for internal identifiers.
\end{itemize}

Identifiers can be used as \textit{names} for \textit{entities}. An entity is a value, object, reference, function, layout, layout field, decoder, table, flow entry, port, event, extraction. In the Steve grammar, identifiers being used as names for a kind of declarations shall have the form \grd{kind}{name}, where \texttt{\textit{kind}} shall be the declaration kind. For example, a decoder name would be represented in the grammar as \grd{decoder}{name}.

Identifiers that name a variable, function, decoder, table, or port can be used as an expression. In this case, the identifier becomes an \textit{identifier expression}. Identifier expressions refer to a declaration. In cases where identifier expressions refer to object declarations (see \ref{guide:object}) a \textit{reference} to \textit{value} conversion is applied (see Section \ref{guide:reftoval_conv}. In the Steve grammar, identifier expressions shall have the form \grd{kind}{id}, where \texttt{\textit{kind}} shall be the declaration kind. For example, an identifier to a variable would be represented in the grammar as \grd{variable}{id}.

\section{Keywords} \label{guide:keyword}

A number of identifiers in Steve are reserved as \textit{keywords}. The meaning and semantics of these identifiers cannot be changed. A list of Steve keywords can be found in Figure \ref{fg:keywords_table}.

\begin{figure} [ht]
{\ttfamily
\begin{tabular*}{\textwidth\noindent}{@{\extracolsep{\fill}} l l l l l}
bool   & break   & char    & continue & def  \\
if     & else    & foreign & int      & uint \\
return & struct  & this    & var      & while \\
match  & case    & layout  & decoder  & decode \\
start  & extract & as      & exact\_table & requires \\
miss   & Port    & goto    & output   & write \\
drop   & flood   & clear   & set      & insert \\
remove & into    & from    & event    & raise \\
in\_port & in\_phys\_port & all & controller & reflow \\
advance & egress & struct & char
\end{tabular*}
}
\caption{Steve reserved keywords. Note that Steve reserves the right to make any identifiers keywords in future versions.}
\label{fg:keywords_table}
\end{figure}

\section{Field Name} \label{guide:field_name}

\textit{Field names} are special, \textit{qualified} names which refer to field declarations made within a layout declaration (see \ref{guide:layout}). Field names have the form:

\begin{minip}
\begin{grammar}
<field-name> ::=
<layout-id> \textbf{.} <field-id>
\alt <field-name> \textbf{.} <field-id>
\end{grammar}
\end{minip}

In the first form \grd{layout}{id}.\grd{field}{id}, or more succinctly \texttt{E1.E2}, \texttt{E1} must be a valid identifier to a layout declaration. \texttt{E2} must be a field of \texttt{E1}. In other words, \texttt{E2} must be found in the scope of \texttt{E1} using a qualified name lookup (see \ref{guide:qlfd_lookup}).

In the second form \grd{field}{name}.\grd{field}{id}, or more succinctly \texttt{E1.E2}, \texttt{E1} must be a valid field name which refers to a field declaration whose type, \texttt{T}, is layout type (see \ref{guide:layout_type}). \emph{E2} must be a field of the layout declaration which declares type \texttt{T}. In other words, \texttt{E2} must be found in the scope of the layout declaration which declares type \texttt{T} using qualified name lookup.

In both forms, \texttt{E1} is referred to as the \textit{container} and \texttt{E2} is referred to as the \textit{contained field}.

The \textit{containing layout identifier} is the phrase used to mean the leftmost identifier in a field name. For example, in \texttt{l1.f1.f2.f3}, \texttt{l1} is the containing layout identifier.

Field names used as expressions become \textit{field access expressions} (see \ref{guide:field_access_expr}). Field access expressions may be used to refer to the value of the last extraction with that field name.

\section{Scope} \label{guide:scope}

Steve scope semantics borrow heavily from C++ scope semantics \cite{cpp_std}. \textit{Declarations} are used throughout program text to introduce \textit{names}. Names are \textit{identifiers} used to identify \textit{entities} (see \ref{guide:identifiers}). A \textit{name} is only \textit{valid} within parts of program text called the \textit{scope} of that name. A particular name is only considered valid if an \textit{entity} with that name can be found using an \textit{unqualified name lookup} (see \ref{guide:unqlfd_lookup}).

\subsection{Global Scope} \label{guide:global_scope}

The outermost part of program text where declarations can be made is known as \textit{global scope}. All declarations made at global scope are said to be \textit{global declarations} and their names are said to be \textit{global names}.

Global names are valid at any point in the program. Steve does not require forward declarations.

Two different declarations of the same name shall not be made at global scope. Any attempts to do this shall produce a compiler error.

\subsection{Block Scope} \label{guide:block_scope}

Blocks are portions of program text which can have their own local declarations. The beginning of a block is delimited by the left-brace (\{) and the end of a block is delimited by the right-brace (\}). A declaration made within a block is in \textit{block scope} and is \textit{local} to that block.

Two different declarations of the same name cannot be made inside the same block. Any attempts to do this shall produce a compiler.

Scopes can be nested. In this case, the inner scope is said to be the \textit{enclosed} scope, and the outer scope is said to be the \textit{enclosing} scope. The same name can be declared in the enclosing scope, and again in one or more enclosed scopes. The same is true for further nested scopes within the enclosed scope. If this happens, the scope of the outer declaration is its typical scope excluding program text of the enclosed scope. Unqualified name lookup (see \ref{guide:unqlfd_lookup}) shall be used to unambiguously determine which declaration the name refers to.

The statements \texttt{if}, \texttt{while}, \texttt{match} all implicitly introduce a block.

%Here, it is useful to talk about a concept called \textit{potential scope}, similarly found in C++ \cite{cpp_std}. The scope of a declaration is the same as its potential scope. The only exception is if there are two or more declarations of the same name in the same potential scope. In this case, the actual scope of a declaration is its potential scope excluding the potential scope of the inner declarative region.

Blocks found in the program text at global scope (i.e. function bodies, layout bodies, decoder bodies, etc) introduce block scopes which are nested in global scope.

For example, in the following example, the name \texttt{i} is declared twice. The scope of the first \texttt{i} is global scope and includes the entire example excluding the block between the first left-brace (\texttt{\{}) and the closing right-brace (\texttt{\}}). The scope of the second \texttt{i} begins immediately after its declaration and ends at the the closing right-brace (\texttt{\}})

\begin{minip}
\begin{lstlisting}
var i : int = 0;
def f() -> int
{
	var i : int = 1;
	var j : int = 2 + i;
	return j; // Result here shall be 3.
}
\end{lstlisting}
\end{minip}

\subsection{Function Scope} \label{guide:function_scope}

The body of a function declaration (see \ref{guide:function}) is its \grd{block}{statement} which introduces a block. All names introduced by a \grd{parameter}{declaration} in a function declaration's \grd{parameter}{sequence} have an effective scope starting at the beginning of the block.

\subsection{Decoder Scope} \label{guide:decoder_scope}

The body of a decoder declaration (see \ref{guide:decoder}) is its \grd{block}{statement} which introduces a block scope. Declarations made inside this block are said to have \textit{decoder scope}.

\subsection{Table Scope} \label{guide:table_scope}

A table declaration (see \ref{guide:tables}) has a body given by \grd{table}{initializer} which introduces a block scope. Declarations made inside this block are said to be in \textit{table scope}.

All field names given by a \grd{key}{declaration} within \grdd{key}{declaration}{sequence}, or within the \grd{requires}{clause}, become valid within the scope of the table if and only if \textit{requirements satisfaction} (see \ref{guide:requirements}) determines that field is satisfied.

In the following example, two decoders are declared; \texttt{ipv4\_d} has extract declarations for field names \texttt{ipv4.type} and \texttt{ipv4.ttl}; \texttt{udp\_d} has extract declarations for \texttt{udp.dst\_port}.

\begin{minip}
\begin{lstlisting}
decoder ipv4_d(ipv4)
{
	extract ipv4.type;
	extract ipv4.ttl;
	// ...
	decode udp;
}

decoder udp_d(udp)
{
	extract udp.dst_port;
	// ...
	goto t1;
}
\end{lstlisting}
\end{minip}

Decoder \texttt{udp\_d} goes to table \texttt{t1}. Table \texttt{t1} has the key declarations \texttt{ipv4.type} and \texttt{udp.dst\_port}. Because requirement satisfaction is met, these field names become valid and in scope within the table's body and its flow entry's bodies. When these field names are used, they refer to the last extraction made with that field name. The same is true for \texttt{ipv4.ttl}.

\begin{minip}
\begin{lstlisting}
exact_table t1(ipv4.type, udp.dst_port)
	requires(ipv4.ttl)
{
	{ 0x01, 80 } ->
	{
		// The ipv4.type field name is valid here.
		set ipv4.type = 0x02;
		// The udp.dst_port field name is valid here.
		set udp.dst_port = 88;
		// The ipv4.ttl field name is valid here.
		set ipv4.ttl = ipv4.ttl - 1;
	}
}
\end{lstlisting}
\end{minip}

\subsection{Flow Entry Scope} \label{guide:flow_scope}

A flow declaration (see \ref{guide:tables}) has a body given by \grd{flow}{body} which introduces a block scope. Declarations made in this block are said to have \textit{flow entry scope}. If a flow declaration is part of a \grd{table}{initializer}, the flow declaration has table scope. The flow entry scope is nested inside table scope.

If a flow declaration is part of an \texttt{insert} action, the body is treated as if it were nested inside the scope of the table it is being inserted into.

Names found in the \grd{properties}{block} follow regular scope semantics. That is, all names which are normally valid at the point where the \grd{properties}{block} appears in the program text are valid inside the \grd{properties}{block}. However, these names may not be valid for the \grd{flow}{body} in the case of an \texttt{insert} action.

In the following example, the name \texttt{x} is valid in the properties block, but not in the body of the flow.

\begin{minip}
\begin{lstlisting}
event e1
{
	var x : int = 100;
	insert
	[timeout = x] // 'x' is valid here.
	{ x } -> // 'x' is also valid here.
	{
		// Error: The name 'x' is not valid here.
		set eth.type = x + 1;
		// However, the field name 'eth.type' is valid
		// because the flow body is treated as if nested
		// inside the scope of table 't1', whose key declaration
		// 'eth.type' makes the field name valid.
		flood;
	}
	into t1;
}

exact_table t1(eth.type) { }
\end{lstlisting}
\end{minip}

\subsection{Event Scope} \label{guide:event_scope}

The body of an event declaration (see \ref{guide:event}) is a \grd{block}{statement} which introduces a block scope. All field names given by the \grd{requires}{clause} are valid within the body if and only if requirement's satisfaction (see \ref{guide:requirements}) determines that the field has been satisfied.

\subsection{Layout Scope} \label{guide:layout_scope}

The body of a layout declaration (see \ref{guide:layout}) introduces a layout block. Field declarations introduce names into this layout block and are said to have \textit{layout scope}. Names of a field declaration can only be used as follows:

\begin{itemize}
\item Inside the scope of its layout.

\item After the dot-operator (\texttt{.}) applied to the name of its containing layout as part of either a field name (see \ref{guide:field_name}) or a field access expression (see \ref{guide:field_access_expr}).

\item After the dot-operator (\texttt{.}) applied to either a field name (see \ref{guide:field_name}) or a field access expression (see \ref{guide:field_access_expr}).
\end{itemize}

\subsection{Unqualified Name Lookup} \label{guide:unqlfd_lookup}

Unqualified name lookup attempts to find the corresponding declaration for a name being used. Unqualified name lookup begins at the innermost block, before the name is used and works outward toward enclosing blocks. If the declaration is not found in any enclosing blocks, global scope is searched. The innermost declaration (e.g. the first one found) with that given name found is considered the corresponding declaration.

If the name refers to one or more function declarations, and is being used as a function call, an \textit{overload set} is associated with the name. If this is the case, \textit{argument dependent lookup} determines which declaration is being referred to. The function declaration chosen shall be the one whose parameter types match the argument types used in the function call.

A name must be declared before being used. Any attempts to use a name before its declaration shall result in a failed unqualified name lookup.

Global names used at any point are considered valid regardless of the order with which they are declared in the program text. For example, the following usage of the name \texttt{i} in function \texttt{foo} refers to a variable declaration made after the function declaration. This is considered valid.

\begin{minip}
\begin{lstlisting}
// The name 'i' is used even though it is declared later
// in global scope.
def foo() -> int { return 3 + i; }
// The name 'i' is declared here.
var i : int = 0;
\end{lstlisting}
\end{minip}

If unqualified lookup fails to find a corresponding declaration, the result is a compiler error.

\subsection{Qualified Name Lookup} \label{guide:qlfd_lookup}

Qualified name lookup attempts to find the corresponding declaration for a name in a given scope. The search is done only on the given scope before the usage of the name and does not expand outward to enclosing scopes.

Qualified name lookup is most often used for looking up of names following the dot-operator in field names (see \ref{guide:field_name}) and field access expressions (see \ref{guide:field_access_expr}).

If qualified lookup fails to find a corresponding declaration, the result is a compiler error.

\section{Conversions} \label{guide:conversions}

There are a number of type conversions in Steve which are all implicitly applied. These implicit conversions are applied to expressions in the order with which they are enumerate in this section.

\subsection{Reference to Value Conversion} \label{guide:reftoval_conv}

Expressions of reference type (see \ref{guide:ref_type}) can be converted to expressions of value type. An object of reference type stores an address to its data. A \textit{reference to value conversion} causes the data to be loaded from the address stored by the reference into a temporary. The value contained in the temporary is used for the operation in place of the expression of reference type.

An identifier to an object declaration is an identifier expression. Assuming that object has type \texttt{T}, the identifier expression has type \texttt{T\&}. When used in a situation where the \textit{value} of the object is needed, a reference to value conversion is applied.

In the following example, the identifier expression \texttt{x} has reference-to-integer type. When used as part of an additive expression, the reference to value conversion is implicitly applied so both operands have integer type.

\begin{minip}
\begin{lstlisting}
var x : uint = 10;

// The reference to value conversion is
// implicitly applied on the identifier expression
// 'x' here.
x + 5;
\end{lstlisting}
\end{minip}

\subsection{Integer Conversions} \label{guide:int_conv}

Steve will convert the precision and signed/unsigned-ness of integers where necessary.

If an integer \texttt{I1} of type \texttt{T1} must be converted to an integer of type \texttt{T2}, the following conversions each get applied in order.

\begin{itemize}
\item If \texttt{T1} is an unsigned integer and \texttt{T2} is a signed integer, then the type of \texttt{I1} is converted to a signed integer type with the same precision as \texttt{T1}.

\item If \texttt{T1} is a signed integer and \texttt{T2} is an unsigned integer, then the type of \texttt{I1} is converted to an unsigned integer type with the same precision as \texttt{T1}.

\item If the precision of \texttt{T1} is less than the precision of \texttt{T2}, then the type of \texttt{I1} is converted (promoted) to an integer type with the same precision as \texttt{T2}. The extra bits are zero-filled.

\item If the precision of \texttt{T1} is greater than the precision of \texttt{T2}, then the type of \texttt{I1} is converted (demoted) to an integer type with the same precision as \texttt{T2}. The extra bits are truncated.
\end{itemize}

\subsection{Port to Integer Conversions} \label{guide:port_conv}

In some cases, namely comparison and equality operators, a port expression (see \ref{guide:port_expr}) may be converted to have integer type. A port to integer conversion takes a port object and interprets its value to an integer value. The integer value is equal to the port object's system assigned ID number. Port objects which have not been initialized or are invalid have an integer value \texttt{0}.

For example, in the following case, a port to integer conversion is applied to expression \texttt{p1} to allow it to be compared with \texttt{0} (note that a reference-to-value conversion is actually applied first since \texttt{p1} is an identifier expression with reference-to-port type).

\begin{minip}
\begin{lstlisting}
Port p1; // Uninitialized port object.
def foo() -> bool {
	// Implicit port to integer conversion.
	if (p1 == 0)
		return true;
}
\end{lstlisting}
\end{minip}

\section{Objects} \label{guide:object}

An \textit{object} in a Steve program is an area of memory that has size, lifetime, type, and value. An object may also be given a name.

Variables, ports, tables, and temporaries are objects. Objects are created in Steve by variable, port, and table declarations. Objects may be created where temporary values are required. For example, the evaluation of expressions such as addition (see \ref{guide:bitwise_expr}) produce temporary objects.

\subsection{Storage Duration and Lifetime} \label{guide:storage}

The \textit{storage duration} of an object describes the point where an object's memory is allocated and the point where its memory is deallocated.

\begin{itemize}
\item \textbf{Automatic}. Automatic storage duration says that an object is allocated at the beginning of the code block where it is declared and deallocated at the end of a code block. Global and local variables have automatic storage.

\item \textbf{Pipeline automatic}. Pipeline automatic storage duration is a property of the context object (see \ref{guide:context}). Upon packet ingress, the context is allocated, upon egress the context is deallocated.
\end{itemize}

The \textit{lifetime} of an object is either equivalent or a subset of its storage duration.

\begin{itemize}
\item \textbf{Automatic}. Automatic lifetime begins at the point where an object is \textit{initialized} and ends at the point where an object is de-initialized.

\item \textbf{Pipeline automatic}. Pipeline automatic lifetime is equivalent to pipeline automatic storage duration.
\end{itemize}

\section{Context Data Structure} \label{guide:context}

The storage duration and lifetime of a context is said to be \textit{pipeline automatic} (see \ref{guide:storage}). Management of the context's memory is exclusively and automatically handled by internal mechanics of the runtime system. This object is used exclusively by the internals of the program to keep track of information about a packet.

It is also important to note that the packet itself is also a part of the context. Any point where "the context" is referred to, it is implied to mean both the packet and context.

A user is never given direct access to a context. Context objects are implicit, yet invisible, within the scope of all pipeline processing stages (decoders, tables, and events). Certain expressions, declarations, and actions might access, modify, or otherwise affect the data of the context in limited and well-defined ways.

\begin{itemize}
\item Expressions which access a context are: field access expressions, in port expression, and in physical port expression.

\item Declarations which modify a context are: extract declarations and rebind declarations.

\item All actions (see \ref{guide:action}) will affect the context in some way.
\end{itemize}

\section{Pipeline Guarantees} \label{guide:pipeline_checking}

Logical correctness and safety guarantees are enforced by ensuring each Steve pipeline has three important properties: \textbf{progress}, \textbf{termination}, and \textbf{requirement satisfaction}. Any pipeline which does not have all three properties shall produce a compiler error. Pipelines that cannot ensure these three properties risk catastrophic crashes or undefined behavior during runtime. This cannot happen on important networking devices.

\subsection{Pipeline to Pipeline Graph Conversion} \label{guide:pipeline_graph}

These properties are checked by first converting a Steve program pipeline into a graph. Each property thus becomes a graph evaluation algorithm on the pipeline graph. To derive a pipeline graph from a Steve program, first all stages (decoders, tables, and events) are pulled from the Steve program. Each stage becomes a \textbf{node} on the pipeline graph. Table stages, specifically, become a node with edges to all of its contained flow entries which become independent nodes themselves. All inserted flow entries are also added with edges from the table they would be inserted into. Added flows cannot violate pipeline properties either, regardless of when they get added.

Every \texttt{decode}, \texttt{goto}, and \texttt{raise} action found in a stage (or flow entry within a table) causes an \textbf{edge} to be added between the stage and the destination specified by the action. This edge is added even if the action is encapsulated by a conditional statement (such as if-else or match) because its impossible to determine during compile time whether or not that edge is reachable during runtime.

Every pipeline graph must have exactly one source node (the starting decoder), but can have multiple sinks.

\subsection{Progress} \label{guide:progress}

The \textbf{progress} property says that a packet always moves to a later stage in a pipeline and can never move, or risk moving, to a previously visited stage. Progress is the fundamental nature of the pipeline abstraction. This prevents packets from infinitely looping between the same stages more than once.

The pipeline graph shall be a directed acyclic graph (DAG). A DAG, by definition, has no cycles and cannot infinitely recur between stages.

%First of all, table nodes are assigned a hidden, unique, incremented integer identifier in the order with which they are declared. For example, the first table declared in a Steve program is given the integer identifier 0, the second table declare is given the identifier 1, and so on. Conventionally, tables are expected to be declared in the order with which they are expected to occur in a pipeline.
%
%The \textbf{table identifiers} rule says that at no point in the pipeline can a packet reach a target table if it has already visited a table stage whose integer identifier is higher than or equal to that of the target table. In other words, a packet can only go forward through tables, never backwards. This is compliant with the OpenFlow specification for tables \cite{openflow_spec}. Because of this table identifiers rule, it is impossible for any number of table stages to form a cycle with each other.
%
%\textit{Proof.} A cycle can only be formed if the next table has either been visited, or is contained within a path to a table that has been visited. This can only happen if the next table has an identifier less than or equal to that of the current largest identifier visited. This property is enforced by the way tables are numbered. Since the table identifiers rule prevents a packet from being sent to these tables, it is thus impossible to form a cycle.

\subsection{Requirements Satisfaction} \label{guide:requirements}

\textbf{Requirement Satisfaction} ensures that field access can only be done on extracted fields.

Every node in a pipeline graph has a set of \textbf{productions} and \textbf{requirements}.

A \textbf{production} is a field that has been extracted or created by the node's respective stage. Currently only decoding stages are capable of have productions because they are the only ones which can extract fields. If a field were pushed (i.e. created) onto the packet, that would also constitute a production (Steve does not currently support this action).

Given any path \textit{P}, comprised of a set of nodes and edges needed to reach a node representing a stage \textit{V}, a \textbf{requirement} of \textit{V} is a field that must be a production of at least one node in the path \textit{P}. A path \textbf{satisfies} a requirement of \textit{V} if and only if this definition holds true.

In Steve, only tables, flow entries, and events can have requirements. Tables implicitly require all of their key fields. Both stages can explicitly state their requirements using the \texttt{\color{blue}requires} clause. A flow entry's requirements are implicitly that of its possessing table.

The requirements satisfaction property says that given any node \textit{V}, all requirements of \textit{V} must be satisfied by all paths leading to \textit{V}. If this property does not hold true, the result is a compiler error.

Remember that the objective is to prevent field access on fields that have not been extracted. Also remember that field access can only be done in certain cases. Firstly by a decoder if that field has been extracted by that decoder. Secondly by a table only if that field is part of the table's key or given by the table's \texttt{\color{blue}requires} clause. Thirdly by a table's flow entry whose requirements are implicitly the same. Fourthly by an event if that field is given by the event's \texttt{\color{blue}requires} clause.

\textit{Proof.} Field access can only be done in certain cases, all of which are cases where the requirements allow it. By the definition of the requirements satisfaction property all nodes in a pipeline graph must have their requirements satisfied, i.e. those fields must have been extracted along the path to that node, otherwise the result is a compiler error. Therefore, it is evident that it is impossible to compile a pipeline where field access is done on non-extracted fields.

\subsection{Depth First Search Graph Checking} \label{guide:dfs_desc}

In order to produce the most complete error messages, the Steve compiler uses depth-first traversal with backtracking to evaluate all possible paths in a pipeline graph, see Algorithm \ref{alg:dfs}. The time complexity of finding all paths from source to a sink in a DAG is O($V^2$). Assuming we have \textit{S} number of sinks, and \textit{S} is at worst \textit{V}, the time complexity of finding all paths in a DAG is O($V^3$).

As the algorithm traverses a path in the graph, it accumulates a set of productions at each node. At each node, the node's requirements are checked against the accumulating set of productions to confirm the \textbf{requirement satisfaction} property holds true. Any node which fails immediately produces a compiler error and further traversal along that path stops.

At any point in a given path, if a node's edge is directed toward a previously visited node in the path, e.g. a cycle is found, traversal past that node immediately stops and a compiler error is generated warning about the error. This ensures that the \textbf{progress} property is met. The \textbf{termination} property is actually implicit as long as the progress property is met.

\begin{algorithm}
 \caption{Depth-first traversal with backtracking used to check pipeline properties.}
 \label{alg:dfs}
 \begin{algorithmic}
 \State
 \State \textbf{Input}: Let \textit{G} be the pipeline graph. Let \textit{v} be a node in \textit{G}. Let \textit{p} be a set of productions.
 \State \textbf{Output}: Whether or not the current stage violates the progress, termination, or requirements satisfaction property. If any property fails, output a compiler error.
 \State

 \Function{DFS}{$G, v, p$}
 	\State v.visited = true
 	\State p.push(v.productions)
 	\If{meetsRequirements(v, p)}
 		\For{\textbf{all} i \textbf{in} G.adjacentNodes(v)}
 			\If{(i.visited == false) $\land$ canProgress(v, i)}
 				\State \Call{DFS}{G, i, p}
 			\Else
 				\State \Return compiler error
 			\EndIf
 		\EndFor
	\Else
 		\State \Return compiler error
 	\EndIf

 	\State v.visited = false \Comment{As we backtrack, we reset the visited property so we can come down this node again in different path.}

 	\State p.pop(v.productions) \Comment{As we backtrack, we remove the productions of the node from the set of productions.}
 \EndFunction
 \end{algorithmic}

\end{algorithm}

\section{Type} \label{guide:type}

Types are a way of describing objects, references, expressions, fields, and functions. Types can describe size, structure, and limitations on possible values for these entities. By giving types to these things, it allows the compiler to reason about limitations on where terms may appear. This process is known as \textit{type checking}. Steve is a statically typed language. Therefore, the types of all things are known during compile time. 

Steve supports scalar types, reference types, layout type, port type, and function type. Types may appear as terms in language to specify the type of variables, parameters, and layout fields. At other points, the type of an entity may be implicit. For example, the type of an additive expression (see \ref{guide:add_expr}) is implicitly integer.

Types have the form:

\begin{minip}
\begin{grammar}
<type> ::=
<scalar-type>
\alt <reference-type>
\alt <function-type>
\alt <layout-type>
\alt <port-type>
\end{grammar}
\end{minip}

\section{Scalar Type} \label{guide:scalar_type}

Objects of scalar type represent exactly one value. They are not compose of multiple sub-objects. Steve supports the scalar types boolean, integer, and character. Scalar types have the form:

\begin{minip}
\begin{grammar}
<scalar-type> ::= <boolean-type>
\alt <integer-type>
\alt <character-type>
\end{grammar}
\end{minip}

\subsection{Boolean Type} \label{guide:bool_type}

Objects of boolean type may only have the values \texttt{true} and \texttt{false}. Objects of boolean type have a size of 8-bits. They have the form:

\begin{minip}
\begin{grammar}
<boolean-type> ::= "bool"
\end{grammar}
\end{minip}

\subsection{Integer Type} \label{guide:integer_type}

Integer type describes the size, precision, and signed/unsigned-ness of a given integer value. They have the form:

\begin{minip}
\begin{grammar}
<integer-type> ::= <signed-integer-type>
\alt <unsigned-integer-type>

<signed-integer-type> ::= "int" <precision-clause>

<unsigned-integer-type> ::= "uint" <precision-clause>

<precision-clause> ::= ["("<integer-literal>")"]
\end{grammar}
\end{minip}

The precision and effective size of an integer is given by \grd{precision}{clause}. If \grd{precision}{clause} is not given, the default precision and effective size shall be 32. For signed integers, the range of integers that can be represented is from $-2^{N-1}$ to $2^{N-1}-1$, where \textit{N} is the precision. For unsigned integers, the range of integers that can be represent is $0$ to $2^{N}-1$.

\subsection{Character Type} \label{guide:char_type}

Single characters have character type. Character type has the form: 

\begin{minip}
\begin{grammar}
<boolean-type> ::= "char"
\end{grammar}
\end{minip}

\section{Reference Type} \label{guide:ref_type}

Objects and expressions of reference type represent an address to an object. Assuming the referred-to object has type \texttt{T}, then a reference to that object has type \texttt{T\&} which is read as "reference-to-\texttt{T}." Reference type may be written and has the form:

\begin{minip}
\begin{grammar}
<reference-type> ::= <type> "\&" 
\end{grammar}
\end{minip}

Identifier expressions referring to variables have reference type. Field access expressions refer to extractions and thus have reference type.

For example, in the following, the variable \texttt{x} has type \texttt{int} and the identifier expression \texttt{x} would have type \texttt{T\&}.

\begin{minip}
\begin{lstlisting}
var x : int = 0; // Variable x
x; // This identifier expression has type ref T
// Used as a value, reference-to-value conversion
// is applied to x
var y : int = x + 10;
\end{lstlisting}
\end{minip}

When a value of type \texttt{T} is needed rather than the reference (traditionally in expressions which appear on the left side of an assignment) a reference-to-value conversion (see \ref{guide:reftoval_conv}) is applied. 

Variables of reference type may be created. Assignment to that variable modifies the original object as well. For example:

\begin{minip}
\begin{lstlisting}
var x : int = 0; // Variable x
var y : int& = x; // y is a reference to x.
y = 5; // This modifies x as well, so now both are 5.
\end{lstlisting}
\end{minip}

Here we have a variable \texttt{x} of type \texttt{int}. We have a variable \texttt{y} if type \texttt{int\&}, and identifier expression \texttt{x} of type \texttt{int\&} is assigned to it. Any modifications to \texttt{y} have the same affect on \texttt{x}, because y only stores an address to the original object. Any modifications to why affect the original object.

\section{Array Type} \label{guide:array_type}

Array types describes a region of contiguous memory containing \texttt{N} number of objects of type \texttt{T}. Array type has the form: 

\begin{minip}
\begin{grammar}
<array-type> ::= <type> "["<integer-literal>"]"
\end{grammar}
\end{minip}

The type \texttt{T} is given by \gr{type}. The number of objects \texttt{N} is given by \grd{integer}{literal} whose type must be unsigned integer.


\section{Block Type} \label{guide:block_type}

A block type describes a region of contiguous memory containing an unknown number of objects of type \texttt{T}. Block type has the form:

\begin{minip}
\begin{grammar}
<block-type> ::= <type> "[" "]"
\end{grammar}
\end{minip}

Block type may be used when the length of an array is unknown during compile time. Block type is most frequently given to variables used to hold strings. For example:

\begin{minip}
\begin{lstlisting}
var str : char[] = "Hello, world";
\end{lstlisting}
\end{minip}

\section{Layout Type} \label{guide:layout_type}

Layout types are declared via layout declarations (see \ref{guide:layout}). Layout types have the form:

\begin{minip}
\begin{grammar}
<layout-type> ::= <layout-id>
\end{grammar}
\end{minip}

Objects of layout type shall not exist. The \grd{layout}{type} may only appear as part of a field declaration within a layout declaration (see \ref{guide:layout}). It may not appear in variable declarations or function declarations as such:

\begin{minip}
\begin{lstlisting}
layout L1 { f1 : uint; f2 : uint(16); }
var x : L1 = 0; // Invalid
// Invalid parameter type and return type.
def foo(y : L1) -> L1 { ... }
\end{lstlisting}
\end{minip}

The size of a layout is equal to the sum of the sizes of each of its field types. This is only knowable at compile time if the layout contains only scalar typed fields. For example, the layout \texttt{L1} has a size of 48 bits or 6 bytes.

\section{Port Type} \label{guide:port_type}

All port declarations have port type. Port type is not a type that appears explicitly in the grammar. Variables, parameters, and fields may not have port type.

In certain cases, namely ordering and equality operators (see \ref{guide:ordering_expr}), an object of port type may be converted to an object of integer type. The value of the converted port object is equal to its system assigned integer identifier. This allows for the comparison of ports to integers as follows:

\begin{minip}
\begin{lstlisting}
Port p1;
// ...
// Comparison against 0 checks if the port is valid.
// The 0 port is the invalid port.
if (p1 == 0) { ... }
\end{lstlisting}
\end{minip}

\section{Function Type} \label{guide:function_type}

Functions have function type. Function type describes the type of each parameter and the return type of the function. Function type can be written and has the form:

\begin{minip}
\begin{grammar}
<function-type> ::= "("<type-sequence>")" "->" <type>
\end{grammar}
\end{minip}

The type of each parameter is given by a corresponding type in \grd{type}{sequence}. The return type is given by \gr{type}.

\section{Declarations} \label{guide:declarations}

\textit{Declarations}, generally speaking, introduce an entity and a name for that entity. When using that name, the declaration is used to determine how to interpret that name.

For example, a variable declaration (see \ref{guide:variables}) introduces a variable and a name for that variable. When the name for that variable is used in program text, it is used to mean the variable itself.

A \textit{definition} in Steve is equivalent to a declaration in all but one case. The only case where a definition is distinct from a definition is when the \texttt{foreign} specifier (see \ref{guide:foreign_spec}) is attached to an incomplete function declaration.

Declarations have the form:

\begin{minip}
\begin{grammar}
<declaration> ::=
[ <specifier-seq> ] <declaration>
\alt <global-declaration>
\alt <key-declaration>
\alt <extract-declaration>
\alt <rebind-declaration>
\alt <flow-declaration>
\alt <field-declaration>
\alt <parameter-declaration>
\alt <variable-declaration>

<global-declaration> :: =
<port-declaration>
\alt <layout-declaration>
\alt <decoder-declaration>
\alt <table-declaration>
\alt <event-declaration>
\alt <function-declaration>
\end{grammar}
\end{minip}

All declarations must occur within a scope. A declaration that declares a layout, decoder, table, event, or function causes a scope to be nested in global scope. That scope might also have scopes nested within it.

Certain declarations can only occur within certain scopes. Specifically, declarations which declare ports, layouts, decoders, tables, events, and functions must occur at global scope. These cannot occur within block scope. These are known as \textit{global} declarations.

Declarations may have a number of specifiers (see \ref{guide:specifications}) attached to them, given by \grd{specifier}{seq}. Specifiers modify the semantics of declarations.

\section{Specifiers} \label{guide:specifications}

Specifiers modify the semantics of a declaration. A sequence of specifiers may optionally appear at the beginning of a declaration. Not all specifiers are allowed on all declarations. Not all specifiers are allowed to appear together before the same declaration. Note that there is currently only one supported specifier. A number of other specifiers will eventually be introduced.

Specifiers have the following form:

\begin{grammar}
\singlespace
<specifier> ::= \textbf{foreign}
\end{grammar}

\subsection{Foreign Specifier} \label{guide:foreign_spec}

The \texttt{foreign} specifier can only appear before \grd{function}{declaration}. This specifier says that a function has foreign linkage, that is, the function is not defined in this scope but rather in a different program. This function is said to be a \textit{foreign function}. The name of a foreign function is not mangled. Foreign functions cannot have a definition, that is, the \grd{function}{declaration} cannot have a \grd{block}{statement}. This is the only case where a declaration varies from a definition.

Foreign linkage is most often used to link against the C runtime library. For example, the following introduces the \texttt{puts} C-function into global scope. Function calls to \texttt{puts} will call the C-function with the same name.

\begin{minip}
\begin{lstlisting}
foreign def puts(char[]) -> int;

def main() -> int {
	puts("Hello world.");
}
\end{lstlisting}
\end{minip}
 
\section{Layout Declaration} \label{guide:layout}

\textit{Layout declarations} are used to define the physical structure of packets in memory. A layout declaration declares a \textit{layout type}. Layout declarations have the following form:

\begin{minip}
\begin{grammar}
<layout-declaration> ::=
\textbf{layout} <layout-name>
\textbf{\{}
	<field-declaration> +
\textbf{\}}

<field-declaration> ::=
<field-name> \textbf{:} <type> \textbf{;}
\end{grammar}
\end{minip}

Layout declarations shall contain one or more \textit{field declarations}, denoted in the grammar as \grd{field}{declaration}. Field declarations introduce names for fields into layout scope. The type of a field declaration, denoted by \gr{type} shall be scalar or layout type. \footnote{Though \texttt{bool} and \texttt{char} are valid scalar types and can appear as \gr{type}, they will result in a compiler error if the given field is needed as part of a table's key. This is a limitation that will be adjusted in later revisions.} Types of field declarations are used to specify the length of the given field. Because this is the extent of the usage, there is no reason to support more complex user-defined types here.

Field declarations must occur in the order with which they appear in the an actual instance of a header which the layout represents. Incorrect ordering will result in incorrect extractions (see \ref{guide:extract}).

All field declarations declared within a layout declaration define a \textit{complete} layout. Field declarations may not be added to a layout elsewhere.

Though layout declarations declare layout types, objects of layout type can never be created and functions cannot have parameters or returns of layout type. The following is not legal in Steve. A layout type may only appear as the type of a field declaration in layout scope.

\begin{minip}
\begin{lstlisting}
layout l1 { ... }
var x : l1; // Illegal.
def foo(x : l1) -> l1 { ... } // Illegal.
\end{lstlisting}
\end{minip}

\subsection{Why Objects of Layout Type can not Exist.}

Remember that layouts are not classes. The primary reason for this differentiation in Steve are dynamically-sized fields in packet headers. Headers potentially have fields whose length is predicated upon some value discovered during runtime. These fields are said to have \textit{dynamically-sized type}. Some examples of this are the \texttt{options} fields in IPv4, IPv6, and TCP headers.

Consider that when objects of user-defined type (i.e. class type) are constructed, stack space must be allocated for them. The amount of space must be known during compilation. By including a member of DST in a class it effectively "taints" a class, making the class a user-defined DST. It is not possible to stack allocate an object which contains a member of DST because the amount of memory needed is unknown until runtime. It suddenly becomes impossible to create variables of that user-defined type, making the entire abstraction meaningless. Therefore, DSTs cannot be members of user-defined types.

Such objects can only be heap allocated, which Steve does not currently support. The only exception is if memory is being allocated for an object of non-user-defined, dynamically-sized type. In this case, stack space can be allocated for this "scalar" DST, but access to it would happen through pointer addressing. The only language which supports user-defined DSTs, Rust, only allows it under very limited circumstance \cite{rust_dst_std}.

By extension, because layouts must contain fields of DST, Steve cannot allow layouts to behave like a user-defined type. Therefore, objects of layout type can never be created.

Layouts cannot contain member functions. It logically follows that since objects of layout type cannot exist, there is no justification for having member functions.

\section{Decoder Declarations} \label{guide:decoder}

Decoder declarations have the following form:

\begin{minip}
\begin{grammar}
\singlespace
<decoder-declaration> ::=
\textbf{decoder} <decoder-name> [\textbf{start}]
\textbf{(} <layout-id> \textbf{)}
<block-statement>
\end{grammar}
\end{minip}

The identifier given by \grd{layout}{id} must name a valid layout declaration at global scope. This \grd{layout}{id} is known as the \textit{layout rule} of the decoder. Different decoder declarations may use the same layout rule. The layout rule is used to determine the \textit{current view} and \textit{implicit advances} generated by a decoder (see \ref{guide:decoder_view}). Extract declarations (see \ref{guide:extract}) may only extract fields from this layout.

The optional \texttt{start} keyword shall occur on exactly one decoder declaration in a given program text. This decoder shall be considered the source (root) of the pipeline graph during pipeline checking. This decoder shall be the first decoder applied to a packet context after ingress.

The execution of a decoder is similar to that of a function. Each statement within \grd{block}{statement} is executed in turn.

\subsection{Decoder View and Shifting} \label{guide:decoder_view}

The \textit{current view} of a packet begins where the first byte of the current header being decoded lies in memory. The end of the current view is found at the position of the beginning plus the length of the current header. For headers whose lengths can be determined during compile time using the layout declaration referred to be the layout rule, the current view is said to be \textit{statically-sized}. For headers whose lengths must be determined by operations performed at runtime, the current view is said to be \textit{dynamically-sized}.

Steve uses this view mechanism to allow for partial decodes of headers. Without the ability to find fields relative to the beginning of views, decoding phases would be forced into full forward decoding, meaning for a field to be extracted, all fields prior to it would have to be extracted. This prevents us from receiving the gains of partial decode.

The context is used to maintain a positional index, known as the \textit{view index}, corresponding to the beginning of the current view. At first, this index begins at 0, corresponding to the first byte of the packet, and thus the first byte of the first header. Each decoder shifts the current view by the length of the current header before transitioning to the next stage, that is, the length of the current header is added to the view index upon the execution of a \texttt{decode} or a \texttt{goto} action (see \ref{guide:decode_action} \& \ref{guide:goto}).

If the view is statically-sized, the shift shall be implicitly emitted as code by the compiler by using the layout rule. This is known as an \textit{implicit advance}.

If the view is dynamically-sized, the length of the shift must be explicitly qualified using the \texttt{\color{blue}advance} clause. This is known as an \texttt{explicit advance}.

\section{Extract Declaration} \label{guide:extract}

Extract declarations have the following form:

\begin{grammar}
<extract-declaration> ::=
\textbf{extract} <field-name> \textbf{;}
\end{grammar}

An \textit{extract declaration} declares that a field with the specified \grd{field}{name} (see \ref{guide:field_name}) is to be extracted by the decoder. The field name is in scope at the point of the extract declaration. The extracted field, or \textit{extraction}, is an object in memory whose name shall be \grd{field}{name}.

An extract declaration must be in decoder scope. Attempting to put an extract declaration in any other context shall result in a compiler error.

The containing layout identifier of \grd{field}{name} (see \ref{guide:field_name}) shall be the same layout identifier as the one given by the decoder's \textit{layout rule} (see \ref{guide:decoder}). A decoder shall not extract fields from layouts which are not it's layout rule. For example, the following is illegal:

\begin{minip}
\begin{lstlisting}
decoder eth_d(eth) {
	// Error: Illegal, this decoder does not extract ipv4.
	extract ipv4.dst; 
	// ...
}
\end{lstlisting}
\end{minip}

\subsection{Determining the Location and Length of Extracted Fields}

An extract declaration produces an extraction by executing a set of instructions on a packet which saves the extraction's \textit{location} and \textit{length} to the context's header environment (see \ref{context_desc}, \ref{guide:context}). Information gathered from \grd{field}{name} is used to calculate these two values. This process is completely opaque to the user, and is described below.

\begin{enumerate}
\item Discover the field declaration $f$ referred to by \grd{field}{name}. The length of the extracted field is calculated by a function $len(f)$. The result of $len(f)$ is the \textit{size} of an object of $f$'s type.

\item The \grd{field}{name} has the form \texttt{E1.E2} where \texttt{E1} is the \textit{container} and \texttt{E2} is the \textit{contained field}. The set $P$ is the set of all field declarations preceding $f$ in its containing layout declaration. The function used to calculate the \textit{relative offset} of $f$ is given as $rel(E1)$ and is defined as:

\begin{enumerate}

\item If \texttt{E1} is a \grd{layout}{id}, then the $rel(E1) = \sum_{x \in P}{} len(x)$.

\item If \texttt{E1} is a \grd{field}{name} and \texttt{E1}'s container is denoted as \texttt{E1.c}, then $rel(E1) = rel(E1.c) + \sum_{x \in P}{} len(x)$

\end{enumerate}

\item Given a field name of the form \texttt{E1.E2}, and the current view index (see \ref{guide:decoder_view}), $i$, the \textit{absolute offset} of the field being extracted is this $i + rel(E1)$.

\item The location of an extracted field is its absolute offset, that is, the number of bytes it is away from the beginning of the packet.
\end{enumerate}

The following example shall be used to demonstrate how each calculation is made. Two layouts, \texttt{L} and \texttt{LN}, and a decoder, \texttt{D}, are provided. \texttt{L} has three fields: \texttt{a}, \texttt{b}, and \texttt{c}.  \texttt{LN} has two fields: \texttt{d} and \texttt{f}. Field \texttt{L.c} has layout type \texttt{LN} and is thus a nested layout. \texttt{D} decodes \texttt{L} and extracts \texttt{L.a} and \texttt{L.c.f}.

\begin{minip}
\begin{lstlisting}
layout L {
	a : uint;
	b : uint;
	c : LN;
}

layout LN {
	d : uint(8);
	f : uint(16);
}

decoder D(L) {
	extract L.a;
	extract L.c;
	// ...
}
\end{lstlisting}
\end{minip}

The first extract declaration is \texttt{extract L.a}. \texttt{L.a} refers to field declaration \texttt{a} in layout \texttt{L}. The type of \texttt{a} is \texttt{uint} (by default this is a 32-bit unsigned integer). The result of $len(a)$ is thus expected to be 32-bits or 4 bytes. The relative offset of \texttt{a} in \texttt{L} is the sum of the lengths of all field declaration which precede it. In this case, no fields precede it, thus the relative offset for the field denoted by \texttt{L.a} is 0.

The second extract declaration is \texttt{extract L.c.f}. \texttt{L.c.f} refers to field declaration \texttt{f} in \texttt{LN} which, in turn, is the type of \texttt{L.c}. \texttt{L.c} refers to field declaration \texttt{c} in \texttt{L}. Here is the case of the nested layout. The type of \texttt{f} is \texttt{uint(16)}, thus the result of $len(f)$ is 16-bits or 2 bytes. The relative offset of \texttt{f} is the sum of the length of all field declaration which precede it in \texttt{LN}, in this case, 8-bits or 1 byte, plus the relative offset of \texttt{c} in \texttt{L}. The relative offset of \texttt{c} in \texttt{L} is 64-bits or 8-bytes long. Thus, the relative offset for  \texttt{L.c.f} is 72-bits or 9-bytes.

Assuming the beginning of the current view for \texttt{D} is 14 bytes past the beginning of the packet. The \textit{absolute offset} for \texttt{L.a} would be 14 bytes. The absolute offset for \texttt{L.c.f} would be $14+9$ or 23 bytes.

\subsection{Extracting the Same Field More Than Once}

It is important to note that a decoder is only ever looking at one header of a packet at once. Using an extract declaration with the same field name more than once in the same decoder will result in the same instance of that field being extracted multiple times, which is completely redundant. Though legal, this should be avoided in most cases.

The following is not considered good practice, though it is valid:

\begin{minip}
\begin{lstlisting}
decoder d1(l1) {
	var x : int = 0; 	
	while (x < 5) {
		extract l1.f1;
		// ...
	}
	// ...
}
\end{lstlisting}
\end{minip}

\subsection{Rebind Declaration} \label{guide:rebind}

At certain times, it may be convenient to extract a certain field, but \textit{alias} that field with a different name than the original. This can be done with the \textit{extract-as}, otherwise known as the \textit{rebind} declaration. A rebind declaration has the following form:

\begin{minip}
\begin{grammar}
<rebind-declaration> ::=
\textbf{extract} <field-name> \textbf{as} <field-name> \textbf{;}
\end{grammar}
\end{minip}

The rebind declaration requires two field names be given. The first \grd{field}{name}, or more succinctly \texttt{N1}, shall be known as the \textit{original field name}. The second \grd{field}{name}, or more succinctly \texttt{N2}, shall be known as the \textit{alias field name}. \texttt{N1} and \texttt{N2} must both be valid field names.

The field declaration named by \texttt{N1} shall have the same type as the field declaration named by \texttt{N2}. For example:

\begin{minip}
\begin{lstlisting}
layout l1 {
	a : uint(16);
	b : uint(24);
}

layout l2 {
	c : uint(16);
	d : uint(32);
}

// ...

decoder d2(l2)
{
	// Legal. l2.c has the same type as l1.a
	extract l2.c as l1.a;
	// Error: Illegal. Mismatched types.
	extract l2.d as l1.b;
	// ...
} 
\end{lstlisting}
\end{minip}

A rebind declaration causes \texttt{N1} and \texttt{N2} to be in scope. Both names may be used to refer to the same extraction. Both names are added to the decoder's productions (see \ref{guide:requirements}). The names \texttt{N1} and \texttt{N2} may be used as field names in either key declarations or requires clauses in tables and events later in the pipeline. 

The extractions which \texttt{N1} can refer to are a subset of the extractions \texttt{N2} can refer to. The aliased name naturally can refer to extractions which are from a different kind of field than the original name. To demonstrate this, the following revision is made to the prior example:

\begin{minip}
\begin{lstlisting}
decoder D1(L1) {
	extract L1.a;
	if (l1.a == 0)
		goto L1;
	decode d2;
}

decoder D2(L2) {
	extract L2.c as L1.a;
	// Valid usage of L2.c.
	var i : uint(16) = L2.c;
	// Valid usage of L1.a to refer to the same extraction.
	var j = uint(16) = L1.a;
	// ...
	set L2.c = 1;
	goto T1;
}

// Key field L1.a will refer to the last extraction of L1.a.
// If D1 sends the packet to T1, then it will be the L1.a field.
// 
// If D2 sends the packet to T1, then L1.a shall refer to an
// extraction of L2.c instead.
exact_table T1(L1.a) {
	{ 0 } -> { drop; }
	{ 1 } -> { flood; }
}
\end{lstlisting}
\end{minip}

Here we have two decoders \texttt{D1} and \texttt{D2}. If a packet is sent directly to table \texttt{T1} from decoder \texttt{D1}, the value of the last extraction of \texttt{L1.a} will be \texttt{0} (based on the \texttt{if} condition). In this scenario, the packet is dropped. 

However, if the packet is sent from decoder \texttt{D2}, the field name (and by extension the extraction) \texttt{L2.c} has been aliased as \texttt{L1.a}. The field \texttt{L2.c} also has its value set to \texttt{1}. Here, the last extraction of \texttt{L1.a} shall be \texttt{1} because L2.c has a value of \texttt{1} and it has been aliased by the name \texttt{L1.a}. Therefore, when the packet is matched against \texttt{T1}'s flow entries, the packet shall be flooded.

Supposing table \texttt{T1} from the prior example were replaced with the following version of \texttt{T1}, then the \texttt{goto t1} action in decoder \texttt{D1} would actually produce a compiler error for violating requirements satisfaction (see \ref{guide:requirements}). 

\begin{minip}
\begin{lstlisting}
exact_table T1(L2.c) {
	// ...
}
\end{lstlisting}
\end{minip}

This version of \texttt{T1} uses \texttt{L2.c} as a key field. However, \texttt{L1.a} is not the same field as \texttt{L2.c} and has not been aliased as such.

\section{Table and Flow Declarations} \label{guide:tables}

Table declarations have the following form:

\begin{minip}
\begin{grammar}
<table-declaration> ::=
\textbf{table} <table-name> \textbf{(} <key-declaration-sequence> \textbf{)}
[ <requires-clause> ] <table-initializer>

<key-declaration> ::=
<layout-id> \textbf{.} <field-id>
\alt <key-declaration> \textbf{.} <field-id>
\alt \textbf{in\_port}
\alt \textbf{in\_phys\_port}

<requires-clause> ::=
\textbf{requires} \textbf{(} <field-name-sequence> \textbf{)}

<table-initializer> ::= \textbf{\{} [ <flow-declaration-list> ] \textbf{\}}

<flow-declaration-list> ::= <flow-declaration>
\alt <flow-declaration-list> <flow-declaration>
\end{grammar}
\end{minip}

Table declarations may cause table objects to be created. After loading a Steve generated application, the runtime system (see \ref{ch:flowpath}) shall receive a number of table allocation requests from the Steve program corresponding to each table declaration made in the program text. These requests are made as part of load-time configuration (see \ref{config_guide}). Each request shall provide:

\begin{itemize}
\item A table name.
\item The set of key fields that comprise the table's key.
\item A maximum number of flow entries.
\end{itemize}

If tables with those properties already exist, the runtime system provides the Steve application with the already existing table. This can happen if multiple Steve applications are run on the same device.

The table's \textit{key fields} are a set of one or more fields which together compose a \textit{key}. A table's key is given by \grdd{key}{declaration}{sequence} in the grammar. Each \grd{key}{declaration} shall also be a valid field name, or be the keywords \texttt{in\_port} or \texttt{in\_phys\_port}. The type of \grd{key}{declaration} shall be the type of the field declaration named by the same field name, or shall be port type (see \ref{guide:port_type}) in the case of \texttt{in\_port} or \texttt{in\_phys\_port}.

The \grd{requires}{clause} is optional. Each field name within the \grd{requires}{clause} must be a valid field name. A field name here may have the same field name as a \grd{key}{declaration} in the same table declaration. There is no change in semantics when this happens. Field names given by \grdd{key}{declaration}{sequence} are implicitly required.

Field names given in the \grdd{key}{declaration}{sequence} and the \grd{requires}{clause} are valid inside the block of \grd{table}{initializer} based on table scope semantics (see \ref{guide:table_scope}).

Each table has a set of \textit{flow entries} declared in Steve using a \grd{flow}{declaration} of the following form:

\begin{minip}
\begin{grammar}
<flow-declaration> ::=
<properties-block>
\textbf{\{} <match-field-sequence> \textbf{\}} \textbf{-\textgreater} <flow-body>
\alt <miss-flow-declaration>

<match-field> ::= <expression>

<flow-body> :: \textbf{\{} <action> + \textbf{\}}

<properties-block> ::=
\textbf{[} <property-sequence> \textbf{]}

<property> ::=
<property-kind> \textbf{=} <expr>

<property-kind> ::=
\textbf{timeout}
\alt \textbf{egress}

<miss-flow-decl> ::=
\textbf{miss} \textbf{-\textgreater} <flow-body>
\end{grammar}
\end{minip}

The \textit{match fields} of a flow entry, that is, values corresponding to a table's key fields, is given by \grdd{match}{field}{sequence}. The type of each \grd{match}{field} must be the same type as its corresponding \grd{key}{declaration}. The count of \grd{match}{field} in \grdd{match}{field}{sequence} shall be equal to the count of \grd{key}{declaration} in \grdd{key}{declaration}{sequence}.

All flow entries in the same table must be uniquely identifiable by their \textit{match fields} and their \textit{priority} (since we only support exact match tables, the priority is the same on all flow entries). If a flow entry being inserted into a table has the same value in each match field as an already existing flow entry in the table, the previous flow entry is removed and replaced by the new flow entry.

Flow entries may optionally have a \grd{properties}{block}. \textit{Properties} are additional metadata that can be attached to flow entries. There are currently two properties: \texttt{timeout} and \texttt{egress}. The \texttt{timeout} property specifies the duration (in milliseconds) that the flow entry will remain the table. The \texttt{egress} property specifies an egress port that can be accessed in the flow entry. This is most useful for using the \texttt{output egress} action within added flow entries (see \ref{guide:output}).

The set of \textit{initial flow entries}, that is, the flow entries which are inserted into the table during load-time configuration, are given as \grd{flow}{declarations} within \grd{table}{initializer}. Each initial flow entry is inserted with the order in which they are declared. There may only be one or less \grd{miss}{flow}{decl} shall appear here.

\section{Event Declaration} \label{guide:event}

An event declaration has the following form:

\begin{minip}
\begin{grammar}
<event-decl> ::=
\textbf{event} <event-name> [ <requires-clause> ]
<block-statement>
\end{grammar}
\end{minip}

An event declaration defines a special function, known as an \textit{event handler}, which has access to extractions (see \ref{guide:extract}) and actions (see \ref{guide:action}) just like decoders. They implicitly take a context (see \ref{guide:context}) as a parameter. These are used when an exceptional \textit{event} has occured and certain slower actions need to be applied, e.g. adding and removing flow entries.

An event handler can only be invoked via the raise action. At this time, a \textit{copy} of the context is passed to the runtime. The runtime shall forward the context and event handler packaged together to the controller port. A program sits on the controller port waiting to receive these contexts and event handlers. This program shall execute the event handler on the given context. The execution of an event handler happens immediately upon the raise action being used if the runtime is single-threaded. However, the behavior is runtime implementation specific. The execution may be multi-threaded and asynchronous, therefore, the user should have no expectations on the order of execution. 

A \textit{copy} of the context  and packet are always passed to an event handler. Any modifications to a packet via actions within an event shall not apply to the original. For example, in the following, it is demonstrated that a field modified via \texttt{set} action only affects a copy and never the original packet.

\begin{minip}
\begin{lstlisting}
exact_table t1(eth.dst)
{
	{ 0x12_34_56_78_90_ab } ->
	{
		// event1 tries to set eth.dst to 0x0
		raise event1;
		// eth.dst will still be 0x12_34_56_78_90_ab
		// after the raise action is finished because
		// only a copy is passed to event1.
		
		// ...
	}
}

event event1
	requires(eth.dst)
{
	// This will not modify the original.
	// Only a copy of the context and packet are
	// operated on.
	set eth.dst = 0x0;
}
\end{lstlisting}
\end{minip}

Event declarations are subject to meeting the \textit{requirements satisfaction} property of pipelines, even though they themselves are not completely separate stages.

The \grd{requires}{clause} is optional. The field names given in \grd{requires}{clause} must be valid field names. Those field names become valid inside \grd{block}{statement} by event scope semantics (see \ref{guide:event_scope}).

\section{Port Declaration} \label{guide:port}

A port declaration has the following form:

\begin{minip}
\begin{grammar}
<port-decl> ::=
\textbf{Port} <port-name> [ <port-initializer> ] \textbf{;}

<port-initializer> ::= \textbf{=} <integer-literal>
\end{grammar}
\end{minip}

Port declarations are required to be in global scope.

A port declaration may have an optional \grd{port}{initializer}. The \grd{port}{initializer} shall be \grd{integer}{literal}. If \grd{port}{initializer} is not given, \grd{port}{initializer} shall be implicit and the value of \grd{integer}{literal} shall be 0.

Upon load-time configuration (see \ref{ch:flowpath}), for each port declaration, a discovery request is made to the runtime system for a port whose system-assigned identifier is equal to the value given by \grd{integer}{literal}. Any requests for port's whose identifiers do not exist result in the Steve application failing to load.

The port identifier zero (0) is reserved as the \textit{invalid port}. It exists, but forwarding to it results in packet drop.

\section{Variable Declarations} \label{guide:variables}

Variable declarations have the form:

\begin{minip}
\begin{grammar}
<variable-decl> ::=
"var" <variable-name> ":" <type> [<variable-initializer>]";"

<variable-initializer> ::= "=" <expression>
\end{grammar}
\end{minip}

A variable declaration may have an optional \grd{variable}{initializer} following \gr{type}.  If this initializer is not given, the result is default initialization. Default initialization of scalar types shall result in their objects having a binary value of zero.

If \grd{variable}{initializer} is given, the type of \gr{expression} shall match the type given by \gr{type}, or there shall exist a conversion sequence (see \ref{guide:conversions}) from the type of \gr{expression} to the type given by \gr{type}. The value given by \gr{expression} shall be copied into the allocated object memory, that is, \textit{copy initialized}.

\section{Function Declarations} \label{guide:function}

A function declaration has the following form:

\begin{minip}
\begin{grammar}
<function-declaration> ::=
"def"<function-name>"("[<parameter-decl-sequence>]")" "->" <type> <block-statement>

<parameter-decl> ::= <parameter-name> ":" <type>
\end{grammar}
\end{minip}

The type of a function declaration (see \ref{guide:function_type}) is determined by its \textit{return type}, given by \gr{type}, and its \textit{parameters}, given by \grdd{parameter}{decl}{sequence}. The body of the function, given by \grd{block}{statement}, is the set of instructions that get executed upon calling the function.

There may be multiple declarations of a function with the same \grd{function}{name} if and only if:

\begin{itemize}
\item Each function declaration has a different type.
\item Two function declarations of the same name, but different type, may not vary only in their return type.
\end{itemize} 

\section{Expressions} \label{guide:expr}

Expressions, generally speaking, perform some type of operations or computations which may return results or have side effects on the state of the program. Steve has the following expressions:

\begin{minip}
\begin{grammar}
<expression> ::=
<primary-expression>
\alt <binary-expression>
\alt <unary-expression>
\end{grammar}
\end{minip}

\section{Primary Expressions} \label{guide:primary_expr}

Primary expressions are expressions which have no operators. Primary expressions have the following form:

\begin{minip}
\begin{grammar}
<primary-expression> ::= 
<identifier-expression>
\alt <field-access-expression>
\alt <literal-expression>
\alt <port-expression>
\end{grammar}
\end{minip}

\section{Identifier Expressions} \label{guide:id_expr}

When an \gr{identifier} (see \ref{guide:identifiers}) is used where an \gr{expression} is expected, it is considered an identifier expression. Identifier expressions have the form:

\begin{minip}
\begin{grammar}
<identifier-expression> ::= <identifier>
\end{grammar}
\end{minip}

Identifier expressions most often refer to a specific declaration of that name. When used as an expression, an identifier returns the entity being referred to. If the identifier refers to an object (see \ref{guide:object}), the type of the object is \texttt{T}, and the identifier expression has \texttt{T\&} type. If the value of the object is required, then a reference-to-value conversion is applied (see \ref{guide:reftoval_conv}).

The grammar shall refer to identifier expressions refering to specific kinds of declarations using \grd{kind}{id}, where \texttt{\textit{kind}} is the kind of declaration. For example, an identifier expression refering to a decoder shall be \grd{decoder}{id}.

\section{Field Access Expression} \label{guide:field_access_expr}

When a field name (see \ref{guide:field_name}) is used where an \gr{expression} is expected, it is considered a field access expression. Field access expressions have the form:

\begin{minip}
\begin{grammar}
<field-access-expression> ::= <field-name>
\end{grammar}
\end{minip}

Field access expressions refer to a field extracted by a decoder, or an \textit{extraction} for short. Field access expressions are similar to identifier expressions (see \ref{guide:id_expr}), except they specifically refer to extractions.

A field access expression may only occur within the body of a decoder declaration (see \ref{guide:decoder}), a flow declaration (see \ref{guide:tables}), or an event declaration (see \ref{guide:event}). In addition to these limitations, a field access expression may only occur:

\begin{itemize}
\item In a decoder declaration if and only if an extract declaration (see \ref{guide:extract}) extracts a field with the same field name before the field access expression's use.

\item In a flow declaration if and only if the table containing the flow uses the same field name as a key, or lists it in its requires clause.

\item In an event declaration if and only if the event lists the same field name in its requires clause.
\end{itemize}

If the type of the extraction is \texttt{T}, then the type of a field access expression refering to that extraction shall be \texttt{T\&}. When the value of that field is required, then a reference-to-value conversion (see \ref{guide:reftoval_conv}) is applied to recover the value.

\section{Port Expressions} \label{guide:port_expr}

A port expression is either an identifier which refers to a port declaration, or a keyword refering to a number of reserved port names. Port expressions have the following form:

\begin{minip}
\begin{grammar}
<port-expression> ::= <port-id>
\alt <input-port-expression>
\alt <input-physical-port-expression>
\alt <egress-port-expression>
\alt <all-port-expr>
\alt <reflow-port-expr>

<input-port-expression> ::= "in_port"

<input-physical-port-expression> ::= "in_phys_port"

<egress-port-expression> ::= "egress"

<all-port-expression> ::= "all"

<reflow-port-expression> ::= "reflow"
\end{grammar}
\end{minip} 

The \grdd{input}{port}{expression} shall evaluate to the port which the current packet entered the network on. It must occur within the scope of a decoder, table, or event because these are the only entities which operate on packets.

The \grddd{input}{physical}{port}{expression} shall evaluate to the physical port which the current packet entered on. It must occur within the scope of a decoder, table, or event because these are the only entities which operate on packets.

The \grdd{egress}{port}{expression} shall evaluate the egress port property set in a flow entry's properties block (see \ref{guide:tables}). It shall only occur in the body of a flow entry whose egress property has been set.

The \grdd{all}{port}{expression} shall evaluate to the all port. The all port is a logical port which represents every port on the system.

The \grdd{reflow}{port}{expression} shall evaluate to the reflow port. The reflow port is a logical port which represent re-entry into the pipeline. When output to this port, a packet's context data is reset and the packet is sent back to the beginning of the pipeline.

\section{Literal Expressions} \label{guide:literal_expr}

Literal expressions are expressions which represent constant values. Steve supports decimal integer, binary, hexadecimal, character, and string literals.

Integer, binary and hexadecimal literals have the following form:

\begin{minip}
\begin{grammar}
<literal-expression> ::=
<integer-literal>
\alt <binary-literal>
\alt <hexadecimal-literal>

<decimal-digit> ::= \textbf{0} | \textbf{1} | \textbf{2} | \textbf{3} | \textbf{4} | \textbf{5} | \textbf{6} | \textbf{7} | \textbf{8} | \textbf{9}

<hexadecimal-digit> ::= \textbf{\_} | <decimal-digit> | \textbf{a} | \textbf{b} | \textbf{c} | \textbf{d} | \textbf{e} | \textbf{f}             

<binary-digit> ::= \textbf{\_} | \textbf{0} | \textbf{1}

<integer-literal> ::=
<decimal-digit> +

<hexadecimal-literal> ::=
\textbf{0x} <hexadecimal-digit> +

<binary-literal> ::=
\textbf{0b} <binary-digit> +
\end{grammar}
\end{minip}

Hexadecimal, binary, and integer literals may be used interchangeably to represent the same integer value. The type of an integer literal is by default 32-bit signed integer. Hexadecimal and binary literals may optionally use the underscore(\_) as an organizational separator. This is purely lexical and has no effect on the value of the literal. For example:

\begin{minip}
\begin{lstlisting}
10 // Integer literal 10
0b1010 // Binary literal 10
0b10_10 // Binary literal 10 w/ underscore
0x0A  // Hexadecimal literal 10
0x00_0A // Hexadecimal literal 10 w/ underscore  
\end{lstlisting}
\end{minip}

Binary literals have boolean type. They have the following form:

\begin{minip}
\begin{grammar}
<boolean-literal> ::= "true" | "false"
\end{grammar}
\end{minip}

Character and string literals are rarely if ever used in Steve at the moment. Its not common to need strings in a language directed towards packet processing, which is largely binary data. However, it may become useful in the future if Steve chooses to support text-based protocols. A character literal has character type. A string literal has character block type. Character and string literals have the following form:

\begin{minip}
\begin{grammar}
<character-literal> "\'" <letter> "\'"

<string-literal> ::= "\"" <letter> + "\""

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z"
\end{grammar}
\end{minip}

Character and string literals produce temporary objects. The content of these temporary objects gets copied if assigned to another object. For example:

\begin{minip}
\begin{lstlisting}
// A single character literal.
var c1 : char = 'a';
// A string literal.
var s1 : char[] = "Hello, world."; 
\end{lstlisting}
\end{minip}

\section{Unary Expressions} \label{guide:unary_expr}

Unary expressions have a single operator and a single operand. Unary expressions have the following form:

\begin{minip}
\begin{grammar}
<unary-expression> ::= 
<not-expression>
\alt <negative-expression>
\end{grammar}
\end{minip}

\subsection{Not Expression} \label{guide:not_expr}

The not expression is used to take the logical-not of a boolean value. The not expression has the form: 

\begin{minip}
\begin{grammar}
<not-expression> ::= "!" <expression> 
\end{grammar}
\end{minip}

The type of \gr{expression} shall be boolean type. If the value of \gr{expression} is \texttt{true}, the result shall be \texttt{false}. If the value of \gr{expression} is \texttt{false}, the result shall be \texttt{true}. The type of \grd{not}{expression} shall be boolean type.

\subsection{Negative Expression} \label{neg_expr_guide}

The negative expression is used to change the sign of an integer value. Negative expressions have the following form:

\begin{minip}
\begin{grammar}
<negative-expression> ::= "-" <expression>
\end{grammar}
\end{minip}

The type of \gr{expression} shall be signed integer type. The evaluation of this expression shall be the equivalent of multiplying the value of \gr{expression} by \texttt{-1}. The result type shall be signed integer type.

\section{Binary Expressions} \label{guide:binary_expr}

Binary expressions are expressions with a single operator and two operands. Binary expressions have the following form:

\begin{minip}
\begin{grammar}
<binary-expr> ::= <multiplicative-expression>
\alt <additive-expression>
\alt <bitshift-expression>
\alt <ordering-expression>
\alt <equality-expression>
\alt <bitwise-and-expression>
\alt <bitwise-xor-expression>
\alt <bitwise-or-expression>
\alt <logical-and-expression>
\alt <logical-or-expression>
\end{grammar}
\end{minip}

The precedence of each operator is enforced by the grammar. The operators with the highest precedence (i.e. the lowest number), get evaluated first when composed together. Operator precedence is as follows:

\begin{enumerate}
\singlespacing
\item Unary expressions
\item Multiplicative expressions
\item Additive expressions
\item Bit-shift expressions
\item Ordering expressions
\item Equality expressions
\item Bit-wise And
\item Bit-wise Xor
\item Bit-wise Or
\item Logical And
\item Logical Or
\end{enumerate}

\subsection{Multiplicative Expression} \label{guide:mult_expr}

Multiplicative expressions are multiplication, division, and modulo operators. They have the following form:

\begin{minip}
\begin{grammar}
<multiplicative-expression> ::= <multiplicative-expression> 
<mult-operator> <unary-expression>
\alt <unary-expression>

<multiplicative-operator> ::= "*" | "/" | "\%"
\end{grammar}
\end{minip}

Both operands must be of integer type. Integer conversion (see \ref{guide:int_conv}) is applied to both operands so that they both have type \texttt{T}, where T is the smallest possible integer type capable of representing both operands. The type of result shall be \texttt{T}. 

\subsection{Additive Expression} \label{guide:add_expr}

Additive expressions are addition and subtraction. They have the form: 

\begin{minip}
\begin{grammar}
<additive-expression> ::= <additive-expression> 
<add-operator> <multiplicative-expression>
\alt <multiplicative-expression>

<add-operator> ::= "+" | "-"
\end{grammar}
\end{minip}

Both operands must be of integer type. Integer conversion (see \ref{guide:int_conv}) is applied to both operands so that they both have type \texttt{T}, where T is the smallest possible integer type capable of representing both operands. The type of result shall be \texttt{T}.

\subsection{Bit-shift Expression} \label{guide:bitshift_expr}

The bit-shift expression allows the user to shift the bits of an integer either left or right. A bitshift expression has the following form:

\begin{minip}
\begin{grammar}
<bitshift-expression> ::= <bitshift-expression> 
<shift-operator> <additive-expression>
\alt <additive-expression>

<shift-operator> ::= "<<" | ">>"
\end{grammar}
\end{minip}

The bitshift expression will shift the bits in \grd{bitshift}{expression} to be shifted either left or right by the number of positions given by \grd{additive}{expression}. Bits shifted off the end shall be discarded. Bit positions that are vacated are filled with zeroes. The type of both operands shall be integer type. The type of the result shall be the type of \grd{bitshift}{expression}.

\subsection{Ordering and Equality Expression} \label{guide:ordering_expr}

Ordering expressions check whether or not the value of two operands are: less than, less than or equal, greater than, or greater than or equal. Equality expressions check whether or not the value of two operands are equal or not equal. The result is always \texttt{true} or \texttt{false}. These expressions have the form: 

\begin{minip}
\begin{grammar}
<ordering-expression> ::= <ordering-expression> 
<ordering-operator> <bitshift-expression>
\alt <bitshift-expression>

<ordering-operator> ::= "<" | "<=" | ">" | ">="

<equality-expression> ::= <equality-expression>
<equality-operator> <ordering-expression>
\alt <ordering-expression>

<equality-operator> ::= "==" | "!="
\end{grammar}
\end{minip}

Given a type \texttt{T}, assuming the type of the first operand is \texttt{T1}, and the type of the second is \texttt{T2}, there must exist a sequence of conversions from \texttt{T1} to \texttt{T} and from \texttt{T2} to \texttt{T}. In other words, the types of both operands must be convertible to some common type. The type of the result shall be boolean type.

\subsection{Bitwise And, Xor, and Or Expressions} \label{guide:bitwise_expr}

The bitwise expressions compares each bit of the first operand with each corresponding bit in the second operand and performs the appropriate bitwise operation.

\begin{minip}
\begin{grammar}
<bitwise-and-expression> ::= <bitwise-and-expression> "\&" <equality-expression>
\alt <equality-expression>

<bitwise-xor-expression> ::= <bitwise-xor-expression> "|" <bitwise-and-expression>
\alt <bitwise-and-expression>

<bitwise-or-expression> ::= <bitwise-or-expression> "^" <bitwise-xor-expression>
\alt <bitwise-xor-expression> 
\end{grammar}
\end{minip}

Given a type \texttt{T}, assuming the type of the first operand is \texttt{T1}, and the type of the second is \texttt{T2}, there must exist a sequence of conversions from \texttt{T1} to \texttt{T} and from \texttt{T2} to \texttt{T}. In other words, the types of both operands must be convertible to some common type. The type of the result shall be \texttt{T}.

With bitwise-and, for each bit position, if both bits are 1, then the result shall be 1, otherwise the resulting bit shall be 0. 

With bitwise-xor, for each bit position, if only one of the two bits is 1, then the result shall be 1, otherwise the resulting bit shall be 0.

With bitwise-or, for each bit position, if either bit is 1, then the result shall be 1, otherwise the resulting bit shall be 0.

\subsection{Logical And and Logical Or Expression} \label{guide:logical_expr}

Logical-and and Logical-or operations have the following form:

\begin{minip}
\begin{grammar}
<logical-and-expression> ::= <logical-and-expression> "\&\&" <bitwise-or-expression>
\alt <bitwise-or-expression>

<logical-or-expression> ::= <logical-and-expression> "||" <logical-and-expression>
\alt <logical-and-expression> 
\end{grammar}
\end{minip}

The type of both operands shall be boolean type. The result of shall have boolean type.

\section{Statements} \label{guide:statements}

Statements are pieces of code which are executed in sequence, and have some side-effects, but unlike expressions do not evaluate to any value or return any results. Statements generally only appear inside a block. Statements have the following form:

\begin{minip}
\begin{grammar}
<statement> ::=
<expression-statement>
\alt <declaration-statement>
\alt <block-statement>
\alt <assign-statement>
\alt <if-then-statement>
\alt <if-else-statement>
\alt <match-statement>
\alt <case-statement>
\alt <while-statement>
\alt <break-statement>
\alt <continue-statement>
\alt <return-statement>
\alt <action>
\end{grammar}
\end{minip}

\section{Expression Statement} \label{guide:expr_stmt}

An expression statement is a statement which executes a single expression. Expression statements have the following form:

\begin{minip}
\begin{grammar}
<expression-statement> ::=
<expression> ";"
\end{grammar}
\end{minip}

The \gr{expression} is executed and any return value it might have had is discarded. It may have had side effects on the program.

\section{Declaration Statement} \label{guide:decl_stmt}

A declaration statement introduces a declaration upon execution. Declaration statements have the following form:

\begin{minip}
\begin{grammar}
<declaration-statement> ::=
<declaration> ";"
\end{grammar}
\end{minip}

Because a statement generally only appears in a block, global declarations (see \ref{guide:declarations}) may not appear in declaration statements. 

\section{Block Statement} \label{guide:block_stmt}

Block statements are a subsection of program text which begins with the right-curly brace (\{) and ends with the left-curly brace (\}). Block statements have the form:

\begin{minip}
\begin{grammar}
<block-statement> ::=
"{" [<statement>] "}"
\end{grammar}
\end{minip}

A block statement defines a block scope (see \ref{guide:block_scope}). Block statements may be nested. A block statement may contain no statements. Each statement in a block statement is executed in order.

\section{Assignment Statements} \label{guide:assign_stmt}

Assignment statements allow the contents of one object to be replaced with the contents of another. Assignment statements have the following form:

\begin{minip}
\begin{grammar}
<assign-statement> ::=
<identifier-expression> "=" <expression> ";"
\end{grammar}
\end{minip}

The \grd{identifier}{expression} must refer to a valid object declaration. That object must be \textit{assignable}. Only variables and ports are assignable. When an assignment statement is executed, the contents of \gr{expression} shall be copied into that object.

Assuming the object referenced by \grd{identifier}{expression} has type \texttt{T}, then the type of \grd{identifier}{expression} must be \texttt{T\&} type and the type of \gr{expression} must by \texttt{T}.

\section{Conditional Statements} \label{guide:condition_stmt}

Conditional statements allow for branches in statement execution based on a condition only know during runtime. Steve supports three conditional statements: if-statement, if-else statement, and the match statement.

If and if-else statements have the following form:

\begin{minip}
\begin{grammar}
<if-statement> ::= "if" "("<expression>")" <statement>

<if-else-statement> ::= "if" "("<expression>")" <statement> "else" <statement>
\end{grammar}
\end{minip}

The type of \gr{expression} in an \grd{if}{statement} shall be boolean. If the \gr{expression} in the \grd{if}{statement} evaluates to \texttt{true}, then the \gr{statement} is executed, otherwise it is not executed. 

For an \grdd{if}{else}{statement}, if the \gr{expression} evaluates to \texttt{true}, then the first \gr{statement} is executed, otherwise the \gr{statement} following \texttt{else} is executed.

Match statements are similar to C-like switch statements. They have the form:

\begin{minip}
\begin{grammar}
<match-statement> ::= "match" "("<expression>")" <match-body>

<match-body> ::= "{"<case-statement> +"}"

<case-statement> ::= <case-label> ":" <case-body>

<case-label> ::= 
"case" <literal-expression> ":"
\alt "miss" ":"

<case-body> ::= <statement> 
\end{grammar}
\end{minip}

Match statements do \textit{not} have fall-through behavior unlike C-like switch statements. The \gr{expression} in \grd{match}{statement} is evaluated and if the value is equal to the value of a \grd{literal}{expression} in one of its \grd{case}{labels}, then the \grd{case}{body} is executed to completion and control branches to the statement immediately following the match statement.

The type, \texttt{T}, of \gr{expression} in \grd{match}{statement} shall be integer. The type of \grd{literal}{expression} in all contained \grd{case}{statements} shall also be \texttt{T}.

\section{While Loops} \label{guide:while_stmt}

While loops work in the same way as all C-like languages. They have the following form:

\begin{minip}
\begin{grammar}
<while-statement> ::= "while" "("<expression>")" <statement>
\end{grammar}
\end{minip}

The type of \gr{expression} shall be boolean. While \gr{expression} evaluates to \texttt{true}, \gr{statement} shall be executed. 

\subsection{Break and Continue} \label{guide:break_continue}

A break statement can be used to exit a loop prematurely. When a break statement is executed, the program branches to and executes the statement immediately following the while statement.

A continue statement can be used to branch to the first statement in the while loop if \gr{statement} is a block statement. 

These have the following form:

\begin{minip}
\begin{grammar}
<break-statement> ::= "break" ";"

<continue-statement> ::= "continue" ";"
\end{grammar}
\end{minip}

Break and continue may only appear in certain contexts. As of now, they may only appear within a while statement.

\section{Return Statement} \label{guide:return_stmt}

A return statement is used to return a value from a function. It has the following form:

\begin{minip}
\begin{grammar}
<return-statement> ::= "return" <expression>
\end{grammar}
\end{minip}

Return statements may only appear within a function body. The \gr{expression} gets evaluated and a copy of its value is returned to the caller. The type of \gr{expression} shall be the same as the function's return type, or there shall be a sequence of conversions to the return type.

\section{Actions} \label{guide:action}

An action is a special statement that may affect the state of a packet, its context, or a table. Because actions are specific to packet handling, an action may only appear in the body of a decoder, event, or flow entry. Steve supports a limited number of actions which can be expanded in the future. Actions have the following form:

\begin{minip}
\begin{grammar}
<action-stmt> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <flood-action>
\alt <drop-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>
\end{grammar}
\end{minip}


\section{Decode Action} \label{guide:decode_action}

The decode action is a stage transitioning action. A decode action transitions the context (see \ref{guide:context}) its working on from the current stage (which may be a decoder, table, or event) to a new decoding stage. A decode action has the following form:

\begin{minip}
\begin{grammar}
<decode-action> ::=
"decode" <decoder-id> [<advance-clause>] ";"

<advance-clause> ::= "advance" <expression>
\end{grammar}
\end{minip}

A decode action transfers control of the context it is operating on to the decoder named by \grd{decoder}{id}. The semantics of transfering control are similar to calling a function and passing the context as a parameter. If a decode action appears within the body of a decoder (see \ref{guide:decoder}), then a view advance (see \ref{guide:decoder_view}) is applied before the decode action transfers control to the next stage.

A decode action may optionally have an \grd{advance}{clause}, if and only if it occurs with the body of a decoder. In this case, \gr{expression} is first evaluated. The type of \gr{expression} must be unsigned integer or there must exist a conversion to unsigned integer. The advance clause results in the decoder view being shifted by \texttt{N} bytes where \texttt{N} is the result of evaluating \gr{expression}. The reason the shift is by bytes and not by bits is because generally speaking, headers are word aligned, and thus also byte aligned.

\section{Goto Action} \label{guide:goto}

The goto action is a stage transition action, similar to the decode action. A goto action transitions the context (see \ref{guide:context}) its working on from the current stage (which may be a decoder, table, or event) to a new table matching stage.

\begin{minip}
\begin{grammar}
<goto-action> ::=
"goto" <table-id> [<advance-clause>] ";"

<advance-clause> ::= "advance" <expression>
\end{grammar}
\end{minip}

A goto action transfers control of the context it is operating on to the table matching stage referred to by \grd{table}{id}. If a goto action appears within the body of a decoder (see \ref{guide:decoder}), then a view advance (see \ref{guide:decoder_view}) is applied before transfering to the table matching stage. After the advance, the context is dispatched the runtime (see \ref{ch:flowpath}) which composes the query key from extracted fields. They query key is then matched against flow entry match fields. All matching flow entries are collected. The one with the highest priority is executed. Because Steve currently only supports exact match tables, there will only ever be one match. The body of the flow entry, which is a sequence of actions, is executed in order. This body may include another stage transitioning action.

A goto action may optionally have an \grd{advance}{clause}, if and only if it occurs with the body of a decoder. In this case, \gr{expression} is first evaluated. The type of \gr{expression} must be unsigned integer or there must exist a conversion to unsigned integer. The advance clause results in the decoder view being shifted by \texttt{N} bytes where \texttt{N} is the result of evaluating \gr{expression}. The reason the shift is by bytes and not by bits is because, generally speaking, headers are word aligned, and thus also byte aligned.

\section{Output Action} \label{guide:output}

An output action forwards a copy of the packet to the designated port. Output actions have the following form:

\begin{minip}
\begin{grammar}
<output-action> ::= "output" <port-expression> ";"
\end{grammar}
\end{minip}

When an output action is executed, control of the packet is returned to the runtime (see \ref{ch:flowpath}) which creates a copy of the packet. The copy is forwarded by the runtime through the port given by \grd{port}{expression}. This may be a reserved port such as \texttt{all} or \texttt{reflow}, or it may be an identifier refering to a declared port (see \ref{guide:port}).

If destination is the \texttt{all} port, copies of the packet are sent on all known ports on the system. If the destination is the \texttt{reflow} port, then the runtime will send a copy of the packet back to the beginning of the pipeline. If the destination is a specific port, the copy is forwarded on that port. After this completes, pipeline processing continues on the original packet.

The output semantics here are a little unintuitive. Some may have the expectation that outputting a packet terminates pipeline processing and immediately forwards the original. This is not the case. Pipeline processing only terminates on the original packet if a stage does not send it to another stage, and does not apply any more actions to it. At this point egress processing (see \ref{egress_process}) would begin. The original packet is forwarded to the port specified by an output action written to the context's action set via write action (see \ref{guide:write}).

\section{Flood Action} \label{guide:flood}

The flood action forwards a copy of the packet to all ports except its ingress port. Flood actions have the form:

\begin{minip}
\begin{grammar}
<flood-action> ::= "flood" ";"
\end{grammar}
\end{minip}

When a flood action is executed, control of the packet is returned to the runtime (see \ref{ch:flowpath}) which creates copies of the packet. The copies are forwarded by the runtime through every port on the system other than the packet's ingress port.

\section{Drop Action} \label{guide:drop}

The drop action is used to delete the packet and immediately terminate pipeline processing. The drop action has the following form:

\begin{minip}
\begin{grammar}
<drop-action> ::= "drop" ";"
\end{grammar}
\end{minip}

The drop action is implicitly applied to any packet who has reached egress processing (see \ref{egress_process}), but which does not have an output action (see \ref{guide:output}) written to its action set via write action (see \ref{guide:write}).

\section{Clear Action} \label{guide:clear}

A clear action removes all actions from the context's action set. If the action set is empty, nothing is done. The clear action has the following form:

\begin{minip}
\begin{grammar}
<clear-action> ::= "clear" ";"
\end{grammar}
\end{minip}

\section{Set Action} \label{guide:set_field}

A set action copies a given value into a given field. The set action has the following form:

\begin{minip}
\begin{grammar}
<set-action> ::= "set" <field-access-expr> "=" <expression>
\end{grammar}
\end{minip}

When a set action is executed, the location and length of the field referred to by \grdd{field}{access}{expression} are discovered. The \gr{expression} is evaluated. The value of the result is copied into the packet at the discovered location. The value must have a binary representation whose length does not exceed the discovered length. 

If \grdd{field}{access}{expression} has type \texttt{T\&}, then \gr{expression} shall have type \texttt{T}, or there shall exist a conversion sequence from its type to \texttt{T}. This prevents the length of the value from exceeding the length of the field.

\section{Insert Action} \label{guide:insert_flow}

An insert action will add a new flow entry into a table. An insert action may also be used to update an existing flow entry into a table. Insert actions have the following form:

\begin{minip}
\begin{grammar}
<insert-action> ::= "insert" <flow-declaration> "into" <table-id>
\end{grammar}
\end{minip}

When an insert action is executed, the flow entry given by \grd{flow}{declaration} is inserted into the table referred to by \grd{table}{id}. Each \grd{match}{field} given in \grdd{match}{field}{sequence} is evaluated. The number and type of each \grd{match}{field} must match the number and type of each \grd{key}{field} in the table. Type conversions may be applied to the types to make them match. The flow entry is inserted into the table after each \grd{match}{field} has been evaluated. If a flow entry already present in that table has the same match fields as the flow entry being inserted, then the prior flow entry is replaced with the new one. All properties of the old flow entry are replaced with the properties of the inserted flow entry. If no properties are given in the inserted flow entry, the properties are the default values (no timeout and no egress port).

A miss case flow entry may be given as \grd{flow}{declaration}. The same insertion semanitcs apply here as well.

\section{Remove Action} \label{guide:remove_flow}

A remove action will remove an existing flow entry from a table. Remove actions have the following form:

\begin{minip}
\begin{grammar}
<remove-action> ::= "remove" <match-field-sequence> "from" <table-id>
\alt <remove-miss-action>
\end{grammar}
\end{minip}

When a remove action is executed, each \grd{match}{field} in \grdd{match}{field}{sequence} is evaluated. The table referred to by \gr{table}{id} is searched for all flow entries whose \grd{match}{field}{sequence} is the same. All flow entries found are removed from the table. If none are found, nothing is done.

Miss case flow entries may also be removed from a table. Miss case removal has the form: 

\begin{minip}
\begin{grammar}
<remove-miss-action> ::= "remove" "miss" "from" <table-id>
\end{grammar}
\end{minip}

When a miss case is removed, it is replaced by the default miss case. The default miss case has no timeout and no egress port. Its body has exactly one action; the drop action. If a table only contains a default flow entry, then nothing is done.

\section{Write Action} \label{guide:write}

A write action writes another action to the context's action set. Write actions have the form:

\begin{minip}
\begin{grammar}
<write-action> ::= "write" <action-stmt> ";"
\end{grammar}
\end{minip}

All actions written to the context's are executed upon egress processing in the order with which they were written. Written actions may have different semantics when executed during egress processing. Not all actions can be written. The actions which are writable may expand in later versions. The following are writable actions and their semantics during egress processing:

\begin{itemize}
\item \textit{Set}. The set action performs the same way it would if executed immediately (see \ref{guide:write}). 

\item \textit{Output}. The output action here sets the output port field in the context. It does not immediately forward the packet upon execution. When every action in the action set is completed, the original packet is forwarded (not a copy).
\end{itemize}

\section{Raise Action} \label{guide:raise}

A raise action is used to raise an event which gets executed on the controller port. The raise action has the form:

\begin{minip}
\begin{grammar}
<raise-action> ::= "raise" <event-id> ";"
\end{grammar}
\end{minip}

When executed, the runtime (see \ref{ch:flowpath}) will create a message containing the context and the event handler function. This message is sent to the controller port. On the controller port sits a separate process which waits to receive contexts and event handlers. That process shall execute the event handler, passing in the context as the argument. This action may be taken synchronously or asynchronously. The choice is runtime implementation specific.

