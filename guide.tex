\chapter{The Steve Reference Guide} \label{ch:users_guide}

This chapter serves as a reference manual for Steve programmers. It should be used as a reference rather than being read
through. It provides detailed descriptions of Steve language semantics: how features work, type checking, grammar, conventional and illegal uses, etc. It also describes how pipeline safety guarantees are enforced, what constitutes a legal pipeline, and potential pitfalls a programmer might fall into when writing a pipeline.
There is an expectation that the user has read the Tutorial and has a basic understanding of Steve.

Grammar in this section is given in Backus-Naur Form (BNF). All non-terminals are given between \texttt{< >}. All terminals appear in mono-spaced font. All optional grammar items are given between \texttt{[ ]}. Grammar items followed by a \texttt{+} indicate that 0 or more of that item may be present. All identifiers are suffixed with \texttt{\textit{-id}} and all names given to declarations are suffixed with \texttt{\textit{-name}}.

\section{Identifiers} \label{guide:identifiers}

An \textit{identifier} is an arbitrarily long sequence of characters. Supported characters include uppercase Latin letters (\texttt{A - Z}), lowercase Latin letters (\texttt{a - z}), digits (\texttt{0 - 9}), and underscores (\_). A valid identifier must begin with a non-digit character. Identifiers are case sensitive. The grammar of identifiers is as follows:

\begin{minip}
\begin{grammar}
<identifier> ::= <letter><identifier-characters>+

<identifier-character> :: <letter>
\alt <digit>
\alt "_"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z"

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
\end{grammar}
\end{minip}

Identifiers are subject to the following limitations:

\begin{itemize}
\item Identifiers which are keywords cannot be used for other purposes (see Section \ref{guide:keyword}).

\item Identifiers beginning with double underscores (\_\_) or an underscore followed by a capital letter (ex. \_F) are reserved by the compiler for internal identifiers.
\end{itemize}

Identifiers can be used as \textit{names} for \textit{entities}. An entity is a value, object, reference, function, layout, layout field, decoder, table, flow entry, port, event, or extraction. In the Steve grammar, identifiers being used as names for a kind of declarations shall have the form \grd{kind}{name}, where \texttt{\textit{kind}} shall be the declaration kind. For example, a decoder name would be represented in the grammar as \grd{decoder}{name}.

Identifiers that refer to a variable, function, decoder, table, or port can be used as an expression. In this case, the identifier becomes an \textit{identifier expression} (see \ref{guide:id_expr}). In the Steve grammar, identifier expressions shall have the form \grd{kind}{id}, where \texttt{\textit{kind}} shall be the declaration kind. For example, an identifier to a variable would be represented in the grammar as \grd{variable}{id}.

\subsection{Keywords} \label{guide:keyword}

A number of identifiers in Steve are reserved as \textit{keywords}. The meaning and semantics of these identifiers cannot be changed. A list of Steve keywords can be found in Table \ref{fg:keywords_table}.

\begin{table} [ht]
\caption{Steve reserved keywords. Note that Steve reserves the right to make any identifiers keywords in future versions.}
\label{fg:keywords_table}
\ttfamily
\begin{tabularx}{\textwidth\noindent}{@{\extracolsep{\fill}} l l l l l}
bool   & break   & char    & continue & def  \\
if     & else    & foreign & int      & uint \\
return & struct  & this    & var      & while \\
match  & case    & layout  & decoder  & decode \\
start  & extract & as      & exact\_table & requires \\
miss   & Port    & goto    & output   & write \\
drop   & flood   & clear   & set      & insert \\
remove & into    & from    & event    & raise \\
in\_port & in\_phys\_port & all & controller & reflow \\
advance & egress & struct & char
\end{tabularx}
\end{table}

\section{Field Names} \label{guide:field_name}

\textit{Field names} are special, \textit{qualified} names which refer to field declarations made within a layout declaration (see \ref{guide:layout}). Field names have the form:

\begin{minip}
\begin{grammar}
<field-name> ::=
<layout-id> \textit{.} <field-id>
\alt <field-name> \textit{.} <field-id>
\end{grammar}
\end{minip}

Given a field name of the form \texttt{E1.E2}, if \texttt{E1} is a valid identifier to a layout declaration, then \texttt{E2} must be a field of \texttt{E1}. In other words, \texttt{E2} must be found in the scope of \texttt{E1} using a qualified name lookup (see \ref{guide:qlfd_lookup}).

If \texttt{E1} is a valid field name, and the referred to field has type \texttt{T}, then \texttt{T} must be layout type (see \ref{guide:layout_type}) declared by a layout declaration (see \ref{guide:layout}), \texttt{D}. \texttt{E2} must identify a field of \texttt{D}.  In other words, \texttt{E2} must be found in the scope of \texttt{D} using qualified name lookup.

\texttt{E1} is referred to as the \textit{container} and \texttt{E2} is referred to as the \textit{contained field}. The \textit{root layout identifier} is used to mean the leftmost identifier in a field name. For example, in \texttt{l1.f1.f2.f3}, \texttt{l1} is the root layout identifier.

Field names used as expressions become \textit{field access expressions} (see \ref{guide:field_access_expr}). Field access expressions may be used to refer to the value of the last extraction with that field name.

\section{Scope} \label{guide:scope}

Steve scope semantics work like all C-based block-structured languages (including C++, Java, C\#, etc). 
\textit{Declarations} are used throughout program text to introduce \textit{names} which refer to an entity (see \ref{guide:identifiers}). 

A \textit{name} is only \textit{valid} within parts of program text called the \textit{scope} of that name. A particular name is only considered valid if an \textit{entity} with that name can be found using an \textit{unqualified name lookup} (see \ref{guide:unqlfd_lookup}).

\subsection{Global Scope} \label{guide:global_scope}

The outermost part of program text where declarations can be made is known as \textit{global scope}. All declarations made at global scope are said to be \textit{global declarations} and their names are said to be \textit{global names}.

Global names are valid at any point in the program. Steve does not require forward declarations. Two declarations of the same name that are not overloaded functions shall not be made at global scope.

\subsection{Block Scope} \label{guide:block_scope}

Blocks are portions of program text which can have their own local declarations. The beginning of a block is delimited by the left-brace (\{) and the end of a block is delimited by the right-brace (\}). Blocks define a block scope which limits the scope of declarations made within them. A declaration made within a block is in \textit{block scope} and is \textit{local} to that block.

The scope of a name made within a block begins at the point of declaration and ends at the final left-brace of the block. It is illegal to use the name of a declaration in local scope at a textual position before its declaration.
Two different declarations of the same name cannot be made inside the same scope.

Scopes can be nested. In this case, the inner scope is said to be the \textit{enclosed} scope, and the outer scope is said to be the \textit{enclosing} scope. The same name can be declared in the enclosing scope, and again in one or more enclosed scopes. The same is true for further nested scopes within the enclosed scope. If this happens, the scope of the outer declaration is its typical scope excluding program text of the enclosed scope. Unqualified name lookup (see \ref{guide:unqlfd_lookup}) shall be used to unambiguously determine which declaration the name refers to.

For example, in the following example, the name \texttt{i} is declared twice. The scope of the first \texttt{i} is global scope and includes the entire example excluding the block between the first left-brace (\texttt{\{}) and the closing right-brace (\texttt{\}}). The scope of the second \texttt{i} begins at its declaration and ends at the the closing right-brace (\texttt{\}})

\begin{lstlisting}
var i : int = 0;
def f() -> int {
	var i : int = 1;
	var j : int = 2 + i;
	return j; // Result here shall be 3.
}
\end{lstlisting}

The body of \texttt{if}, \texttt{while}, and \texttt{match} statements all implicitly introduce a block.

\subsection{Function Scope} \label{guide:function_scope}

The scope of a parameter declared in a \grd{function}{declaration} (see \ref{guide:function}) is the function's \grd{block}{statement}.

\subsection{Table Scope} \label{guide:table_scope}

A name is said to be in table scope if its scope is within the \grd{table}{initializer} of a \grd{table}{declaration} (see \ref{guide:tables}). The scope of field names declared by a \grd{key}{declaration} within \grdd{key}{declaration}{sequence} and field names listed in the \grd{requires}{specifier} is the \grd{table}{initializer}.

The field name refers to the \textit{last} extraction made with that field name. This entity may vary during runtime depending on the path through the pipeline which a packet took. Because of memory safety (see \ref{guide:requirements}), it is always guaranteed that an entity with that name exists.

\subsection{Flow Scope} \label{guide:flow_scope}

A name is said to be in \textit{flow entry scope} if its scope is within the \grd{flow}{body} of a \grd{flow}{declaration} (see \ref{guide:tables}). If a \grd{flow}{declaration} appears within a \grd{table}{initializer}, then all field names whose scope is \grd{table}{initializer} are valid within the flow entry's body.

If a flow entry is being inserted into a table using the \grd{insert}{action} (see \ref{guide:insert_flow}), then a flow declaration is implicitly generated representing that flow entry. The \grd{flow}{body} of that declaration is treated as if it were within that table's \grd{table}{initializer}. This ensures that the field names valid within that table are valid within the inserted flow entry's body.

Names found in the \grd{properties}{block} of an inserted flow entry follow regular scope semantics. That is, all names which are normally valid at the point where the \grd{properties}{block} appears in the program text are valid inside the \grd{properties}{block}. However, these names may not be valid for the \grd{flow}{body} in the case of an \grd{insert}{action}.

In the following example, the name \texttt{x} is valid in the properties block, but not in the body of the flow.

\begin{lstlisting}
event e1 {
	var x : int = 100;
	insert into t1
	{ x } -> // 'x' is valid here.
	[timeout = x] // 'x' is also valid here.
	{
		// Error: The name 'x' is not valid here.
		set eth.type = x + 1;
		// However, the field name 'eth.type' is valid
		// because the flow body is treated as if nested
		// inside the scope of table 't1', whose key declaration
		// 'eth.type' makes the field name valid.
		flood;
	};
}

exact_table t1(eth.type) { }
\end{lstlisting}

\subsection{Event Scope} \label{guide:event_scope}

The scope of names declared in the \grd{block}{statement} of an \grd{event}{declaration} follow regular block scope semantics (see \ref{guide:block_scope}). The scope of field names given by the \grd{requires}{specifier} is also that \grd{block}{statement}.

\subsection{Layout Scope} \label{guide:layout_scope}

The scope of a field declared within a layout is the \grd{layout}{body} of the containing \grd{layout}{declaration} (see \ref{guide:layout}). This name is valid in the following circumstances:

\begin{itemize}
\item Inside the \grd{layout}{body}.

\item After the dot-operator (\texttt{.}) applied to the name of its containing layout as part of either a field name (see \ref{guide:field_name}) or a field access expression (see \ref{guide:field_access_expr}).

\item After the dot-operator (\texttt{.}) applied to either a field name (see \ref{guide:field_name}) or a field access expression (see \ref{guide:field_access_expr}).
\end{itemize}

\subsection{Unqualified Name Lookup} \label{guide:unqlfd_lookup}

Unqualified name lookup attempts to find the corresponding declaration for a name being used. Unqualified name lookup begins at the innermost scope, before the name is used and works outward toward enclosing scopes. If the declaration is not found in any enclosing scopes, global scope is searched. The innermost declaration (e.g. the first one found) with that name is considered the corresponding declaration.

A name must be declared before being used. Any attempts to use a name before its declaration shall result in a failed unqualified name lookup. If unqualified lookup fails to find a corresponding declaration, the a compiler error is produced.

If the name refers to one or more function declarations, and is being used as a function call, an \textit{overload set} is associated with the name. If this is the case, \textit{argument dependent lookup} determines which declaration is being referred to. The function declaration chosen shall be the one whose parameter types match the argument types used in the function call.

Global names used at any point are considered valid regardless of the order with which they are declared in the program text. For example, the following usage of the name \texttt{i} in function \texttt{foo} refers to a variable declaration made after the function declaration. This is considered valid.

\begin{lstlisting}
// The name 'i' is used even though it is declared later
// in global scope.
def foo() -> int { return 3 + i; }
// The name 'i' is declared here.
var i : int = 0;
\end{lstlisting}

\subsection{Qualified Name Lookup} \label{guide:qlfd_lookup}

Qualified name lookup attempts to find the corresponding declaration for a name in a given scope. The search is done only on the given scope before the usage of the name and does not expand outward to enclosing scopes.

Qualified name lookup is used for looking up names following the dot-operator in field names (see \ref{guide:field_name}) and field access expressions (see \ref{guide:field_access_expr}).

If qualified lookup fails to find a corresponding declaration, the result is a compiler error.

\section{Objects} \label{guide:object}

An \textit{object} in a Steve program is an area of memory that has size, lifetime, type, and value. An object may also be given a name.
Variables, extractions, ports, tables, and temporaries are objects. Objects are created in Steve by variable, extract, port, and table declarations (see \ref{guide:variables}, \ref{guide:extract}, \ref{guide:port}, \ref{guide:tables}). Objects may be created where temporary values are required. For example, the evaluation of expressions such as addition (see \ref{guide:add_expr}) produce temporary objects.

\subsection{Storage Duration and Lifetime} \label{guide:storage}

The \textit{storage duration} of an object describes the point where an object's memory is allocated and the point where its memory is deallocated.

\begin{itemize}
\item \textit{Automatic}. Automatic storage duration says that an object is allocated at the beginning of the code block where it is declared and deallocated at the end of a code block. Global entities (such as tables, ports, and global variables) and local variables have automatic storage. 

\item \textit{Pipeline automatic}. Pipeline automatic storage duration is a property of the context object (see \ref{guide:context}). Upon packet ingress, the context is allocated, upon egress the context is deallocated. The memory associated with extracted fields, which are part of the packet, exist before they have actually been extracted, and thus have the same storage duration.
\end{itemize}

The \textit{lifetime} of an object is less than or equal to its storage duration.

\begin{itemize}
\item \textit{Automatic}. Automatic lifetime begins at the point where an object is \textit{initialized} and ends at the point where an object is de-initialized (which is currently equivalent to the end of the block).

\item \textit{Pipeline automatic}. Pipeline automatic lifetime is equivalent to pipeline automatic storage duration for contexts. The lifetime of an extracted field can be thought of as being from the point where its position is found (decoded) to the point where the context's storage duration ends.
\end{itemize}

\section{Context Data Structure} \label{guide:context}

The storage duration and lifetime of a context is said to be \textit{pipeline automatic} (see \ref{guide:storage}). Management of the context's memory is exclusively and automatically handled by internal mechanics of the runtime system. This object is used exclusively by the internals of the program to keep track of information about a packet. It is also important to note that the packet itself is also a part of the context. Any point where "the context" is referred to, it is implied to mean both the packet and context.

A user is never given direct access to a context. Context objects are implicit, yet invisible, within all pipeline processing stages (decoders, tables, and events). They serve to carry data as input and output between stages. Certain expressions, declarations, and actions might access, modify, or otherwise affect the data of the context in limited and well-defined ways.

\begin{itemize}
\item Expressions which access a context are: field access expressions (see \ref{guide:field_access_expr}), ingress port expression, and ingress physical port expression (see \ref{guide:port_expr}).

\item Declarations which modify a context are: extract declarations (see \ref{guide:extract}) and rebind declarations (see \ref{guide:rebind}).

\item All actions (see \ref{guide:action}) will affect the context in some way.
\end{itemize}

\section{Type} \label{guide:type}

Types are a way of describing objects, references, expressions, fields, and functions. Types can describe size, structure, and limitations on possible values and legal operations for these entities. By giving types to these things, it allows the compiler to reason about limitations on where terms may appear. Steve is a strongly-typed language. Therefore, the types of all things are known during compile time. 

Steve supports scalar types (see \ref{guide:scalar_type}), reference types (see \ref{guide:ref_type}), layout type (see \ref{guide:layout_type}), port type (see \ref{guide:port_type}), and function type (see \ref{guide:function_type}). Types may appear as terms in language to specify the type of variables, parameters, return values, and layout fields. At other points, the type of an entity may be implicit. For example, the type of an additive expression (see \ref{guide:add_expr}) is implicitly integer.
Types have the form:

\begin{minip}
\begin{grammar}
<type> ::=
<scalar-type>
\alt <reference-type>
\alt <function-type>
\alt <layout-type>
\alt <port-type>
\end{grammar}
\end{minip}

\subsection{Scalar Type} \label{guide:scalar_type}

Objects of scalar type represent exactly one value. They are not composed of multiple sub-objects. Steve supports the scalar types boolean, integer, and character. Scalar types have the form:

\begin{minip}
\begin{grammar}
<scalar-type> ::= <boolean-type>
\alt <integer-type>
\alt <character-type>
\end{grammar}
\end{minip}

\subsection{Boolean Type} \label{guide:bool_type}

Objects of boolean type may only have the values \texttt{true} and \texttt{false}. Objects of boolean type have a size of 8 bits. They have the form:

\begin{minip}
\begin{grammar}
<boolean-type> ::= "bool"
\end{grammar}
\end{minip}

\subsection{Integer Type} \label{guide:integer_type}

An integer type describes the size, precision, and signed/unsigned-ness of a given integer value. They have the form:

\begin{minip}
\begin{grammar}
<integer-type> ::= <signed-integer-type>
\alt <unsigned-integer-type>

<signed-integer-type> ::= "int" [ <precision-specifier> ]

<unsigned-integer-type> ::= "uint" [ <precision-specifier> ]

<precision-specifier> ::= "("<integer-literal>")"
\end{grammar}
\end{minip}

The precision of an integer is given by \grd{precision}{specifier}.
Precision is not always equivalent to size. The size of an integer is
always the next highest multiple of 8.
If \grd{precision}{specifier} is not given, the default precision and effective size shall be 32. For signed integers, the range of integers that can be represented is from $-2^{N-1}$ to $2^{N-1}-1$, where \textit{N} is the precision. For unsigned integers, the range of integers that can be represent is $0$ to $2^{N}-1$.

\subsection{Character Type} \label{guide:char_type}

Single characters have character type. Objects of this type have a size of 8 bits. It has the form: 

\begin{minip}
\begin{grammar}
<boolean-type> ::= "char"
\end{grammar}
\end{minip}

\subsection{Reference Type} \label{guide:ref_type}

Objects and expressions of reference type represent an address to an object.  Reference types have the form:

\begin{minip}
\begin{grammar}
<reference-type> ::= <type> "\&" 
\end{grammar}
\end{minip}

The type \texttt{T\&} is read as "reference-to-\texttt{T}," where \texttt{T} is the type of the referred to object.

Identifier expressions referring to variables have reference type. Field access expressions refer to extractions and thus have reference type.

For example, in the following, the variable \texttt{x} has type \texttt{int} and the identifier expression \texttt{x} would have type \texttt{T\&}.

\begin{lstlisting}

x; // This identifier expression has type ref T
// Used as a value, reference-to-value conversion
// is applied to x
var y : int = x + 10;
\end{lstlisting}

When an expression of type \texttt{T\&} appears on the right-hand side of an
assignment statement (see \ref{guide:assign_stmt}), a reference-to-value
conversion (see \ref{guide:reftoval_conv}) is applied to recover the value of the object.

Variables of reference type may be created. Assignment to that variable modifies the original object as well. For example:


\begin{lstlisting}
var y : int& = x; // y is a reference to x.
y = 5; // This modifies x as well, so now both are 5.
\end{lstlisting}

Here, any modifications to \texttt{y} have the same affect on \texttt{x}, because y only stores an address to the original object.

\subsection{Array Type} \label{guide:array_type}

An array type, \texttt{T[N]}, describes a region of contiguous memory containing \texttt{N} number of objects of type \texttt{T}. Array types have the form: 

\begin{minip}
\begin{grammar}
<array-type> ::= <type> "["<expression>"]"
\end{grammar}
\end{minip}

The type of \gr{expression} shall be integer. The evaluated value shall be a positive integer, otherwise behavior is undefined.

\subsection{Block Type} \label{guide:block_type}

A block type describes a region of contiguous memory containing an unknown number of objects of type \texttt{T}. Block type has the form:

\begin{minip}
\begin{grammar}
<block-type> ::= <type> "[" "]"
\end{grammar}
\end{minip}

Block type may be used when the length of an array is unknown during compile time. Block type is most frequently given to variables used to hold strings. For example:

\begin{lstlisting}
var str : char[] = "Hello, world";
\end{lstlisting}

\subsection{Layout Type} \label{guide:layout_type}

Layout types are declared via layout declarations (see \ref{guide:layout}). Layout types have the form:

\begin{minip}
\begin{grammar}
<layout-type> ::= <layout-id>
\end{grammar}
\end{minip}

Objects of layout type shall not exist. The \grd{layout}{type} may only appear as the type of a field declaration within a layout declaration (see \ref{guide:layout}). It may not appear in variable declarations or function declarations as such:

\begin{lstlisting}
layout L1 { f1 : uint; f2 : uint(16); }
var x : L1 = 0; // Invalid
// Invalid parameter type and return type.
def foo(y : L1) -> L1 { ... }
\end{lstlisting}

The size of a layout is equal to the sum of the sizes of each of its field types. This is only knowable at compile time if the layout contains only scalar typed fields. For example, the layout \texttt{L1} has a size of 48 bits or 6 bytes.

\subsection{Port Type} \label{guide:port_type}

All port declarations have port type. Port type is not a type that appears explicitly in the grammar. Variables, parameters, and fields may not have port type.

In certain cases, namely ordering and equality operators (see \ref{guide:ordering_expr}), an object of port type may be converted to an object of integer type. The value of the converted port object is equal to its system assigned integer identifier. This allows for the comparison of ports to integers as follows:

\begin{lstlisting}
Port p1;
// Comparison against 0 checks if the port is valid.
// The 0 port is the invalid port.
if (p1 == 0) { ... }
\end{lstlisting}

\subsection{Function Type} \label{guide:function_type}

Functions have function type. Function type describes the type of each parameter and the return type of the function. Function type can be written and has the form:

\begin{minip}
\begin{grammar}
<function-type> ::= "("<type-sequence>")" "->" <type>
\end{grammar}
\end{minip}

A function of type \texttt{(T1, T2, ..., Tn) -> T} has parameters of type \texttt{T1}, \texttt{T2}, ..., \texttt{Tn}, respectively, and a return type \texttt{T}.

\section{Conversions} \label{guide:conversions}

At certain points, the type of an expression may be implicitly converted to another type. A \textit{conversion sequence} applies conversions in turn until the original type has been converted to another target type.

\subsection{Reference to Value Conversion} \label{guide:reftoval_conv}

Given an assignment statement (see \ref{guide:assign_stmt}) \texttt{E1 = E2},
an expression of type \texttt{T\&} which can appear as \texttt{E1} or in \texttt{E2} is traditionally called an \textit{lvalue} in C/C++ \cite{cpp_std}. Lvalues are objects which persist past a single expression. These are typically identifiers which refer to non-temporary objects. Expressions which may only appear in \texttt{E2} are known as \textit{rvalues}. Rvalues do not persist past the expression which creates them such as: literals, arithmetic expressions, comparison expressions, etc.

When an lvalue of type \texttt{T\&} appears in \texttt{E2}, it must go through implicit reference to value conversion (also known as lvalue to rvalue conversion). The reference is replaced with the object it refers.

\begin{lstlisting}
var x : uint = 10;
// The reference to value conversion is
// implicitly applied on the identifier expression
// 'x' here.
var y : uint = x + 5;
\end{lstlisting}

\subsection{Integer Conversions} \label{guide:int_conv}

Steve will convert the precision and signed/unsigned-ness of integers where necessary. If an expression \texttt{E1} of type \texttt{T1} must be converted to an integer of type \texttt{T2}, the following conversions each get applied in order.

\begin{enumerate}
\item If \texttt{T1} is a signed integer and \texttt{T2} is an unsigned integer, then the type of \texttt{E1} is converted to an unsigned integer type with the same precision as \texttt{T1} (the original precision).

\item If the precision of \texttt{T1} is less than the precision of \texttt{T2}, then the type of \texttt{E1} is converted (promoted) to an integer type with the same precision as \texttt{T2}. The extra high-order bits are zero-filled if both are unsigned or sign-extended if both are signed.

\item If the precision of \texttt{T1} is greater than the precision of \texttt{T2}, then the type of \texttt{E1} is converted (demoted) to an integer type with the same precision as \texttt{T2}. The extra high-order bits are truncated.
\end{enumerate}

\subsection{Arithmetic Conversions} \label{guide:arith_conv}

In an arithmetic expression (see \ref{guide:mult_expr}, \ref{guide:add_expr}, \ref{guide:bitshift_expr}, \ref{guide:bitwise_expr}), the resulting integer type is decided based on the rules below. Given two operands, \texttt{E1} of type \texttt{T1} and \texttt{E2} of type \texttt{T2}, the resulting integer type:

\begin{enumerate}
\item has the same precision as the largest precision between \texttt{E1} and \texttt{E2}.

\item is unsigned if either \texttt{T1} or \texttt{T2} are unsigned. Otherwise, it is signed.
\end{enumerate}

\subsection{Port to Integer Conversions} \label{guide:port_conv}

In some cases, namely comparison and equality operators, a port expression (see \ref{guide:port_expr}) may be converted to have integer type. A port to integer conversion takes a port object and interprets its value to an integer value. The integer value is equal to the port object's system assigned ID number. Port objects which have not been initialized or are invalid have an integer value \texttt{0}.

For example, in the following case, a port to integer conversion is applied to expression \texttt{p1} to allow it to be compared with \texttt{0} (note that a reference-to-value conversion is actually applied first since \texttt{p1} is an identifier expression with reference-to-port type).

\begin{lstlisting}
Port p1; // Uninitialized port object.
def foo() -> bool {
	// Implicit port to integer conversion.
	if (p1 == 0)
		return true;
}
\end{lstlisting}


\section{Declarations} \label{guide:declarations}

Declarations, generally speaking, introduce an entity and a name for that entity. When using that name, the declaration is used to determine how to interpret that name. 

For example, a variable declaration (see \ref{guide:variables}) introduces a variable and a name for that variable. When the name for that variable is used in program text, it is used to mean the variable itself.

A \textit{definition} in Steve is equivalent to a declaration in all but one case. The only case where a definition is distinct from a definition is when the \texttt{foreign} specifier (see \ref{guide:foreign_spec}) is attached to an incomplete function declaration.
Declarations have the form:

\begin{minip}
\begin{grammar}
<declaration> ::=
[ <specifier-seq> ] <declaration>
\alt <global-declaration>
\alt <key-declaration>
\alt <extract-declaration>
\alt <rebind-declaration>
\alt <flow-declaration>
\alt <field-declaration>
\alt <parameter-declaration>
\alt <variable-declaration>

<global-declaration> :: =
<port-declaration>
\alt <layout-declaration>
\alt <decoder-declaration>
\alt <table-declaration>
\alt <event-declaration>
\alt <function-declaration>
\end{grammar}
\end{minip}

All declarations introduce a name into a scope. A layout, decoder, table, event, or function declaration must be made in global scope. These are known as \textit{global} declarations.

Declarations may have a number of specifiers (see \ref{guide:specifications}) attached to them, given by \grd{specifier}{seq}. Specifiers modify the semantics of declarations.
 
\subsection{Layout Declaration} \label{guide:layout}

Layout declarations are used to define the physical structure of packets in memory. A layout declaration declares a \textit{layout type}. Layout declarations have the following form:

\begin{minip}
\begin{grammar}
<layout-declaration> ::=
"layout" <layout-name> <layout-body>

<layout-body> ::=
"{"
	<field-declaration> +
"}"

<field-declaration> ::=
<field-name> ":" <type> ";"
\end{grammar}
\end{minip}

A field declaration \texttt{F : T} introduces the name \texttt{F} into layout scope. \texttt{T} must be of scalar type (see \ref{guide:scalar_type}) or layout type (see \ref{guide:layout_type}).
\footnote{Though \texttt{bool} and \texttt{char} are valid scalar types, they will result in a compiler error if the given field is needed as part of a table's key. This is a limitation that will be adjusted in later revisions.} The type \texttt{T} specifies the length of the field. Because this is the extent of the usage, there is no reason to support more complex user-defined types here.

Field declarations must occur in the order with which they appear in the an actual instance of a header which the layout represents. Incorrect ordering will result in incorrect extractions by decoders.

Though layout declarations declare layout types, objects of layout type can never be created and functions cannot have parameters or returns of layout type (see \ref{guide:layout_type}, \ref{guide:no_dst}). The following is not legal in Steve. 

\begin{lstlisting}
layout l1 { ... }
var x : l1; // Illegal.
def foo(x : l1) -> l1 { ... } // Illegal.
\end{lstlisting}

A layout type may only appear as the type of a field declaration in layout scope. This is to allow for handling of nested header structures.

\subsection{Decoder Declarations} \label{guide:decoder}

Decoder declarations have the following form:

\begin{minip}
\begin{grammar}
<decoder-declaration> ::=
\textit{decoder} <decoder-name> [ "start" ]
"("<layout-id> ")" 
<block-statement>
\end{grammar}
\end{minip}

The identifier given by \grd{layout}{id} must name a valid layout declaration at global scope. This \grd{layout}{id} is known as the \textit{layout rule} of the decoder. Different decoder declarations may use the same layout rule. The layout rule is used to determine the \textit{current view} and \textit{implicit advances} generated by a decoder (see \ref{guide:decoder_view}). Extract declarations (see \ref{guide:extract}) may only extract fields from this layout.

The optional \texttt{start} keyword shall occur on exactly one decoder declaration in a given program text. This decoder shall be considered the source (root) of the pipeline graph during pipeline checking. This decoder shall be the first decoder applied to a packet context after ingress.

The execution of a decoder is similar to that of a function. Each statement within \grd{block}{statement} is executed in turn.

%\subsection{Decoder View and Shifting} \label{guide:decoder_view}
%
%The \textit{current view} of a packet begins where the first byte of the header being decoded lies in memory. The end of the current view is found at the position of the beginning plus the length of the current header. For headers whose lengths can be determined during compile time using the layout rule, the current view is said to be \textit{statically-sized}. For headers whose lengths must be determined by operations performed at runtime, the current view is said to be \textit{dynamically-sized}.
%
%Steve uses this view mechanism to allow for partial decodes of headers. Without the ability to find fields relative to the beginning of views, decoding phases would be forced into full forward decoding, meaning for a field to be extracted, all fields prior to it would have to be extracted. This prevents us from receiving the gains of partial decode.
%
%Additionally, this means extractions cannot exceed the logical bounds of a single header. It is implicitly impossible to decode further than the final field in the layout rule.
%
%The context is used to maintain a positional index, known as the \textit{view index}, corresponding to the beginning of the current view. At first, this index begins at 0, corresponding to the first byte of the packet, and thus the first byte of the first header. Each decoder shifts the current view by the length of the current header before transitioning to the next stage, that is, the length of the current header is added to the view index upon the execution of a \texttt{decode} or a \texttt{goto} action (see \ref{guide:decode_action} \& \ref{guide:goto}).
%
%If the view is statically-sized, the shift shall be implicitly emitted as code by the compiler by using the layout rule. This is known as an \textit{implicit advance}.
%
%If the view is dynamically-sized, the length of the shift must be explicitly quantified using the \texttt{\color{blue}advance} specifier attached to either a \texttt{goto} (see \ref{guide:goto}) or \texttt{decode} action (see \ref{guide:decode_action}). This is known as an \textit{explicit advance}.

\subsection{Extract Declaration} \label{guide:extract}

An extract declaration causes a field with the specified field name (see \ref{guide:field_name}) to be extracted by the decoder. Extract declarations have the following form:

\begin{grammar}
<extract-declaration> ::=
"extract" <field-name> \textit{;}
\end{grammar}

After this declaration, the name and value of that field may be used in a \grdd{field}{access}{expression} (see \ref{guide:field_access_expr}).
An extract declaration must be in decoder scope. Attempting to put an extract declaration in any other context shall result in a compiler error.

The root layout identifier of \grd{field}{name} (see \ref{guide:field_name}) shall be the same layout as the decoder's \textit{layout rule} (see \ref{guide:decoder}). A decoder shall not extract fields from layouts which are not it's layout rule. For example, the following is illegal:

\begin{lstlisting}
// Error: Decoder does not extract ipv4.
decoder eth_d(eth) { extract ipv4.dst; }
\end{lstlisting}

\subsection{Rebind Declaration} \label{guide:rebind}

At certain times, it may be convenient to extract a certain field, but \textit{alias} that field with a different name than the original. This can be done with the \textit{extract-as} or \textit{rebind} declaration. A rebind declaration has the following form:

\begin{minip}
\begin{grammar}
<rebind-declaration> ::=
"extract" <field-name> "as" <field-name> ";"
\end{grammar}
\end{minip}

The rebind declaration has the form \texttt{extract N1 as N2} where \texttt{N1} and \texttt{N2} are field names.
\texttt{N1} is the \textit{original field name} and must refer to a field in the layout rule. \texttt{N2} is the \textit{alias field name} and may refer to any valid field. The types of \texttt{N1} and \texttt{N2} must be the same.

\subsection{Table and Flow Declarations} \label{guide:tables}

Table declarations have the following form:

\begin{minip}
\begin{grammar}
<table-declaration> ::=
"table" <table-name> "(" <key-declaration-sequence> ")"
[ <requires-specifier> ] <table-initializer>

<key-declaration> ::=
<layout-id> "." <field-id>
\alt <key-declaration> "." <field-id>
\alt "in_port"
\alt "in\_phys\_port"

<requires-specifier> ::=
"requires" "(" <field-name-sequence> ")"

<table-initializer> ::= "{" [ <flow-declaration-list> ] "}"

<flow-declaration-list> ::= <flow-declaration>
\alt <flow-declaration-list> <flow-declaration>
\end{grammar}
\end{minip}

Table declarations cause table objects to be created by the runtime system. After loading a Steve generated application, the runtime system (see \ref{ch:flowpath}) shall receive a number of table allocation requests from the Steve program corresponding to each table declaration. These requests are made as part of load-time configuration (see \ref{lifetime}). Each request shall provide:

\begin{itemize}
\item A table name.
\item The set of key fields that comprise the table's key.
\item A maximum number of flow entries.
\end{itemize}

If tables with those properties already exist, the runtime system provides the Steve application with the already existing table. This can happen if multiple Steve applications are run on the same device.

The table's \textit{key fields} are a set of one or more fields which together compose a \textit{key}. A table's key is given by \grdd{key}{declaration}{sequence} in the grammar. Each \grd{key}{declaration} shall be a valid field name, or be the keywords \texttt{in\_port} or \texttt{in\_phys\_port}. The type of \grd{key}{declaration} shall be the type of the field, or shall be port type (see \ref{guide:port_type}) in the case of \texttt{in\_port} or \texttt{in\_phys\_port}.

The \grd{requires}{specifier} is optional. A field name here may also be a \grd{key}{declaration}. This is redundant and does not change semantics. Field names given by \grdd{key}{declaration}{sequence} are implicitly required.

Names in \grdd{key}{declaration}{sequence} and \grd{requires}{specifier} are valid inside \grd{table}{initializer} based on table scope semantics (see \ref{guide:table_scope}).

Each table has a set of \textit{flow entries} declared in Steve using a flow declaration of the following form:

\begin{minip}
\begin{grammar}
<flow-declaration> ::=
<properties-block>
"{" <match-field-sequence> "}" "->" <flow-body>
\alt <miss-flow-declaration>

<match-field> ::= <expression>

<flow-body> ::= "{" <action>+ "}"

<properties-block> ::=
"[" <property-sequence> "]"

<property> ::=
<property-kind> "=" <expr>

<property-kind> ::=
"timeout"
\alt "egress"

<miss-flow-declaration> ::=
"miss ->" <flow-body>
\end{grammar}
\end{minip}

The match fields of a flow entry, that is, values corresponding to a table's key fields, is given by \grdd{match}{field}{sequence}. The type of each \grd{match}{field} must be the same type as its corresponding \grd{key}{declaration}. The number of match fields must be equal to the number of key fields.

All flow entries in the same table must be uniquely identifiable by their \textit{match fields} and their \textit{priority} (since Steve only support exact match tables, the priority is the same on all flow entries). If a flow entry being inserted into a table has the same match fields as an already existing flow entry, the previous one is replaced by the one.

Flow entries may optionally have a \grd{properties}{block}. \textit{Properties} are additional metadata that can be attached to flow entries. There are currently two properties: \texttt{timeout} and \texttt{egress}. The \texttt{timeout} property specifies the duration (in seconds) that the flow entry will remain the table. The \texttt{egress} property specifies an egress port that can be accessed in the flow entry. This facilitates the \texttt{output egress} action within added flow entries (see \ref{guide:output}).

\textit{Initial flow entries}, that is, the flow entries within \grd{table}{initializer}, are inserted into tables before any packets are processed. Each initial flow entry is inserted with the order in which they are declared. There may only be one or less \grdd{miss}{flow}{declaration}.

\subsection{Event Declaration} \label{guide:event}

An event declaration has the following form:

\begin{minip}
\begin{grammar}
<event-declaration> ::=
\textit{event} <event-name> [ <requires-specifier> ]
<block-statement>
\end{grammar}
\end{minip}

An event declaration defines a special function, known as an \textit{event handler}, which has access to extractions (see \ref{guide:extract}) and can use actions (see \ref{guide:action}). They implicitly take a context (see \ref{guide:context}) as a parameter. These are used when an exceptional event has occurred and certain slower actions need to be applied outside of the fast path, e.g. adding and removing flow entries.

An event handler can only be invoked via the raise action. At this time, a \textit{copy} of the context is passed to the runtime. The runtime shall forward this context and event handler packaged together to the controller port. The controller port waits to receive these contexts and event handlers. It dispatches these contexts to be executed by the event handler in the control plane.
Any modifications to the copied context shall not apply to the original. For example, in the following, it is demonstrated that a field modified via \texttt{set} action only affects a copy and never the original packet.

\begin{lstlisting}
exact_table t1(eth.dst) {
	{ 0x12_34_56_78_90_ab } -> {
		// event1 tries to set eth.dst to 0x0
		raise event1;
		// eth.dst will still be 0x12_34_56_78_90_ab
		// after the raise action is finished because
		// only a copy is passed to event1.
	}
}

event event1 requires(eth.dst) {
	// This will not modify the original.
	// Only a copy of the context and packet are
	// operated on.
	set eth.dst = 0x0;
}
\end{lstlisting}

Event declarations are subject to meeting the \textit{requirements satisfaction} property (see \ref{guide:requirements}) of pipelines, even though they are not pipeline stages.

The execution of an event handler may be immediate or asynchronous. The behavior is runtime implementation specific. The user should have no expectations on the order of execution. 

\subsection{Port Declaration} \label{guide:port}

A port declaration has the following form:

\begin{minip}
\begin{grammar}
<port-declaration> ::=
"Port" <port-name> "[" <port-initializer> "]" ";"

<port-initializer> ::= "=" <port-expression>
\end{grammar}
\end{minip}

A port declaration may have an optional \grd{port}{initializer} that instantiates it with a port identifier. The \grd{port}{initializer} shall be a \grd{port}{expr} (see \ref{guide:port_expr}). If no initializer is given, the default is a port with identifier 0 (invalid port). Forwarding to the invalid port drops the packet.

\subsection{Variable Declarations} \label{guide:variables}

Variable declarations have the form:

\begin{minip}
\begin{grammar}
<variable-declaration> ::=
"var" <variable-name> ":" <type> [<variable-initializer>]";"

<variable-initializer> ::= "=" <expression>
\end{grammar}
\end{minip}

A variable declaration may have an optional \grd{variable}{initializer}. If this initializer is not given, the value of the variable object is default initialized. Default initialization of scalar types shall result in their objects having a binary value of zero.

For a variable declaration \texttt{var v1 : T = E1}, the type of object \texttt{v1} is \texttt{T}. The type of \texttt{E1} must be \texttt{T} or there shall be a type conversion sequence from \texttt{E1}'s type to \texttt{T}. 

\subsection{Function Declarations} \label{guide:function}

A function declaration has the following form:

\begin{minip}
\begin{grammar}
<function-declaration> ::=
"def" <function-name> "(" [<parameter-decl-sequence>] ")" "->" <type> <block-statement>

<parameter-declaration> ::= <parameter-name> ":" <type>
\end{grammar}
\end{minip}

A function \texttt{def F(P1 : T1, P2 : T2,..., Pn : Tn) -> T \{...\}} has function type (see \ref{guide:function_type}) \texttt{(T1, T2,...,Tn) -> T}.

The body of the function, given by \grd{block}{statement}, is the set of statements that get executed in order upon calling the function.

There may be multiple declarations of a function with the same name if and only if:

\begin{itemize}
\item Each function declaration has a different type.
\item Two function declarations of the same name, but different type, may not vary only in their return type.
\end{itemize}

\section{Specifiers} \label{guide:specifications}

Specifiers modify the semantics of a declaration. A sequence of specifiers may optionally appear at the beginning of a declaration. Not all specifiers are allowed on all declarations. Not all specifiers are allowed to appear together before the same declaration. Note that there is currently only one supported specifier. A number of other specifiers will eventually be introduced.

Specifiers have the following form:

\begin{grammar}
\singlespace
<specifier> ::= "foreign"
\end{grammar}

\subsection{Foreign Specifier} \label{guide:foreign_spec}

The \texttt{foreign} specifier can only appear before a \grd{function}{declaration}. This specifier says that a function has foreign linkage, that is, the function is not defined in this scope but rather in a different program. This function is said to be a \textit{foreign function}. The name of a foreign function is not mangled. 

Foreign functions cannot have a definition, that is, the function declaration cannot have a \grd{block}{statement}. This is the only case where a declaration varies from a definition.

\begin{lstlisting}
foreign def puts(char[]) -> int;
def f() -> int {
	puts("Hello world.");
}
\end{lstlisting}

Foreign linkage is most often used to link against the C runtime library. For example, the following introduces the \texttt{puts} C-function into global scope. Function calls to \texttt{puts} will call the C-function with the same name.

\section{Expressions} \label{guide:expr}

Expressions, generally speaking, perform some type of operation or computation which may return results or have side effects on the state of the program. Steve has the following expressions:

\begin{minip}
\begin{grammar}
<expression> ::=
<binary-expression>
\end{grammar}
\end{minip}

\subsection{Primary Expressions} \label{guide:primary_expr}

Primary expressions have no operators. They have the following form:

\begin{minip}
\begin{grammar}
<primary-expression> ::= 
<identifier-expression>
\alt <field-access-expression>
\alt <literal-expression>
\alt <port-expression>
\end{grammar}
\end{minip}

\subsection{Identifier Expressions} \label{guide:id_expr}

When an \gr{identifier} (see \ref{guide:identifiers}) is used where an \gr{expression} is expected, it is considered an identifier expression. Identifier expressions have the form:

\begin{minip}
\begin{grammar}
<identifier-expression> ::= <identifier>
\end{grammar}
\end{minip}

Identifier expressions refer to a specific declaration of that name. When used as an expression, an identifier returns the entity being referred to. If the identifier refers to an object (see \ref{guide:object}), the type of the object is \texttt{T}, and the identifier expression has \texttt{T\&} type. 

If an identifier expression is used where an rvalue is expected, then a reference-to-value conversion is applied (see \ref{guide:reftoval_conv}).

\subsection{Field Access Expression} \label{guide:field_access_expr}

When a field name (see \ref{guide:field_name}) is used where an \gr{expression} is expected, it is considered a field access expression. They have the form:

\begin{minip}
\begin{grammar}
<field-access-expression> ::= <field-name>
\end{grammar}
\end{minip}

Field access expressions refer to fields extracted by a decoder.They are similar to identifier expressions (see \ref{guide:id_expr}), except they specifically refer to extractions.

A field access expression may only occur within the body of a decoder declaration (see \ref{guide:decoder}), a flow declaration (see \ref{guide:tables}), or an event declaration (see \ref{guide:event}). In addition to these limitations, a field access expression may only occur:

\begin{itemize}
\item In a decoder declaration if and only if an extract declaration (see \ref{guide:extract}) extracts a field with the same field name before the field access expression's use.

\item In a flow declaration if and only if the table containing the flow uses the same field name as a key, or lists it in its requires specifier.

\item In an event declaration if and only if the same field name is in its requires specifier.
\end{itemize}

If the type of the extraction is \texttt{T}, then the type of a field access expression referring to that extraction shall be \texttt{T\&}. When the value of that field is required, then a reference-to-value conversion (see \ref{guide:reftoval_conv}) is applied to the field access expression.

\subsection{Port Expressions} \label{guide:port_expr}

A port expression is either an identifier which refers to a port declaration, or a keyword referring to a number of reserved port names. They have the form:

\begin{minip}
\begin{grammar}
<port-expression> ::= <port-id>
\alt <input-port-expression>
\alt <input-physical-port-expression>
\alt <egress-port-expression>
\alt <all-port-expression>
\alt <reflow-port-expression>

<input-port-expression> ::= "in_port"

<input-physical-port-expression> ::= "in_phys_port"

<egress-port-expression> ::= "egress"

<all-port-expression> ::= "all"

<reflow-port-expression> ::= "reflow"
\end{grammar}
\end{minip} 

An \grdd{input}{port}{expression} shall evaluate to the packet's ingress port.
An \grddd{input}{physical}{port}{expression} shall evaluate to the packet's physical ingress port.

An \grdd{egress}{port}{expression} shall evaluate the egress port property set in a flow entry's properties block (see \ref{guide:tables}). It shall only occur in the body of a flow entry whose egress property has been set.

The \grdd{all}{port}{expression} shall evaluate to the all port. The all port is a logical port which represents every port on the system.

The \grdd{reflow}{port}{expression} shall evaluate to the reflow port. The reflow port is a logical port which represent re-entry into the pipeline. When output to this port, a packet's context data is reset and the packet is sent back to the beginning of the pipeline.

\subsection{Literal Expressions} \label{guide:literal_expr}

Literal expressions are expressions which represent constant values. Steve supports decimal integer, binary, hexadecimal, character, and string literals.

\subsection{Integer Literals}

Decimal, binary and hexadecimal literals have the following form:

\begin{minip}
\begin{grammar}
<literal-expression> ::=
<decimal-literal>
\alt <binary-literal>
\alt <hexadecimal-literal>

<decimal-digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<hexadecimal-digit> ::= "_" | <decimal-digit> | "a" | "b" | "c" | "d" | "e" | "f"            

<binary-digit> ::= "_" | "0" | "1"

<decimal-literal> ::=
<decimal-digit>+

<hexadecimal-literal> ::=
"0x" <hexadecimal-digit>+

<binary-literal> ::=
"0b" <binary-digit>+
\end{grammar}
\end{minip}

Hexadecimal, binary, and decimal integer literals may be used interchangeably to represent the same integer value. The type of an integer literal is by default 32 bit signed integer (see \ref{guide:integer_type}). Hexadecimal and binary literals may optionally use the underscore(\_) as an organizational separator. This is purely lexical and has no effect on the value of the literal. For example:

\begin{lstlisting}
10 // Integer literal 10
0b1010 // Binary literal 10
0b10_10 // Binary literal 10 w/ underscore
0x0A  // Hexadecimal literal 10
0x00_0A // Hexadecimal literal 10 w/ underscore  
\end{lstlisting}

\subsection{Boolean Literals}

Boolean literals have boolean type (see \ref{guide:bool_type}) and have the values \texttt{true} or \texttt{false}. They have the following form:

\begin{minip}
\begin{grammar}
<boolean-literal> ::= "true" | "false"
\end{grammar}
\end{minip}

\subsection{Character and String Literals}

Character and string literals are rarely if ever used in Steve at the moment. Its not common to need strings in a language directed towards packet processing, which is largely binary data. However, it may become useful in the future if Steve chooses to support text-based protocols.  Character and string literals have the following form:

\begin{minip}
\begin{grammar}
<character-literal> "\'" <letter> "\'"

<string-literal> ::= "\"" <letter>+ "\""

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z"
\end{grammar}
\end{minip}

A character literal has character type (see \ref{guide:char_type}). A string literal has character block type (see \ref{guide:block_type}).
For example:

\begin{lstlisting}
var c1 : char = 'a';
var s1 : char[] = "Hello, world."; 
\end{lstlisting}

\subsection{Postfix Expressions} \label{guide:postfix_expr}

Postfix expressions current only include call expressions and array subscript expressions.

\begin{minip}
\begin{grammar}
<postfix-expression> ::= 
<call-expression>
\alt <subscript-expression>
\alt <primary-expression>
\end{grammar}
\end{minip}

\subsection{Call Expression} \label{guide:call_expr}

Call expressions are used to call a function and returns the result of the function. They have the following form:

\begin{minip}
\begin{grammar}
<call-expression> ::= <function-id> "(" [<expression-sequence>] ")"
\end{grammar}
\end{minip}

The type of a call expression is the return type of the function referred to by \grd{function}{id}. The number of expressions in \grd{expression}{sequence} must match the number of parameters required. Their types must also match the types of corresponding parameters, or there must exist a conversion to the corresponding type.

\subsection{Array Subscript Expression} \label{guide:subscript_expr}

Array subscript expressions return the value of the element in a given position within an array or block. They have the form:

\begin{minip}
\begin{grammar}
<subscript-expression> ::= <variable-id> "[" <expression> "]"
\end{grammar}
\end{minip}

The \gr{expression} must have integer type.
The type of the object referred to by \grd{variable}{id} must be array or block. If the evaluation of \gr{expression} is larger than the extent of the array or block, or it is negative, then behavior is undefined.

\subsection{Unary Expressions} \label{guide:unary_expr}

Unary expressions have a single operator and a single operand. They have the following form:

\begin{minip}
\begin{grammar}
<unary-expression> ::= 
<not-expression>
\alt <negative-expression>
\alt <postfix-expression>
\end{grammar}
\end{minip}

\subsection{Not Expression} \label{guide:not_expr}

The not expression is used to take the logical-not of a boolean value. The not expression has the form: 

\begin{minip}
\begin{grammar}
<not-expression> ::= "!" <expression> 
\end{grammar}
\end{minip}

Given a not expression \texttt{!N}, both \texttt{N} and the result of \texttt{!N} shall have boolean type. If the value of \texttt{N} is \texttt{true}, the result shall be \texttt{false}. If the value of \texttt{N} is \texttt{false}, the result shall be \texttt{true}.

\subsection{Negative Expression} \label{neg_expr_guide}

The negative expression is used to change the sign of an integer value. Negative expressions have the following form:

\begin{minip}
\begin{grammar}
<negative-expression> ::= "-" <expression>
\end{grammar}
\end{minip}

Given an expression \texttt{-N}, \texttt{N} shall have integer type and \texttt{-N} shall have signed integer type. The evaluation shall be equal to \texttt{N * -1}.

\subsection{Binary Expressions} \label{guide:binary_expr}

Binary expressions have a single operator and two operands. They have the following form:

\begin{minip}
\begin{grammar}
<binary-expr> ::= <multiplicative-expression>
\alt <additive-expression>
\alt <bitshift-expression>
\alt <ordering-expression>
\alt <equality-expression>
\alt <bitwise-and-expression>
\alt <bitwise-xor-expression>
\alt <bitwise-or-expression>
\alt <logical-and-expression>
\alt <logical-or-expression>
\alt <unary-expression>
\end{grammar}
\end{minip}

The precedence of each operator is enforced by the grammar. The operators with the highest precedence (i.e. the lowest number) get evaluated first. Operator precedence is as follows:

\begin{enumerate}
\singlespacing
\item Unary expressions
\item Multiplicative expressions
\item Additive expressions
\item Bit-shift expressions
\item Ordering expressions
\item Equality expressions
\item Bit-wise And
\item Bit-wise Xor
\item Bit-wise Or
\item Logical And
\item Logical Or
\end{enumerate}

\subsection{Multiplicative Expression} \label{guide:mult_expr}

Multiplicative expressions perform multiplication, division, and modulo operations. They have the following form:

\begin{minip}
\begin{grammar}
<multiplicative-expression> ::= <multiplicative-expression> 
<multiplicative-operator> <unary-expression>
\alt <unary-expression>

<multiplicative-operator> ::= "*" | "/" | "\%"
\end{grammar}
\end{minip}

Both operands must be of integer type. Arithmetic conversion (see \ref{guide:arith_conv}) is applied to both operands so that they both have type \texttt{T}, where T is the smallest integer type capable of representing both operands. The result shall have type \texttt{T}.

\subsection{Additive Expression} \label{guide:add_expr}

Additive expressions perform addition and subtraction operations. They have the following form: 

\begin{minip}
\begin{grammar}
<additive-expression> ::= <additive-expression> 
<add-operator> <multiplicative-expression>
\alt <multiplicative-expression>

<add-operator> ::= "+" | "-"
\end{grammar}
\end{minip}

Both operands must be of integer type. Arithmetic conversion (see \ref{guide:arith_conv}) is applied to both operands so that they both have type \texttt{T}, where \texttt{T} is the smallest integer type capable of representing both operands. The result shall have type \texttt{T}.

\subsection{Bit-shift Expression} \label{guide:bitshift_expr}

The bit-shift expression shifts the bits of an integer either left or right. They have the form:

\begin{minip}
\begin{grammar}
<bitshift-expression> ::= <bitshift-expression> 
<shift-operator> <additive-expression>
\alt <additive-expression>

<shift-operator> ::= "<<" | ">>"
\end{grammar}
\end{minip}

Given a bit-shift expression \texttt{E1 << E2} or \texttt{E1 >> E2}, the result is E1 shifted either left or right, respectively. Vacated bit positions are filled with zeros. Bits shifted off either end are discarded. The type of both operands and the result shall be unsigned integer type.

\subsection{Ordering and Equality Expression} \label{guide:ordering_expr}

Ordering expressions check whether or not the value of two operands are: less than, less than or equal, greater than, or greater than or equal. Equality expressions check whether or not the value of two operands are equal or not equal. The result is always \texttt{true} or \texttt{false}. These expressions have the form: 

\begin{minip}
\begin{grammar}
<ordering-expression> ::= <ordering-expression> 
<ordering-operator> <bitshift-expression>
\alt <bitshift-expression>

<ordering-operator> ::= "<" | "<=" | ">" | ">="

<equality-expression> ::= <equality-expression>
<equality-operator> <ordering-expression>
\alt <ordering-expression>

<equality-operator> ::= "==" | "!="
\end{grammar}
\end{minip}

Given a type \texttt{T}, assuming the type of the first operand is \texttt{T1}, and the type of the second is \texttt{T2}, there must exist a sequence of conversions from \texttt{T1} to \texttt{T} and from \texttt{T2} to \texttt{T}. In other words, the types of both operands must be convertible to some common type. The type of the result shall be boolean type.

\subsection{Bitwise Expressions} \label{guide:bitwise_expr}

The bitwise expressions perform bitwise AND, XOR, or OR operations.
They have the form:

\begin{minip}
\begin{grammar}
<bitwise-and-expression> ::= <bitwise-and-expression> "\&" <equality-expression>
\alt <equality-expression>

<bitwise-xor-expression> ::= <bitwise-xor-expression> "|" <bitwise-and-expression>
\alt <bitwise-and-expression>

<bitwise-or-expression> ::= <bitwise-or-expression> "^" <bitwise-xor-expression>
\alt <bitwise-xor-expression> 
\end{grammar}
\end{minip}

Both operands must be of integer type. Arithmetic conversion (see \ref{guide:arith_conv}) is applied to both operands so that they both have type \texttt{T}, where T is the smallest integer type capable of representing both operands. The type of the result shall be \texttt{T}.

\subsection{Logical And and Logical Or Expression} \label{guide:logical_expr}

The type of both operands in logical-and and logical-or expressions shall be boolean type. The result shall have boolean type. They have the following form:

\begin{minip}
\begin{grammar}
<logical-and-expression> ::= <logical-and-expression> "\&\&" <bitwise-or-expression>
\alt <bitwise-or-expression>

<logical-or-expression> ::= <logical-or-expression> "||" <logical-and-expression>
\alt <logical-and-expression> 
\end{grammar}
\end{minip}



\section{Statements} \label{guide:statements}

Statements are pieces of code which are executed in sequence, and have some side-effects, but unlike expressions do not evaluate to any value or return any results. They have the form:

\begin{minip}
\begin{grammar}
<statement> ::=
     <block-statement>
\alt <expression-statement>
\alt <declaration-statement>
\alt <assign-statement>
\alt <if-then-statement>
\alt <if-else-statement>
\alt <match-statement>
\alt <case-statement>
\alt <while-statement>
\alt <break-statement>
\alt <continue-statement>
\alt <return-statement>
\alt <action>
\end{grammar}
\end{minip}

\subsection{Block Statement} \label{guide:block_stmt}

A block statement is a compound statement which contains a sequence of statements that are executed in order. A block statement introduces block scope (see \ref{guide:block_scope}). Block statements may be nested within each other. A block statement may contain no statements It has the form: 

\begin{minip}
\begin{grammar}
<block-statement> ::=
"{" [<statement>] "}"
\end{grammar}
\end{minip} 

\subsection{Expression Statement} \label{guide:expr_stmt}

An expression statement executes an expression. It has the form:

\begin{minip}
\begin{grammar}
<expression-statement> ::=
<expression> ";"
\end{grammar}
\end{minip}

The \gr{expression} is executed and any return value it might have is discarded. It may have had side effects on the program.

\subsection{Declaration Statement} \label{guide:decl_stmt}

A declaration statement introduces a declaration at compile time. Declaration statements have the following form:

\begin{minip}
\begin{grammar}
<declaration-statement> ::=
<declaration> ";"
\end{grammar}
\end{minip}

Because a statement generally only appears in a block statement, global declarations (see \ref{guide:declarations}) may not appear in declaration statements. 

\subsection{Assignment Statements} \label{guide:assign_stmt}

Assignment statements allow the contents of one object to be replaced with the contents of another. Assignment statements have the form:

\begin{minip}
\begin{grammar}
<assign-statement> ::=
<identifier-expression> "=" <expression> ";"
\end{grammar}
\end{minip}

The \grd{identifier}{expression} must refer to a valid object declaration. That object must be assignable. Only variables and ports are assignable. When an assignment statement is executed, the result \gr{expression} shall be copied into that object.

Given an assignment statement \texttt{E1 = E2}, \texttt{E1} must have type \texttt{T\&}. \texttt{E2} must have type \texttt{T} or there must exist a conversion sequence to \texttt{T}.

\subsection{If and If-else}

If and if-else statements have the same semantics as almost all other languages. They have the form:

\begin{minip}
\begin{grammar}
<if-statement> ::= "if" "("<expression>")" <statement>

<if-else-statement> ::= "if" "("<expression>")" <statement> "else" <statement>
\end{grammar}
\end{minip}

Given an if statement of the form \texttt{if (E1) S1}, the type of \texttt{E1} must be boolean. \texttt{S1} will only execute if the value of \texttt{E1} is \texttt{true}.

For an if-else statement of the form \texttt{if (E1) S1 else S2}, the type of \texttt{E1} must be boolean. \texttt{S1} will only execute if the value of \texttt{E1} is \texttt{true}, otherwise \texttt{S2} executes.

\subsection{Match}

Match statements are similar to C-like switch statements with some minor differences. They have the form:

\begin{minip}
\begin{grammar}
<match-statement> ::= "match" "("<expression>")" <match-body>

<match-body> ::= "{" <case-statement>+ "}"

<case-statement> ::= <case-label> ":" <case-body>

<case-label> ::= 
"case" <literal-expression> ":"
\alt "miss" ":"

<case-body> ::= <statement> 
\end{grammar}
\end{minip}

Match statements do \textit{not} have fall-through behavior like switch statements. The condition \gr{expression} is evaluated; if the value is equal to the value of a \grd{case}{label}, then the corresponding \grd{case}{body} is executed. The match statement then completes.

The type of \gr{expression} in \grd{match}{statement} shall be integer type \texttt{T}. The type of \grd{literal}{expression} in all \grd{case}{statements} shall also be \texttt{T}.

\subsection{While Loops} \label{guide:while_stmt}

While loops work in the same way as all C-like languages. They have the following form:

\begin{minip}
\begin{grammar}
<while-statement> ::= "while" "("<expression>")" <statement>
\end{grammar}
\end{minip}

The type of \gr{expression} shall be boolean. The value of \gr{expression} is evaluated at the beginning of every loop. While it evaluates to \texttt{true}, \gr{statement} shall be executed. 

\subsection{Break and Continue} \label{guide:break_continue}

Break and continue may only appear in certain contexts. As of now, they may only appear within a while statement.

A break statement can be used to exit a loop prematurely. When a break statement is executed, the program branches to and executes the statement immediately following the while statement.

A continue statement can be used to branch to the first statement in the while loop if \gr{statement} is a block statement. 
These have the form:

\begin{minip}
\begin{grammar}
<break-statement> ::= "break" ";"

<continue-statement> ::= "continue" ";"
\end{grammar}
\end{minip}

\subsection{Return Statement} \label{guide:return_stmt}

A return statement returns a value from a function and terminates the execution of that function. It has the form:

\begin{minip}
\begin{grammar}
<return-statement> ::= "return" <expression> ";"
\end{grammar}
\end{minip}

Return statements may only appear within a function body. Executing a return statement shall evaluate \gr{expression} and a copy of its value is returned to the caller. The type of \gr{expression} shall be the same as the function's return type, or there shall exist a conversion sequence to the return type.

\section{Actions} \label{guide:action}

An action is a special statement that may affect the state of a packet, its context, or a table. Because actions are specific to packet handling, an action may only appear in the body of a decoder, event, or flow entry. Actions have the form:

\begin{minip}
\begin{grammar}
<action-statement> ::=
<decode-action>
\alt <goto-action>
\alt <output-action>
\alt <flood-action>
\alt <drop-action>
\alt <clear-action>
\alt <set-field-action>
\alt <insert-flow-action>
\alt <remove-flow-action>
\alt <raise-action>
\alt <write-action>
\end{grammar}
\end{minip}


\subsection{Decode Action} \label{guide:decode_action}

The decode action is a stage transitioning action. It transitions the context (see \ref{guide:context}) from the current stage (which may be a decoder, table, or event) to a new decoding stage. It has the form:

\begin{minip}
\begin{grammar}
<decode-action> ::=
"decode" <decoder-id> [<advance-specifier>] ";"

<advance-specifier> ::= "advance" <expression>
\end{grammar}
\end{minip}

A decode action transfers control of the context it is operating on to the decoder named by \grd{decoder}{id}. The semantics of transferring control are similar to calling a function and passing the context as a parameter. If a decode action appears within the body of a decoder (see \ref{guide:decoder}), then a view advance (see \ref{guide:decoder_view}) is applied before the decode action transfers control to the next stage.

A decode action may optionally have an \grd{advance}{specifier}, if and only if it occurs within a decoder. Given a decode action of the form \texttt{decode d1 advance E1}, the type of \texttt{E1} shall be unsigned integer. The result of E1 (in bytes) shall be added to the view index. The reason the shift is by bytes and not by bits is because generally speaking, headers are byte aligned.

\subsection{Goto Action} \label{guide:goto}

The goto action is a stage transition action, similar to the decode action. A goto action transitions the context (see \ref{guide:context}) from the current stage (which may be a decoder, table, or event) to a new table matching stage.

\begin{minip}
\begin{grammar}
<goto-action> ::=
"goto" <table-id> [<advance-specifier>] ";"
\end{grammar}
\end{minip}

A goto action transfers control of the context it is operating on to the table matching stage referred to by \grd{table}{id}. The context is dispatched to the runtime (see \ref{ch:flowpath}) which composes the query key from extracted fields. The query key is then matched against flow entries. All matching flow entries are collected. The one with the highest priority is executed. Because Steve currently only supports exact match tables, there will only ever be one match. The flow entry's actions are then executed. This body may include another stage transitioning action.

If a goto action appears within the body of a decoder (see \ref{guide:decoder}), then a view advance (see \ref{guide:decoder_view}) is applied before transferring to the table matching stage.

A goto action may optionally have an \grd{advance}{specifier}, if and only if it occurs with the body of a decoder. Given a goto action of the form \texttt{goto d1 advance E1}, the type of \texttt{E1} shall be unsigned integer. The result of E1 (in bytes) shall be added to the view index.

\subsection{Output Action} \label{guide:output}

An output action forwards a copy of the packet to the designated port. It has the form:

\begin{minip}
\begin{grammar}
<output-action> ::= "output" <port-expression> ";"
\end{grammar}
\end{minip}

When an output action is executed, control of the packet is returned to the runtime (see \ref{ch:flowpath}) which creates a \textit{copy} of the packet. The copy is forwarded by the runtime through the port given by \grd{port}{expression}.

If destination is the \texttt{all} port, copies of the packet are sent on all known ports on the system. If destination is the \texttt{flood} port, copies of the packet are sent on all ports except the packet's ingress port. If the destination is the \texttt{reflow} port, then the runtime will send the packet back to the beginning of the pipeline. If the destination is a specific port, the packet is forwarded on that port. After this completes, pipeline processing continues on the original packet.

The output semantics here are a little unintuitive. Some may have the expectation that outputting a packet terminates pipeline processing and immediately forwards the original. This is not the case. Pipeline processing only terminates on the original packet if a stage does not send it to another stage, and does not apply any more actions to it. 

At this point egress processing (see \ref{egress_desc}) would begin. Any actions written to the action list would be executed. Written output actions modify the egress port field in the context. The original packet is forwarded to the port saved in this field.

\subsection{Drop Action} \label{guide:drop}

The drop action is used to delete the packet and immediately terminate pipeline processing. The drop action has the following form:

\begin{minip}
\begin{grammar}
<drop-action> ::= "drop" ";"
\end{grammar}
\end{minip}

The drop action is implicitly applied to any packet who has reached egress processing (see \ref{egress_desc}), but which does not have an output action (see \ref{guide:output}) written to its action list.

\subsection{Clear Action} \label{guide:clear}

A clear action removes all actions from the context's action list. If the action list is empty, nothing is done. The clear action has the following form:

\begin{minip}
\begin{grammar}
<clear-action> ::= "clear" ";"
\end{grammar}
\end{minip}

\subsection{Set Action} \label{guide:set_field}

A set action copies a given value into a given field. The set action has the following form:

\begin{minip}
\begin{grammar}
<set-action> ::= "set" <field-access-expression> "=" <expression> ";"
\end{grammar}
\end{minip}

If \grdd{field}{access}{expression} has type \texttt{T\&}, then the result of evaluating \gr{expression} shall have type \texttt{T}, or there shall exist a conversion sequence from its type to \texttt{T}. This prevents the length of the value from exceeding the length of the field.

\subsection{Insert Action} \label{guide:insert_flow}

Insert action will add a new flow entry into a table. They may also be used to update an existing flow entry into a table. They have the form:

\begin{minip}
\begin{grammar}
<insert-action> ::= "insert" "into" <table-id> <flow-declaration> ";"
\end{grammar}
\end{minip}

The flow entry represented by the \grd{flow}{declaration} is inserted into the table referred to by \grd{table}{id}. Each \grd{match}{field} in \grdd{match}{field}{sequence} is evaluated. The number and type of each \grd{match}{field} must match the number and type of each \grd{key}{field} in the table. Type conversions may be applied to the types to make them match. 

If a flow entry already in that table has the same match fields as the flow entry being inserted, then the prior one is replaced with the new one. All properties of the old flow entry are replaced with the properties of the inserted flow entry. If no properties are given in the inserted flow entry, the properties are the default values (no timeout and no egress port).

A miss case flow entry may be given as \grd{flow}{declaration}. The same insertion semantics apply here as well.

\subsection{Remove Action} \label{guide:remove_flow}

A remove action will remove an existing flow entry from a table. They have the form:

\begin{minip}
\begin{grammar}
<remove-action> ::= "remove" "from" <table-id> <match-field-sequence> ";"
\alt <remove-miss-action>
\end{grammar}
\end{minip}

Each \grd{match}{field} in \grdd{match}{field}{sequence} is evaluated. The table referred to by \grd{table}{id} is searched for all flow entries with the same match fields. All flow entries found are removed from the table. If none are found, nothing is done.

Miss case flow entries may also be removed from a table. Miss case removal has the form: 

\begin{minip}
\begin{grammar}
<remove-miss-action> ::= "remove" "from" <table-id> "miss" ";"
\end{grammar}
\end{minip}

When a miss case is removed, it is replaced by the default miss case. The default miss case has no timeout and no egress port. Its body has exactly one action: the drop action.

\subsection{Write Action} \label{guide:write}

A write action writes another action to a context's action list. They have the form:

\begin{minip}
\begin{grammar}
<write-action> ::= "write" <action-statement> ";"
\end{grammar}
\end{minip}

All actions written to the context's are executed upon egress processing (see \ref{egress_desc}) in the order with which they were written. Written actions may have different semantics when executed during egress processing. Not all actions can be written. The actions which are writable may expand in later versions. The following are writable actions and their semantics during egress processing.

\begin{itemize}
\item \textit{Set}. The set action works same as it would if executed immediately (see \ref{guide:write}). 

\item \textit{Output}. The output action lists the egress port field in the context. It does not immediately forward the packet upon execution. When every action in the action list is completed, the original packet is forwarded (not a copy).
\end{itemize}

\subsection{Raise Action} \label{guide:raise}

A raise action is used to raise an event which causes the context to be dispatched to the controller port. The packet is then sent to an event handler with the same name. The event handler gets executed by the control plane. The raise action has the form:

\begin{minip}
\begin{grammar}
<raise-action> ::= "raise" <event-id> [<advance-specifier>] ";"
\end{grammar}
\end{minip}

When executed, the runtime (see \ref{ch:flowpath}) will create a message containing the context and the event handler function. This message is sent to the controller port. The controller port is connected to a controller. That controller shall execute the event handler, passing in the context as the argument. This action may be taken synchronously or asynchronously. The choice is runtime implementation specific.

